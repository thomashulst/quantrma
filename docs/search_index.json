[["index.html", "Quantitative Research Methods &amp; Analysis Preface Important notes", " Quantitative Research Methods &amp; Analysis Original Author: Matthew J. C. Crump Adapted materials for chapter 1 and chapters 4-6 from Danielle Navarro Edited for EUC by Thomas Hulst and Thanos Kostopoulos Last Compiled 2021-02-16 Preface Important notes This is a free textbook for the course “Quantitative Research Methods and Analysis” at EUC. This textbook was adapted from “Answering questions with data” by Mattew J.C. Crump and “Learning statistics with R” by Danielle Navarro and extended with our own materials. The original text is part of a larger OER (Open Educational Resource) course for teaching undergraduate statistics in psychology. As such, the text assumes you are a psychology student and many of the examples are drawn from the field of psychology. This does not mean that this course is only useful for you if you have an interest in psychology. The field of psychology will serve as a vehicle to teach you important concepts and skills in quantitative research methods and data analysis, but the concepts and skills taught are universal. This textbook is accompanied by the lab manual found here. Attributions This textbook was adapted from Crump, M. J. C., Navarro, D., &amp; Suzuki, J. (2019, June 5). Answering Questions with Data (Textbook): Introductory Statistics for Psychology Students. https://doi.org/10.17605/OSF.IO/JZE52 Several chapters were adapted from Danielle Navarro’s wonderful free textbook. The citation for that textbook is: Navarro, D. (2018). Learning statistics with R: A tutorial for psychology students and other beginners (version 0.6). The website is https://learningstatisticswithr.com CC BY-SA 4.0 license All resources are released under a creative commons licence CC BY-SA 4.0. Click the link to read more about the license, or read more below: This license means that you are free to: Share: copy and redistribute the material in any medium or format Adapt: remix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution: You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike: If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions: You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. "],["week-1-introductionadapted1.html", " 1 Week 1: Introduction1 1.1 The curse of belief bias 1.2 The cautionary tale of Simpson’s paradox 1.3 Statistics in psychology3 1.4 Statistics in everyday life 1.5 There’s more to research methods than statistics 1.6 A brief introduction to research methods 1.7 Some thoughts about measurement 1.8 Operationalization: defining your measurement 1.9 Assessing the reliability and validity of a measurement 1.10 Forms of measurement error 1.11 The role of variables: predictors and outcomes 1.12 That’s it for this week", " 1 Week 1: Introduction1 To the surprise of many students, statistics is a fairly significant part of any bachelor program at university. To the surprise of no-one, statistics is very rarely the favorite part of one’s bachelor studies. After all, if you really loved the idea of doing statistics, you’d probably be enrolled in a statistics program right now, not a university college. So, not surprisingly, there’s a pretty large proportion of the student base that isn’t happy about the fact university studies have so much statistics in it. In view of this, I thought that the right place to start might be to answer some of the more common questions that people have about statistics… A big part of this issue at hand relates to the very idea of statistics. What is it? What’s it there for? And why are scientists so bloody obsessed with it? These are all good questions, when you think about it. So let’s start with the last one. As a group, scientists seem to be bizarrely fixated on running statistical tests on everything. In fact, we use statistics so often that we sometimes forget to explain to people why we do. It’s a kind of article of faith among scientists – and especially social scientists – that your findings can’t be trusted until you’ve done some statistics. Undergraduate students might be forgiven for thinking that we’re all completely mad, because no-one takes the time to answer one very simple question: Why do you do statistics? Why don’t scientists just use common sense? It’s a naive question in some ways, but most good questions are. There’s a lot of good answers to it, but for my money, the best answer is a really simple one: we don’t trust ourselves enough. We worry that we’re human, and susceptible to all of the biases, temptations and frailties that humans suffer from. Much of statistics is basically a safeguard. Using “common sense” to evaluate evidence means trusting gut instincts, relying on verbal arguments and on using the raw power of human reason to come up with the right answer. Most scientists don’t think this approach is likely to work. Is it plausible to think that this “common sense” approach is very trustworthy? Verbal arguments have to be constructed in language, and all languages have biases – some things are harder to say than others, and not necessarily because they’re false (e.g., quantum electrodynamics is a good theory, but hard to explain in words). The instincts of our “gut” aren’t designed to solve scientific problems, they’re designed to handle day to day inferences – and given that biological evolution is slower than cultural change, we should say that they’re designed to solve the day to day problems for a different world than the one we live in. Most fundamentally, reasoning sensibly requires people to engage in “induction,” making wise guesses and going beyond the immediate evidence of the senses to make generalisations about the world. If you think that you can do that without being influenced by various distractors, well, I have a bridge in Brooklyn I’d like to sell you. Heck, as the next section shows, we can’t even solve “deductive” problems (ones where no guessing is required) without being influenced by our pre-existing biases. 1.1 The curse of belief bias People are mostly pretty smart. We’re certainly smarter than the other species that we share the planet with (though many people might disagree). Our minds are quite amazing things, and we seem to be capable of the most incredible feats of thought and reason. That doesn’t make us perfect though. And among the many things that psychologists have shown over the years is that we really do find it hard to be neutral, to evaluate evidence impartially and without being swayed by pre-existing biases. A good example of this is the belief bias effect in logical reasoning: if you ask people to decide whether a particular argument is logically valid (i.e., conclusion would be true if the premises were true), we tend to be influenced by the believability of the conclusion, even when we shouldn’t. For instance, here’s a valid argument where the conclusion is believable: No cigarettes are inexpensive (Premise 1) Some addictive things are inexpensive (Premise 2) Therefore, some addictive things are not cigarettes (Conclusion) And here’s a valid argument where the conclusion is not believable: No addictive things are inexpensive (Premise 1) Some cigarettes are inexpensive (Premise 2) Therefore, some cigarettes are not addictive (Conclusion) The logical structure of argument #2 is identical to the structure of argument #1, and they’re both valid. However, in the second argument, there are good reasons to think that premise 1 is incorrect, and as a result it’s probably the case that the conclusion is also incorrect. But that’s entirely irrelevant to the topic at hand: an argument is deductively valid if the conclusion is a logical consequence of the premises. That is, a valid argument doesn’t have to involve true statements. On the other hand, here’s an invalid argument that has a believable conclusion: No addictive things are inexpensive (Premise 1) Some cigarettes are inexpensive (Premise 2) Therefore, some addictive things are not cigarettes (Conclusion) And finally, an invalid argument with an unbelievable conclusion: No cigarettes are inexpensive (Premise 1) Some addictive things are inexpensive (Premise 2) Therefore, some cigarettes are not addictive (Conclusion) Now, suppose that people really are perfectly able to set aside their pre-existing biases about what is true and what isn’t, and purely evaluate an argument on its logical merits. We’d expect 100% of people to say that the valid arguments are valid, and 0% of people to say that the invalid arguments are valid. So if you ran an experiment looking at this, you’d expect to see data like this: conlusion feels true conclusion feels false argument is valid 100% say “valid” 100% say “valid” argument is invalid 0% say “valid” 0% say “valid” If the data looked like this (or even a good approximation to this), we might feel safe in just trusting our gut instincts. That is, it’d be perfectly okay just to let scientists evaluate data based on their common sense, and not bother with all this murky statistics stuff. By now you probably know where this is going. In a classic study, Evans, Barston, and Pollard (1983) ran an experiment looking at exactly this. What they found is that when pre-existing biases (i.e., beliefs) were in agreement with the structure of the data, everything went the way you’d hope: conlusion feels true conclusion feels false argument is valid 92% say “valid” – argument is invalid – 8% say “valid” Not perfect, but that’s pretty good. But look what happens when our intuitive feelings about the truth of the conclusion run against the logical structure of the argument: conlusion feels true conclusion feels false argument is valid 92% say “valid” 46% say “valid” argument is invalid 92% say “valid” 8% say “valid” Oh dear, that’s not as good. Apparently, when people are presented with a strong argument that contradicts our pre-existing beliefs, we find it pretty hard to even perceive it to be a strong argument (people only did so 46% of the time). Even worse, when people are presented with a weak argument that agrees with our pre-existing biases, almost no-one can see that the argument is weak (people got that one wrong 92% of the time!) If you think about it, it’s not as if these data are horribly damning. Overall, people did do better than chance at compensating for their prior biases, since about 60% of people’s judgements were correct (you’d expect 50% by chance). Even so, if you were a professional “evaluator of evidence,” and someone came along and offered you a magic tool that improves your chances of making the right decision from 60% to (say) 95%, you’d probably jump at it, right? Of course you would. Thankfully, we actually do have a tool that can do this. But it’s not magic, it’s statistics. So that’s reason #1 why scientists love statistics. It’s just too easy for us to “believe what we want to believe”; so if we want to “believe in the data” instead, we’re going to need a bit of help to keep our personal biases under control. That’s what statistics does: it helps keep us honest. 1.2 The cautionary tale of Simpson’s paradox The following is a true story (I think…). In 1973, the University of California, Berkeley had some worries about the admissions of students into their postgraduate courses. Specifically, the thing that caused the problem was that the gender breakdown of their admissions, which looked like this: Number of applicants Percent admitted Males 8442 44% Females 4321 35% and they were worried about being sued. Given that there were nearly 13,000 applicants, a difference of 9% in admission rates between males and females is just way too big to be a coincidence. Pretty compelling data, right? And if I were to say to you that these data actually reflect a weak bias in favour of women (sort of!), you’d probably think that I was either crazy or sexist.2 When people started looking more carefully at the admissions data (Bickel, Hammel, and O’Connell 1975) they told a rather different story. Specifically, when they looked at it on a department by department basis, it turned out that most of the departments actually had a slightly higher success rate for female applicants than for male applicants. The table below shows the admission figures for the six largest departments (with the names of the departments removed for privacy reasons): Table 1.1: Admission figures for the six largest departments by gender Department Male Applicants Male Percent Admitted Female Applicants Female Percent admitted A 825 62% 108 82% B 560 63% 25 68% C 325 37% 593 34% D 417 33% 375 35% E 191 28% 393 24% F 272 6% 341 7% Remarkably, most departments had a higher rate of admissions for females than for males! Yet the overall rate of admission across the university for females was lower than for males. How can this be? How can both of these statements be true at the same time? Here’s what’s going on. Firstly, notice that the departments are not equal to one another in terms of their admission percentages: some departments (e.g., engineering, chemistry) tended to admit a high percentage of the qualified applicants, whereas others (e.g., English) tended to reject most of the candidates, even if they were high quality. So, among the six departments shown above, notice that department A is the most generous, followed by B, C, D, E and F in that order. Next, notice that males and females tended to apply to different departments. If we rank the departments in terms of the total number of male applicants, we get A\\(&gt;\\)B\\(&gt;\\)D\\(&gt;\\)C\\(&gt;\\)F\\(&gt;\\)E (the “easy” departments are in bold). On the whole, males tended to apply to the departments that had high admission rates. Now compare this to how the female applicants distributed themselves. Ranking the departments in terms of the total number of female applicants produces a quite different ordering C\\(&gt;\\)E\\(&gt;\\)D\\(&gt;\\)F\\(&gt;\\)A\\(&gt;\\)B. In other words, what these data seem to be suggesting is that the female applicants tended to apply to “harder” departments. And in fact, if we look at all Figure 1.1 we see that this trend is systematic, and quite striking. This effect is known as Simpson’s paradox. It’s not common, but it does happen in real life, and most people are very surprised by it when they first encounter it, and many people refuse to even believe that it’s real. It is very real. And while there are lots of very subtle statistical lessons buried in there, I want to use it to make a much more important point …doing research is hard, and there are lots of subtle, counterintuitive traps lying in wait for the unwary. That’s reason #2 why scientists love statistics, and why we teach research methods. Because science is hard, and the truth is sometimes cunningly hidden in the nooks and crannies of complicated data. Figure 1.1: The Berkeley 1973 college admissions data. This figure plots the admission rate for the 85 departments that had at least one female applicant, as a function of the percentage of applicants that were female. The plot is a redrawing of Figure 1 from Bickel et al. (1975). Circles plot departments with more than 40 applicants; the area of the circle is proportional to the total number of applicants. The crosses plot department with fewer than 40 applicants. Before leaving this topic entirely, I want to point out something else really critical that is often overlooked in a research methods class. Statistics only solves part of the problem. Remember that we started all this with the concern that Berkeley’s admissions processes might be unfairly biased against female applicants. When we looked at the “aggregated” data, it did seem like the university was discriminating against women, but when we “disaggregate” and looked at the individual behaviour of all the departments, it turned out that the actual departments were, if anything, slightly biased in favour of women. The gender bias in total admissions was caused by the fact that women tended to self-select for harder departments. From a legal perspective, that would probably put the university in the clear. Postgraduate admissions are determined at the level of the individual department (and there are good reasons to do that), and at the level of individual departments, the decisions are more or less unbiased (the weak bias in favour of females at that level is small, and not consistent across departments). Since the university can’t dictate which departments people choose to apply to, and the decision making takes place at the level of the department it can hardly be held accountable for any biases that those choices produce. But that’s not exactly the whole story, is it? After all, if we’re interested in this from a more sociological and psychological perspective, we might want to ask why there are such strong gender differences in applications. Why do males tend to apply to engineering more often than females, and why is this reversed for the English department? And why is it it the case that the departments that tend to have a female-application bias tend to have lower overall admission rates than those departments that have a male-application bias? Might this not still reflect a gender bias, even though every single department is itself unbiased? It might. Suppose, hypothetically, that males preferred to apply to “hard sciences” and females prefer “humanities.” And suppose further that the reason for why the humanities departments have low admission rates is because the government doesn’t want to fund the humanities (spots in Ph.D. programs, for instance, are often tied to government funded research projects). Does that constitute a gender bias? Or just an unenlightened view of the value of the humanities? What if someone at a high level in the government cut the humanities funds because they felt that the humanities are “useless chick stuff.” That seems pretty blatantly gender biased. None of this falls within the purview of statistics, but it matters to the research project. If you’re interested in the overall structural effects of subtle gender biases, then you probably want to look at both the aggregated and disaggregated data. If you’re interested in the decision making process at Berkeley itself then you’re probably only interested in the disaggregated data. In short there are a lot of critical questions that you can’t answer with statistics, but the answers to those questions will have a huge impact on how you analyse and interpret data. And this is the reason why you should always think of statistics as a tool to help you learn about your data, no more and no less. It’s a powerful tool to that end, but there’s no substitute for careful thought. 1.3 Statistics in psychology3 I hope that the discussion above helped explain why science in general is so focused on statistics. But I’m guessing that you have a lot more questions about what role statistics plays in psychology, and specifically why psychology classes always devote so many lectures to stats. So here’s my attempt to answer a few of them… Why does psychology have so much statistics? To be perfectly honest, there’s a few different reasons, some of which are better than others. The most important reason is that psychology is a statistical science. What I mean by that is that the “things” that we study are people. Real, complicated, gloriously messy, infuriatingly perverse people. The “things” of physics include objects like electrons, and while there are all sorts of complexities that arise in physics, electrons don’t have minds of their own. They don’t have opinions, they don’t differ from each other in weird and arbitrary ways, they don’t get bored in the middle of an experiment, and they don’t get angry at the experimenter and then deliberately try to sabotage the data set. At a fundamental level psychology is harder than physics. Basically, we teach statistics to you as psychologists because you need to be better at stats than physicists. There’s actually a saying used sometimes in physics, to the effect that “if your experiment needs statistics, you should have done a better experiment.” They have the luxury of being able to say that because their objects of study are pathetically simple in comparison to the vast mess that confronts social scientists. It’s not just psychology, really: most social sciences are desperately reliant on statistics. Not because we’re bad experimenters, but because we’ve picked a harder problem to solve. We teach you stats because you really, really need it. Can’t someone else do the statistics? To some extent, but not completely. It’s true that you don’t need to become a fully trained statistician just to do psychology, but you do need to reach a certain level of statistical competence. In my view, there’s three reasons that every psychological researcher ought to be able to do basic statistics: There’s the fundamental reason: statistics is deeply intertwined with research design. If you want to be good at designing psychological studies, you need to at least understand the basics of stats. If you want to be good at the psychological side of the research, then you need to be able to understand the psychological literature, right? But almost every paper in the psychological literature reports the results of statistical analyses. So if you really want to understand the psychology, you need to be able to understand what other people did with their data. And that means understanding a certain amount of statistics. There’s a big practical problem with being dependent on other people to do all your statistics: statistical analysis is expensive. In almost any real life situation where you want to do psychological research, the cruel facts will be that you don’t have enough money to afford a statistician. So the economics of the situation mean that you have to be pretty self-sufficient. Note that a lot of these reasons generalize beyond researchers. If you want to be a practicing psychologist and stay on top of the field, it helps to be able to read the scientific literature, which relies pretty heavily on statistics. I don’t care about jobs, research, or clinical work. Do I need statistics? Okay, now you’re just messing with me. Still, I think it should matter to you too. Statistics should matter to you in the same way that statistics should matter to everyone: we live in the 21st century, and data are everywhere. Frankly, given the world in which we live these days, a basic knowledge of statistics is pretty damn close to a survival tool! 1.4 Statistics in everyday life “We are drowning in information, but we are starved for knowledge” – Various authors, original probably John Naisbitt When I started writing up my lecture notes I took the 20 most recent news articles posted to the ABC news website. Of those 20 articles, it turned out that 8 of them involved a discussion of something that I would call a statistical topic; 6 of those made a mistake. The most common error, if you’re curious, was failing to report baseline data (e.g., the article mentions that 5% of people in situation X have some characteristic Y, but doesn’t say how common the characteristic is for everyone else!) The point I’m trying to make here isn’t that journalists are bad at statistics (though they almost always are), it’s that a basic knowledge of statistics is very helpful for trying to figure out when someone else is either making a mistake or even lying to you. Perhaps, one of the biggest things that a knowledge of statistics does to you is cause you to get angry at the newspaper or the internet on a far more frequent basis :). 1.5 There’s more to research methods than statistics So far, most of what I’ve talked about is statistics, and so you’d be forgiven for thinking that statistics is all I care about in life. To be fair, you wouldn’t be far wrong, but research methodology is a broader concept than statistics. So most research methods courses will cover a lot of topics that relate much more to the pragmatics of research design, and in particular the issues that you encounter when trying to do research with humans. However, about 99% of student fears relate to the statistics part of the course, so I’ve focused on the stats in this discussion, and hopefully I’ve convinced you that statistics matters, and more importantly, that it’s not to be feared. That being said, it’s pretty typical for introductory research methods classes to be very stats-heavy. This is not (usually) because the lecturers are evil people. Quite the contrary, in fact. Introductory classes focus a lot on the statistics because you almost always find yourself needing statistics before you need the other research methods training. Why? Because almost all of your assignments in other classes will rely on statistical training, to a much greater extent than they rely on other methodological tools. It’s not common for undergraduate assignments to require you to design your own study from the ground up (in which case you would need to know a lot about research design), but it is common for assignments to ask you to analyse and interpret data that were collected in a study that someone else designed (in which case you need statistics). In that sense, from the perspective of allowing you to do well in all your other classes, the statistics is more urgent. But note that “urgent” is different from “important” – they both matter. I really do want to stress that research design is just as important as data analysis, and this book does spend a fair amount of time on it. However, while statistics has a kind of universality, and provides a set of core tools that are useful for most types of research, the research methods side isn’t quite so universal. There are some general principles that everyone should think about, but a lot of research design is very idiosyncratic and specific to the area of research that you want to engage in. Throughout the course you will be introduced to some core principles of research methods, but research methodology is an incredibly extensive and diverse field. To the extent that it’s the details of research methods that matter, those details don’t usually show up in an introductory class, as is the case for this course. 1.6 A brief introduction to research methods In this section, we’re going to start thinking about the basic ideas that go into designing a study, collecting data, checking whether your data collection works, and so on. It won’t give you enough information to allow you to design studies of your own, but it will give you a lot of the basic tools that you need to assess the studies done by other people. However, since the focus of this book is much more on data analysis than on data collection, I’m only giving a very brief overview. Note that this section is “special” in two ways. Firstly, it’s much more psychology-specific than the later parts of this book. Secondly, it focuses much more heavily on the scientific problem of research methodology, and much less on the statistical problem of data analysis. Nevertheless, the two problems are related to one another, so it’s traditional for stats textbooks to discuss the problem in at least some detail. This section relies heavily on Campbell and Stanley (1963) for the discussion of study design. 1.7 Some thoughts about measurement The first thing to understand is data collection can be thought of as a kind of measurement. That is, in psychological research, what we’re trying to do is measure something about human behaviour. What do I mean by “measurement?” Measurement itself is a subtle concept, but basically it comes down to finding some way of assigning numbers, or labels, or some other kind of well-defined descriptions to “stuff.” So, any of the following would count as a psychological measurement: My age is 32 years. I do like anchovies. My chromosomal gender is male. My self-identified gender is male. In the short list above, the bolded part is “the thing to be measured,” and the italicized part is “the measurement itself.” In fact, we can expand on this a little bit, by thinking about the set of possible measurements that could have arisen in each case: My age (in years) could have been 0, 1, 2, 3 …, etc. The upper bound on what my age could possibly be is a bit fuzzy, but in practice you’d be safe in saying that the largest possible age is 150, since no human has ever lived that long. When asked if I like anchovies, I might have said that I do, or I do not, or I have no opinion, or I sometimes do. My chromosomal gender is almost certainly going to be male (XY) or female (XX), but there are a few other possibilities. I could also have Klinfelter’s syndrome (XXY), which is more similar to male than to female. And I imagine there are other possibilities too. My self-identified gender is also very likely to be male or female, but it doesn’t have to agree with my chromosomal gender. I may also choose to identify with neither, or to explicitly call myself transgender. As you can see, for some things (like age) it seems fairly obvious what the set of possible measurements should be, whereas for other things it gets a bit tricky. But I want to point out that even in the case of someone’s age, it’s much more subtle than this. For instance, in the example above, I assumed that it was okay to measure age in years. But if you’re a developmental psychologist, that’s way too crude, and so you often measure age in years and months (if a child is 2 years and 11 months, this is usually written as “2;11”). If you’re interested in newborns, you might want to measure age in days since birth, maybe even hours since birth. In other words, the way in which you specify the allowable measurement values is important. Looking at this a bit more closely, you might also realise that the concept of “age” isn’t actually all that precise. In general, when we say “age” we implicitly mean “the length of time since birth.” But that’s not always the right way to do it. Suppose you’re interested in how newborn babies control their eye movements. If you’re interested in kids that young, you might also start to worry that “birth” is not the only meaningful point in time to care about. If Baby Alice is born 3 weeks premature and Baby Bianca is born 1 week late, would it really make sense to say that they are the “same age” if we encountered them “2 hours after birth?” In one sense, yes: by social convention, we use birth as our reference point for talking about age in everyday life, since it defines the amount of time the person has been operating as an independent entity in the world, but from a scientific perspective that’s not the only thing we care about. When we think about the biology of human beings, it’s often useful to think of ourselves as organisms that have been growing and maturing since conception, and from that perspective Alice and Bianca aren’t the same age at all. So you might want to define the concept of “age” in two different ways: the length of time since conception, and the length of time since birth. When dealing with adults, it won’t make much difference, but when dealing with newborns it might. Moving beyond these issues, there’s the question of methodology. What specific “measurement method” are you going to use to find out someone’s age? As before, there are lots of different possibilities: You could just ask people “how old are you?” The method of self-report is fast, cheap and easy, but it only works with people old enough to understand the question, and some people lie about their age. You could ask an authority (e.g., a parent) “how old is your child?” This method is fast, and when dealing with kids it’s not all that hard since the parent is almost always around. It doesn’t work as well if you want to know “age since conception,” since a lot of parents can’t say for sure when conception took place. For that, you might need a different authority (e.g., an obstetrician). You could look up official records, like birth certificates. This is time consuming and annoying, but it has its uses (e.g., if the person is now dead). 1.8 Operationalization: defining your measurement All of the ideas discussed in the previous section all relate to the concept of operationalization. To be a bit more precise about the idea, operationalization is the process by which we take a meaningful but somewhat vague concept, and turn it into a precise measurement. The process of operationalization can involve several different things: Being precise about what you are trying to measure: For instance, does “age” mean “time since birth” or “time since conception” in the context of your research? Determining what method you will use to measure it: Will you use self-report to measure age, ask a parent, or look up an official record? If you’re using self-report, how will you phrase the question? Defining the set of the allowable values that the measurement can take: Note that these values don’t always have to be numerical, though they often are. When measuring age, the values are numerical, but we still need to think carefully about what numbers are allowed. Do we want age in years, years and months, days, hours? Etc. For other types of measurements (e.g., gender), the values aren’t numerical. But, just as before, we need to think about what values are allowed. If we’re asking people to self-report their gender, what options to we allow them to choose between? Is it enough to allow only “male” or “female?” Do you need an “other” option? Or should we not give people any specific options, and let them answer in their own words? And if you open up the set of possible values to include all verbal response, how will you interpret their answers? Operationalization is a tricky business, and there’s no “one, true way” to do it. The way in which you choose to operationalize the informal concept of “age” or “gender” into a formal measurement depends on what you need to use the measurement for. Often you’ll find that the community of scientists who work in your area have some fairly well-established ideas for how to go about it. In other words, operationalization needs to be thought through on a case by case basis. Nevertheless, while there a lot of issues that are specific to each individual research project, there are some aspects to it that are pretty general. Before moving on, I want to take a moment to clear up our terminology, and in the process introduce more terms. Here are four different things that are closely related to each other: A theoretical construct or concept. This is the thing that you’re trying to take a measurement of, like “age,” “gender” or an “opinion.” A theoretical construct can’t be directly observed, and often they’re actually a bit vague. A measure. The measure refers to the method or the tool that you use to make your observations. A question in a survey, a behavioural observation or a brain scan could all count as a measure. A variable. A variable is what we end up with when we apply our measure to something in the world. That is, variables are the actual “data” that we end up with in our data sets. An operationalization. The term operationalization refers to the logical connection between the measure and the theoretical construct, or to the process by which we try to derive a measure from a theoretical construct. The process of operationalization consists of two steps, each of which entails some kind of definition of the theoretical construct we are interested in measuring. The first step of operationalization is specifying the nominal definition of a theoretical construct. This is when you specify the meaning of a theoretical construct but remain quite abstract. For instance, when defining “children,” we could be asking the following questions: is a child defined by a blood relationship, a legal relationship, a social relationship, chronological age, level of dependency or some other criterion? Different nominal definitions will produce different results; hence it is important that nominal definitions are derived carefully and transparently. Usually, it is good practice to develop and narrow down a nominal definition as follows: Obtain a range of different definitions: search the (academic) literature for explicit and implicit definitions. Decide on a definition: from your list, either pick one definition, or create a new one that serves the purposes of your study best. Explain and justify your approach. Delineate the dimensions of the theoretical construct. Almost any theoretical construct has a number of dimensions associated with it and it is helpful to spell these out as they can help you get closer to the measure that best serves the purposes of your study. For example, the theoretical construct “child’s well-being” has a number of dimensions: emotional, psychological, physical, educational, financial, social, environmental, legal, etc. If you are interested in the effect of marriage breakdown on children’s well-being, which dimensions are relevant to you? You may examine all of the possible dimensions or limit yourself to one or two. To answer this question you can borrow from literature and theoretical frameworks used by other researchers to motivate and explain the context of research. What is most important is that you explain and justify your approach. In addition to the aforementioned dimensions, theoretical constructs can also have subdimensions. Suppose we decide to focus on social well-being. In this case, the following subdimensions could be of some relevance: the level of safety in the neighborhood or the nature of a child’s relationships and experiences with discrimination. Given that we are interested in the effect of marriage breakdown on children’s well-being, we might want to focus on the child’s relationships with others, especially people like their mother, father, siblings, etc. Again, what is important here is to explain and justify your approach. Figure 1.2: Operationalization of a child’s well-being. Adapted from Vaus (2001) The next step of operationalization is specifying the operational definition of a theoretical construct. This specifies the indicators that reflect the nominal definition. Working with our example of marriage breakdown on children’s well-being and our decision to focus on social well-being and a child’s relationship with his or her father, we can use the following indicators: amount of contact, level of conflict, feelings of closeness, amount of helping, type of activities engaged in. How well the indicators match the theoretical construct has a big impact on the value of the conclusions that can be drawn from the study. Once the indicators have been chosen, the researcher can move to the next stage which is to measure the chosen indicators. In practice, even scientists tend to blur the distinction between these things, but it’s very helpful to try to understand the differences. 1.9 Assessing the reliability and validity of a measurement At this point we’ve thought a little bit about how to operationalize a theoretical construct and thereby create a psychological measure. Now, we should start discussing the obvious question: is the measurement any good? We’ll do this in terms of two related ideas: reliability and validity. Put simply, the reliability of a measure tells you how precisely you are measuring something, whereas the validity of a measure tells you how accurate the measure is. Reliability is actually a very simple concept: it refers to the repeatability or consistency of your measurement. The measurement of my weight by means of a “bathroom scale” is very reliable: if I step on and off the scales over and over again, it’ll keep giving me the same answer. Measuring my intelligence by means of “asking my mom” is very unreliable: some days she tells me I’m a bit thick, and other days she tells me I’m a complete moron. Notice that this concept of reliability is different to the question of whether the measurements are correct (the correctness of a measurement relates to it’s validity). If I’m holding a sack of potatos when I step on and off of the bathroom scales, the measurement will still be reliable: it will always give me the same answer. However, this highly reliable answer doesn’t match up to my true weight at all, therefore it’s wrong. In technical terms, this is a reliable but invalid measurement. Similarly, while my mom’s estimate of my intelligence is a bit unreliable, she might be right. Maybe I’m just not too bright, and so while her estimate of my intelligence fluctuates pretty wildly from day to day, it’s basically right. So that would be an unreliable but valid measure. Of course, to some extent, notice that if my mum’s estimates are too unreliable, it’s going to be very hard to figure out which one of her many claims about my intelligence is actually the right one. To some extent, then, a very unreliable measure tends to end up being invalid for practical purposes; so much so that many people would say that reliability is necessary (but not sufficient) to ensure validity. Okay, now that we’re clear on the distinction between reliability and validity, let’s have a think about the different ways in which we might measure reliability: Test-retest reliability. This relates to consistency over time: if we repeat the measurement at a later date, do we get a the same answer? Inter-rater reliability. This relates to consistency across people: if someone else repeats the measurement (e.g., someone else rates my intelligence) will they produce the same answer? Parallel forms reliability. This relates to consistency across theoretically-equivalent measurements: if I use a different set of bathroom scales to measure my weight, does it give the same answer? Internal consistency reliability. If a measurement is constructed from lots of different parts that perform similar functions (e.g., a personality questionnaire result is added up across several questions) do the individual parts tend to give similar answers? Not all measurements need to possess all forms of reliability. For instance, educational assessment can be thought of as a form of measurement. Many courses at EUC have an assessment structure that has a research component and an exam component (plus other things). The exam component is intended to measure something different from the research component, so the assessment as a whole has low internal consistency. However, within the exam there are several questions that are intended to (approximately) measure the same things, and those tend to produce similar outcomes; so the exam on its own has a fairly high internal consistency. Which is as it should be. You should only demand reliability in those situations where you want to be measure the same thing! 1.10 Forms of measurement error The aim of the process of operationalization is to identify measures with the highest possible validity and reliability. However, such endeavors turn out to be trickier in practice than they sound in theory and several errors might occur along the way. As we will see here, different forms of measurement error have different implications and consequences in the conclusions of the study. The first and least harmful form of error is random error. As the name suggests, it occurs randomly which means there is no systematic pattern underlying its occurrence. For instance, if we employ a self-reported measure of conflict with one’s own father, participants in our study might overestimate or underestimate the actual level of conflict with their father. If we believe that people are equally likely to under- or overestimate, there will be no systematic pattern of under- or overestimation in our data as the former will cancel out the latter. Constant error occurs where there is some amount of error for every case. When this is the case, values of any measure are systemetically overestimated or underestimated. For instance, people tend to overestimate their driving skills: significantly more than 50% of drivers believe their driving skills are better than average, which of course cannot be true! When such patterns of bias occur in the data, our measures are affected because errors do not cancel each other out. Correlated error occurs when the measurement error correlates with a characteristic that varies across the observations of our data. For instance, overweight people tend to underestimate their weight, whereas underweight people tend to overestimate it (Rowland 1990). This is subtly distinct from random error: even if at the aggregate the amount of overestimated weights is the same as the amount of underestimated weights, the underlying pattern of weight biased measurements can affect the conclusions of a study as it might generate alternative explanations related to weight differences. It is one of the main goals of any measure to minimize such errors. To achieve this, the researcher should pay careful attention to indicator quality, socially desirable responses and other forms of deliberate (mis)representation by respondents. Despite the fact it is often difficult to identify when such errors actually occur, researchers should pay a fair amount of attention trying to minimize them. 1.11 The role of variables: predictors and outcomes I’ve got one last piece of terminology that I need to explain to you. Remember, the outcome of a psychological measurement is called a variable. Normally, when we do some research we end up with lots of different variables. Then, when we analyse our data we usually try to explain some of the variables in terms of some of the other variables. It’s important to keep the two roles “thing doing the explaining” and “thing being explained” distinct. So let’s be clear about this now. Firstly, we might as well get used to the idea of using mathematical symbols to describe variables, since it’s going to happen over and over again. Let’s denote the “to be explained” variable \\(Y\\), and denote the variables “doing the explaining” as \\(X_1\\), \\(X_2\\), etc. Now, when we doing an analysis, we have different names for \\(X\\) and \\(Y\\), since they play different roles in the analysis. The classical names for these roles are independent variable (IV) and dependent variable (DV). The IV is the variable that you use to do the explaining (i.e., \\(X\\)) and the DV is the variable being explained (i.e., \\(Y\\)). The logic behind these names goes like this: if there really is a relationship between \\(X\\) and \\(Y\\) then we can say that \\(Y\\) depends on \\(X\\), and if we have designed our study “properly” then \\(X\\) isn’t dependent on anything else. However, some people have suggested these names are horrible: they’re hard to remember and they can be misleading, because (a) the IV is never actually “independent of everything else” and (b) if there’s no relationship, then the DV doesn’t actually depend on the IV. There are a number of alternatives that some people find more appealing. For example, in an experiment the IV refers to the manipulation, and the DV refers to the measurement. So, we could use manipulated variable (independent variable) and measured variable (dependent variable). Table 1.2: The terminology used to distinguish between different roles that a variable can play when analysing a data set. role of the variable classical name modern name to be explained dependent variable (DV) measurement to do the explaining independent variable (IV) manipulation We could also use predictors and outcomes. The idea here is that what you’re trying to do is use \\(X\\) (the predictors) to make guesses about \\(Y\\) (the outcomes). This is summarized in the table: Table 1.3: The terminology used to distinguish between different roles that a variable can play when analysing a data set. role of the variable classical name modern name to be explained dependent variable (DV) outcome to do the explaining independent variable (IV) predictor 1.12 That’s it for this week That’s it for the readings of the first week. Next, make sure to complete the “Getting started” section of the lab manual before your first tutorial. The “Getting started” section will ask you to install and learn about the very basics of the statistical software we will be using during this course: R and RStudio. Adapted nearly verbatim from Chapter 1 and 2 in Navarro, D. “Learning Statistics with R.”. Extended the materials about research methods with our own.↩︎ Earlier versions of these notes incorrectly suggested that they actually were sued – apparently that’s not true. There’s a nice commentary on this here: https://www.refsmmat.com/posts/2016-05-08-simpsons-paradox-berkeley.html. A big thank you to Wilfried Van Hirtum for pointing this out to me!↩︎ As stated in the preface, this text was originally written for psychology students. Regardless of your interest in psychology, the reasons stated here are also relevant many other research fields (e.g. medicine, economics, sociology, sustainability etc.)↩︎ "],["week-2-describing-data-adapted2.html", " 2 Week 2: Describing Data4 2.1 Scales of measurement 2.2 This is what too many numbers looks like 2.3 Describing data using graphs 2.4 Describing data using numbers 2.5 Measures of central tendency (sameness) 2.6 Measures of variation (differentness) 2.7 Remember to look at your data 2.8 That’s it for this week", " 2 Week 2: Describing Data4 Far better an approximate answer to the right question, which is often vague, than an exact answer to the wrong question, which can always be made precise. —John W. Tukey This chapter is about descriptive statistics. These are tools for describing data. Some things to keep in mind as we go along are: There are lots of different ways to describe data There is more than one “correct” way, and you get to choose the most “useful” way for the data that you are describing It is possible to invent new ways of describing data Describing data is necessary because there is usually too much of it, so it doesn’t make any sense by itself. Before we start with describing data, we need to introduce you to the concept of measurement scales. 2.1 Scales of measurement Remember last week when we talked about measurement? To reiterate: the outcome of a measurement is called a variable. But not all variables are of the same qualitative type, and it’s very useful to understand what types there are. A very useful concept for distinguishing between different types of variables is what’s known as scales of measurement. 2.1.1 Nominal scale A nominal scale variable (also referred to as a categorical variable) is one in which there is no particular relationship between the different possibilities: for these kinds of variables it doesn’t make any sense to say that one of them is ``bigger’ or “better” than any other one, and it absolutely doesn’t make any sense to average them. The classic example for this is “eye colour.” Eyes can be blue, green and brown, among other possibilities, but none of them is any “better” than any other one. As a result, it would feel really weird to talk about an “average eye colour.” Similarly, gender is nominal too: male isn’t better or worse than female, neither does it make sense to try to talk about an “average gender.” In short, nominal scale variables are those for which the only thing you can say about the different possibilities is that they are different. That’s it. Let’s take a slightly closer look at this. Suppose I was doing research on how people commute to and from work. One variable I would have to measure would be what kind of transportation people use to get to work. This “transport type” variable could have quite a few possible values, including: “train,” “bus,” “car,” “bicycle,” etc. For now, let’s suppose that these four are the only possibilities, and suppose that when I ask 100 people how they got to work today, and I get this: Transportation Number of people (1) Train 12 (2) Bus 30 (3) Car 48 (4) Bicycle 10 So, what’s the average transportation type? Obviously, the answer here is that there isn’t one. It’s a silly question to ask. You can say that travel by car is the most popular method, and travel by train is the least popular method, but that’s about all. Similarly, notice that the order in which I list the options isn’t very interesting. I could have chosen to display the data like this and nothing really changes. Transportation Number of people (3) Car 48 (1) Train 12 (4) Bicycle 10 (2) Bus 30 2.1.2 Ordinal scale Ordinal scale variables have a bit more structure than nominal scale variables, but not by a lot. An ordinal scale variable is one in which there is a natural, meaningful way to order the different possibilities, but you can’t do anything else. The usual example given of an ordinal variable is “finishing position in a race.” You can say that the person who finished first was faster than the person who finished second, but you don’t know how much faster. As a consequence we know that 1st \\(&gt;\\) 2nd, and we know that 2nd \\(&gt;\\) 3rd, but the difference between 1st and 2nd might be much larger than the difference between 2nd and 3rd. A more interesting example could be as follows. Suppose I’m interested in people’s attitudes to climate change, and I ask them to pick one of these four statements that most closely matches their beliefs: Temperatures are rising, because of human activity Temperatures are rising, but we don’t know why Temperatures are rising, but not because of humans Temperatures are not rising Notice that these four statements actually do have a natural ordering, in terms of “the extent to which they agree with the current science.” Statement 1 is a close match, statement 2 is a reasonable match, statement 3 isn’t a very good match, and statement 4 is in strong opposition to the science. So, in terms of the thing I’m interested in (the extent to which people endorse the science), I can order the items as \\(1 &gt; 2 &gt; 3 &gt; 4\\). Since this ordering exists, it would be very weird to list the options like this… Temperatures are rising, but not because of humans Temperatures are rising, because of human activity Temperatures are not rising Temperatures are rising, but we don’t know why …because it seems to violate the natural “structure” to the question. So, let’s suppose I asked 100 people these questions, and got the following answers: Response Number (1) Temperatures are rising, because of human activity 51 (2) Temperatures are rising, but we don’t know why 20 (3) Temperatures are rising, but not because of humans 10 (4) Temperatures are not rising 19 When analysing these data, it seems quite reasonable to try to group (1), (2) and (3) together, and say that 81 of 100 people were willing to at least partially endorse the science. And it’s also quite reasonable to group (2), (3) and (4) together and say that 49 of 100 people registered at least some disagreement with the dominant scientific view. However, it would be entirely bizarre to try to group (1), (2) and (4) together and say that 90 of 100 people said…what? There’s nothing sensible that allows you to group those responses together at all. That said, notice that while we can use the natural ordering of these items to construct sensible groupings, what we can’t do is average them. For instance, in my simple example here, the “average” response to the question is 1.97. If you can tell me what that means, I’d love to know. Because that sounds like gibberish to me! 2.1.3 Interval scale In contrast to nominal and ordinal scale variables, interval scale and ratio scale variables are variables for which the numerical value is genuinely meaningful. In the case of interval scale variables, the differences between the numbers are interpretable, but the variable doesn’t have a “natural” zero value. A good example of an interval scale variable is measuring temperature in degrees celsius. For instance, if it was 15\\(^\\circ\\) yesterday and 18\\(^\\circ\\) today, then the 3\\(^\\circ\\) difference between the two is genuinely meaningful. Moreover, that 3\\(^\\circ\\) difference is exactly the same as the 3\\(^\\circ\\) difference between \\(7^\\circ\\) and \\(10^\\circ\\). In short, addition and subtraction are meaningful for interval scale variables. However, notice that the \\(0^\\circ\\) does not mean “no temperature at all”: it actually means “the temperature at which water freezes,” which is pretty arbitrary. As a consequence, it becomes pointless to try to multiply and divide temperatures. It is wrong to say that \\(20^\\circ\\) is twice as hot as \\(10^\\circ\\), just as it is weird and meaningless to try to claim that \\(20^\\circ\\) is negative two times as hot as \\(-10^\\circ\\). Let’s look at a different example. Suppose I’m interested in looking at how the attitudes of first-year university students have changed over time. Obviously, I’m going to want to record the year in which each student started. This is an interval scale variable. A student who started in 2003 did arrive 5 years before a student who started in 2008. However, it would be completely insane for me to divide 2008 by 2003 and say that the second student started “1.0024 times later” than the first one. That doesn’t make any sense at all. 2.1.4 Ratio scale The fourth and final type of variable to consider is a ratio scale variable, in which zero really means zero, and it’s okay to multiply and divide. A good example of a ratio scale variable is response time (RT). In a lot of tasks it’s very common to record the amount of time somebody takes to solve a problem or answer a question, because it’s an indicator of how difficult the task is. Suppose that Alan takes 2.3 seconds to respond to a question, whereas Ben takes 3.1 seconds. As with an interval scale variable, addition and subtraction are both meaningful here. Ben really did take \\(3.1 - 2.3 = 0.8\\) seconds longer than Alan did. However, notice that multiplication and division also make sense here too: Ben took \\(3.1 / 2.3 = 1.35\\) times as long as Alan did to answer the question. And the reason why you can do this is that, for a ratio scale variable such as RT, “zero seconds” really does mean “no time at all.” 2.1.5 Continuous versus discrete variables There’s a second kind of distinction that you need to be aware of, regarding what types of variables you can run into. This is the distinction between continuous variables and discrete variables. The difference between these is as follows: A continuous variable is one in which, for any two values that you can think of, it’s always logically possible to have another value in between. A discrete variable is, in effect, a variable that isn’t continuous. For a discrete variable, it’s sometimes the case that there’s nothing in the middle. These definitions probably seem a bit abstract, but they’re pretty simple once you see some examples. For instance, response time is continuous. If Alan takes 3.1 seconds and Ben takes 2.3 seconds to respond to a question, then it’s possible for Cameron’s response time to lie in between, by taking 3.0 seconds. And of course it would also be possible for David to take 3.031 seconds to respond, meaning that his RT would lie in between Cameron’s and Alan’s. And while in practice it might be impossible to measure RT that precisely, it’s certainly possible in principle. Because we can always find a new value for RT in between any two other ones, we say that RT is continuous. Discrete variables occur when this rule is violated. For example, nominal scale variables are always discrete: there isn’t a type of transportation that falls “in between” trains and bicycles, not in the strict mathematical way that 2.3 falls in between 2 and 3. So transportation type is discrete. Similarly, ordinal scale variables are always discrete: although “2nd place” does fall between “1st place” and “3rd place,” there’s nothing that can logically fall in between “1st place” and “2nd place.” Interval scale and ratio scale variables can go either way. As we saw above, response time (a ratio scale variable) is continuous. Temperature in degrees celsius (an interval scale variable) is also continuous. However, the year you went to school (an interval scale variable) is discrete. There’s no year in between 2002 and 2003. The number of questions you get right on a true-or-false test (a ratio scale variable) is also discrete: since a true-or-false question doesn’t allow you to be “partially correct,” there’s nothing in between 5/10 and 6/10. The following table summarizes the relationship between the scales of measurement and the discrete/continuity distinction. Cells with a tick mark correspond to things that are possible. I’m trying to hammer this point home, because (a) some textbooks get this wrong, and (b) people very often say things like “discrete variable” when they mean “nominal scale variable.” It’s very unfortunate. Table 2.1: The relationship between the scales of measurement and the discrete/continuity distinction. Cells with a tick mark correspond to things that are possible. continuous discrete nominal \\(\\checkmark\\) ordinal \\(\\checkmark\\) interval \\(\\checkmark\\) \\(\\checkmark\\) ratio \\(\\checkmark\\) \\(\\checkmark\\) 2.1.6 Some complexities Okay, I know you’re going to be shocked to hear this, but …the real world is much messier than this little classification scheme suggests. Very few variables in real life actually fall into these nice neat categories, so you need to be kind of careful not to treat the scales of measurement as if they were hard and fast rules. It doesn’t work like that: they’re guidelines, intended to help you think about the situations in which you should treat different variables differently. Nothing more. So let’s take a classic example, maybe the classic example, of a psychological measurement tool: the Likert scale. The humble Likert scale is the bread and butter tool of all survey design. You yourself have filled out hundreds, maybe thousands of them, and odds are you’ve even used one yourself. Suppose we have a survey question that looks like this: Which of the following best describes your opinion of the statement that “all pirates are freaking awesome” … and then the options presented to the participant are these: (1) Strongly disagree (2) Disagree (3) Neither agree nor disagree (4) Agree (5) Strongly agree This set of items is an example of a 5-point Likert scale: people are asked to choose among one of several (in this case 5) clearly ordered possibilities, generally with a verbal descriptor given in each case. However, it’s not necessary that all items be explicitly described. This is a perfectly good example of a 5-point Likert scale too: (1) Strongly disagree (2) (3) (4) (5) Strongly agree Likert scales are very handy, if somewhat limited, tools. The question is, what kind of variable are they? They’re obviously discrete, since you can’t give a response of 2.5. They’re obviously not nominal scale, since the items are ordered; and they’re not ratio scale either, since there’s no natural zero. But are they ordinal scale or interval scale? One argument says that we can’t really prove that the difference between “strongly agree” and “agree” is of the same size as the difference between “agree” and “neither agree nor disagree.” In fact, in everyday life it’s pretty obvious that they’re not the same at all. So this suggests that we ought to treat Likert scales as ordinal variables. On the other hand, in practice most participants do seem to take the whole “on a scale from 1 to 5” part fairly seriously, and they tend to act as if the differences between the five response options were fairly similar to one another. As a consequence, a lot of researchers treat Likert scale data as if it were interval scale. It’s not interval scale, but in practice it’s close enough that we usually think of it as being quasi-interval scale. 2.2 This is what too many numbers looks like With that out of the way, we can start looking at some actual measurements. Let’s say you want to know how happy people are. So, you ask 500 people on the street how happy they are. You let them pick any number they want from negative infinity to positive infinity and record all the numbers in a continuous interval variable. We could look at the numbers and see if that helps determine anything about how happy people are. Perhaps it would look something like this: # From now on, whenever it makes sense, I will show the R code used to generate # the examples. That way you can follow along in your own R session and learn # from the examples given. # The following line of code generates a variable called &#39;happiness&#39; with 500 # pretend happiness ratings. This is of course not the same as actually # conducting a study, as we ask R to generate 500 random values, but is very # helpful for illustrative purposes. happiness &lt;- rnorm(500, 100, 500) 1243.62 -31.37 359.53 -77.85 1111.67 -638.80 362.63 345.69 -59.85 -552.91 -498.39 96.17 393.77 648.65 531.25 -1386.63 -37.86 65.49 682.53 1111.71 -247.15 283.58 60.33 -353.35 87.55 -569.88 127.35 -575.40 -210.86 -277.82 -106.15 953.58 -487.18 -3.73 400.32 -32.92 -94.12 499.68 724.11 -20.80 -385.34 461.87 254.36 439.43 708.24 -92.00 -108.51 -60.05 820.20 648.58 -373.64 340.52 -701.94 -298.89 -488.27 -201.47 -482.09 -78.48 481.00 -373.31 474.07 -683.93 595.64 -695.77 -204.67 -225.76 968.93 -155.36 379.69 -466.98 41.52 259.13 611.61 690.17 293.63 978.84 -27.04 -839.44 899.63 -341.69 176.33 183.00 520.07 711.28 -599.57 90.48 -386.86 -375.92 50.77 358.21 1194.99 -349.95 160.04 94.55 716.25 177.64 655.60 1236.58 -624.78 -68.98 278.49 138.19 -113.13 272.76 107.75 -280.42 586.75 201.34 -28.83 88.77 1458.38 179.58 329.46 147.09 -710.48 -674.86 728.56 -1054.28 -916.54 48.97 1240.73 371.84 422.52 103.40 -232.73 1475.08 988.14 71.68 393.48 250.20 262.01 452.40 405.77 471.31 -187.42 623.71 -1241.58 131.42 180.29 503.31 1048.03 259.48 -344.61 621.09 -350.95 559.00 429.93 455.11 156.58 81.40 333.84 654.62 871.95 -59.67 845.80 335.05 689.72 -196.15 385.85 -628.24 -346.90 484.58 -520.88 261.32 31.36 -208.69 296.76 249.26 -382.76 -211.95 -53.66 676.74 651.72 442.53 154.14 121.05 -494.93 421.27 259.00 15.20 97.59 730.34 591.39 260.12 -417.61 -350.95 -78.26 1156.40 13.25 738.06 594.08 450.31 252.16 -857.47 -122.37 769.79 -632.75 558.89 -356.31 -27.96 519.88 316.31 -677.36 -1069.98 1.98 501.93 -445.37 -686.43 -823.45 17.32 452.67 -361.30 884.95 341.43 -534.68 259.24 -228.63 596.32 434.76 -113.66 752.98 -207.79 444.22 689.27 576.76 4.77 1231.47 339.76 45.61 71.56 -594.00 -333.33 11.20 -546.39 336.27 -443.63 143.85 -48.29 883.29 -622.69 736.46 -719.76 464.60 407.89 -179.39 172.70 483.76 507.92 -322.42 1041.40 192.10 -562.92 866.63 228.02 721.03 1331.40 -206.58 -399.89 648.82 158.45 476.14 -344.52 353.29 463.92 92.37 561.81 176.25 374.61 250.44 310.57 395.87 -178.80 116.66 762.06 -295.89 470.94 -195.85 239.89 -288.48 888.70 -391.53 68.80 -633.78 173.58 -100.81 808.01 -380.35 558.32 80.78 -25.69 -38.03 1311.35 609.58 -199.27 -848.35 725.83 -192.48 -765.63 654.74 72.19 -335.43 271.29 -196.67 1196.26 585.99 1154.45 428.34 -639.79 368.16 88.73 459.36 102.12 506.20 1263.56 -156.98 455.16 -45.12 1214.91 -81.67 1265.48 155.33 114.61 533.08 667.43 107.28 -637.59 552.05 293.25 47.25 50.58 60.77 -96.71 284.15 4.56 -30.47 -194.86 199.51 430.13 266.94 183.22 -110.25 -296.35 667.41 337.42 861.18 169.85 74.21 -38.12 505.12 -34.82 -181.06 -55.85 -278.55 -172.74 -636.68 -155.86 -354.10 237.97 -741.85 522.24 598.76 -73.03 322.61 627.82 91.72 175.47 -471.24 -1037.12 432.86 804.38 -452.57 -52.30 557.97 314.51 112.27 321.02 595.16 554.04 -296.19 -683.12 28.86 -792.95 234.88 -809.98 99.37 18.80 156.14 -443.13 863.86 184.52 257.50 393.64 603.77 -245.99 -116.97 585.92 674.82 -7.76 -643.35 -652.84 709.28 917.90 -630.72 -865.91 -102.78 -235.63 -355.25 -266.71 -235.57 597.47 -249.66 -222.71 -337.39 704.84 177.62 919.20 -451.91 206.06 937.59 721.95 -42.72 409.50 182.61 -39.50 -386.19 -434.14 -717.43 -369.57 405.97 81.87 -555.78 218.20 203.60 -447.89 874.09 94.29 -708.19 -209.60 -16.10 -105.63 -95.51 523.25 341.18 48.91 -85.06 -832.64 -318.37 222.01 402.65 742.07 -100.76 -186.82 64.17 278.51 1080.76 109.13 646.50 285.87 -479.55 -458.90 775.26 659.00 -344.46 -341.15 -205.00 -23.51 717.55 413.60 -482.21 -317.53 395.60 -670.00 342.97 71.68 61.29 -359.71 186.03 -436.56 -334.96 850.41 150.26 -119.06 270.25 -190.51 -814.43 -986.58 160.25 -254.35 -30.55 549.58 565.54 24.66 -448.96 422.04 502.96 -224.69 378.77 553.57 -147.10 -128.21 When you deal with data, you will often encounter so many numbers to you that you will be overwhelmed by them. That is why we need ways to describe the data in a more manageable fashion. The complete description of the data is the data itself. Descriptive statistics and other tools for describing data go one step further to summarize aspects of the data. Summaries are a way to compress the important bits of a thing down to a useful and manageable tidbit. It’s like telling your friends why they should watch a movie: you don’t replay the entire movie for them, instead you tell them the general highlights. Summarizing the data is just like a movie preview, only for data. 2.3 Describing data using graphs So, we tried one way of looking at the numbers (just printing all of them in a large table) which wasn’t particularly useful. Let’s look at the numbers using graphs. 2.3.1 Scatterplot Let’s turn all of the numbers into dots, then show them in a graph. This type of graph is called a scatterplot. Note, when we do this, we have not yet summarized anything about the data. Instead, we just look at all of the data in a visual format, rather than looking at the numbers themselves. plot(happiness,ylim=c(-1500,1500),las=1) Figure 2.1: Pretend happiness ratings from 500 people Figure 2.1 shows 500 measurements of happiness. The graph has two axes. The horizontal x-axis, going from left to right is labeled “Index.” The vertical y-axis, going up and down, is labeled “happiness.” Each dot represents one measurement of every person’s happiness from our pretend study. Before we talk about what we can see about the data, it is worth mentioning that the way you plot the data will make some things easier to see and some things harder to see. So, what can we now see about the data? Firstly, there are lots of dots everywhere. It looks like there are 500 of them because the index on the x-axis goes to 500. It looks like some dots go as high as +1500 and as low as -1500. It looks like there are more dots in the middle-ish area of the plot, sort of spread around 0. The dots are kind of all over the place, so different people have different levels of happiness, which is not so surprising. But we could now also start to answer questions about the data. Are there any trends? Are more people happy than unhappy, or vice-versa? Take home message: we can visualize our variables by putting them in a plot, which is easier and more helpful than looking at the raw numbers. 2.3.2 Histogram Making a histogram will be our first act of officially summarizing the data. We will no longer look at the individual bits of data, instead we will see how the numbers group together. Let’s look at a histogram of the happiness data, and then explain it. hist(happiness,breaks=6,ylim=c(0,200), xlim=(c(-1500,1500))) Figure 2.2: A histogram of the happiness ratings The dots have disappeared and instead we have some bars. Each bar is a summary of the dots, representing the number of dots (frequency count) inside a particular range of happiness, also called bins. For example, how many people gave a happiness rating between 0 and 500? The fourth bar, the one between 0 and 500 on the x-axis, tells you how many. The height is shown on the y-axis, which provides a frequency count (the number of dots or data points). It looks like around 180 people said their happiness was between 0-500. More generally, we see there are 6 bins on the x-axis. We have divided the data into bins of 500. Bin #1 goes from -1500 to -1000, bin #2 goes from -1000 to -500, and so on until the last bin. To make the histogram, we just count up the number of data points falling inside each bin, then plot those frequency counts as a function of the bins. Voila, a histogram. What does the histogram help us see about the data? First, we can see the shape of data. The shape of the histogram refers to how it goes up and down. The shape tells us where the data is. For example, when the bars are low we know there isn’t much data there. When the bars are high, we know there is more data there. So, where is most of the data? It looks like it’s mostly in the middle two bins, between -500 and 500. We can also see the range of the data. This tells us the minimums and the maximums of the data. Most of the data is between -1500 and +1500, so no infinite sadness or infinite happiness in our data-set. When you make a histogram you get to choose how wide each bar will be. For example, below are four different histograms of the very same happiness data. What changes is the width of the bins. par(mfrow = c(2, 2), mar = c(2, 2, 2, 2)) g1 &lt;- hist(happiness, breaks = 6, ylim = c(0, 200), xlim = (c(-1500, 1500))) g2 &lt;- hist(happiness, breaks = 12, ylim = c(0, 100), xlim = (c(-1500, 1500))) g3 &lt;- hist(happiness, breaks = 24, ylim = c(0, 50), xlim = (c(-1500, 1500))) g4 &lt;- hist(happiness, breaks = 48, ylim = c(0, 25), xlim = (c(-1500, 1500))) Figure 2.3: Four histograms of the same data using different bin widths All of the histograms have roughly the same overall shape: From left to right, the bars start off small, then go up, then get small again. In other words, as the numbers get closer to zero, they start to occur more frequently. We see this general trend across all the histograms. But, some aspects of the trend fall apart when the bars get really narrow. For example, although the bars generally get taller when moving from -1000 to 0, there are some exceptions and the bars seem to fluctuate a little bit. When the bars are wider, there are less exceptions to the general trend. How wide or narrow should your histogram be? It’s a Goldilocks question. Make it just right for your data. 2.3.3 Other graphs There are many other graphs to describe your data in addition to scatterplots and histograms, but they will be introduced to you as we continue this course. For now it’s important to know that your data can be visualized using a graph and different types of graphs can show you different things about your data. 2.4 Describing data using numbers Let’s introduce three important terms that we will use a lot in descriptive statistics: distribution, central tendency, and variance. These terms are similar to their everyday meanings (although I suspect most people don’t say central tendency very often). Distribution. “To distribute” is to spread something. Notice, the data in the histogram is distributed, or spread across the bins. We can also talk about a distribution as a noun. The histogram is a distribution of the frequency counts across the bins. Distributions are very, very, very, very, very important. They can have many different shapes. They can describe data, like in the histogram above. And as we will learn in later chapters, distributions can also produce data. Many times we will be asking questions about where our data came from, and this usually means asking what kind of distribution could have created our data (more on that later). Central tendency is all about sameness: What is common about some numbers? For example, is there anything similar about all of the numbers in the histogram? Yes, we can say that most of them are near 0. There is a tendency for most of the numbers to be centered near 0. Notice we are being cautious about our generalization about the numbers. We are not saying they are all 0. We are saying there is a tendency for many of them to be near zero. There are lots of ways to talk about the central tendency of some numbers. There can even be more than one kind of tendency. For example, if lots of the numbers were around -1000, and a similar large amount of numbers were grouped around 1000, we could say there was two tendencies. Variance is all about “differentness.” The variance in the numbers refers to how the numbers are different. There are many ways to summarize the amount of variance in the numbers, and we will discuss these very soon. 2.5 Measures of central tendency (sameness) We’ve seen that we can get a sense of data by plotting dots in a graph and by making a histogram. These tools show us what the numbers look like, approximately how big and small they are, and how similar and different they are from another. It is good to get a feeling about the numbers in this way. But, these visual sensitudes are not very precise. In addition to summarizing numbers with graphs, we can summarize numbers using numbers. Measures of central tendency have one important summary goal: to reduce a pile of numbers to a single number that we can look at. We already know that looking at thousands of numbers is hopeless. Wouldn’t it be nice if we could just look at one number instead? It turns out there are lots of ways to do this. 2.5.1 Mode The mode is the most frequently occurring number in your measurement. That is it. How do you find it? You have to count the number of times each number appears in your measure, then whichever one occurs the most, is the mode. Example: 1 1 1 2 3 4 5 6 The mode of the above set is 1, which occurs three times. Every other number only occurs once. OK fine. What happens here: Example: 1 1 1 2 2 2 3 4 5 6 Hmm, now 1 and 2 both occur three times each. What do we do? We say there are two modes, 1 and 2, and call the distribution of numbers bimodal. Why is the mode a measure of central tendency? Well, when we ask, “what are my numbers like,” we can say, “most of the number are, like a 1 (or whatever the mode is).” Is the mode a good measure of central tendency? That depends on your numbers. For example, consider these numbers 1 1 2 3 4 5 6 7 8 9 Here, the mode is 1 again, because there are two 1s and all of the other numbers occur once. But, most numbers are not 1s, so you can argue whether the mode is a good summary of the set of numbers in this case. “Argh, so should I or should I not use the mode? I thought this class was supposed to tell me what to do?” There is no telling you what to do. Every time you use a tool in statistics you have to think about what you are doing and justify if and why what you are doing makes sense. Sorry. 2.5.2 Median The median is the exact middle of the data. After all, we are asking about central tendency, so why not go to the center of the data and see where it lies. Let’s have a look at the following numbers: 1 5 4 3 6 7 9 Umm, OK. So, three is in the middle and therefore the median? That seems kind of arbitrary and it is. Before we compute the median, we need to order the numbers from smallest to largest. 1 3 4 5 6 7 9 Now, 5 is in the middle. There are three numbers to the left of 5, and three numbers to the right. What happens when there aren’t an even number of numbers? Then the middle will be missing right? Let’s see: 1 2 3 4 5 6 There is no number between 3 and 4 in the data, the middle is empty. In this case, we compute the median by figuring out the number in between 3 and 4. So, the median would be 3.5. Is the median a good measure of central tendency? Sure, it is often very useful. One property of the median is that it stays in the middle even when some of the other numbers get really weird. For example, consider these numbers: 1 2 3 4 4 4 5 6 6 6 7 7 1000 Most of these numbers are smallish, but the 1000 is a big weird number, very different from the rest. The median is still 5, because it is in the middle of these ordered numbers. We can also see that five is pretty similar to most of the numbers (except for 1000). So, the median does a pretty good job of representing most of the numbers in the set, and it does so even if one or two of the numbers are very different from the others. Finally, outlier is a term will we use to describe numbers that appear in data that are very different from the rest. 1000 is an outlier, because it lies way out there on the number line compared to the other numbers. What to do with outliers is another topic we discuss sometimes throughout this course. 2.5.3 Mean Have you noticed this is a textbook about statistics that hasn’t used a formula yet? That is about to change, but for those of you with formula anxiety, don’t worry, we will do our best to explain them. The mean is also called the average. And, we’re guessing you might already now what the average of a bunch of numbers is. It’s the sum of the numbers, divided by the number of numbers right? We express that idea in a formula just like this: \\(\\text{Mean} = \\bar{X} = \\frac{\\sum_{i=1}^{N} X_{i}}{N}\\) The \\(\\sum\\) symbol is called sigma, and it stands for the operation of summing. The little “i” on the bottom, and the “N” on the top refers to all of the numbers in the set, from the first number “i” to the last number “N.” The \\(X_{i}\\) refers to individual numbers in the set. We sum up all of the numbers, then divide the sum by \\(N\\), which is the total number of numbers. Sometimes you will see \\(\\bar{X}\\) (say: ex-bar) to refer to the mean of a set of numbers. In plain English, the formula looks like: \\(\\text{Mean} = \\frac{\\text{Sum of my numbers}}{\\text{Count of my numbers}}\\) Let’s compute the mean for these five numbers: 3 7 9 2 6 Add em up: 3+7+9+2+6 = 27 Count em up: \\(i_{1}\\) = 3, \\(i_{2}\\) = 7, \\(i_{3}\\) = 9, \\(i_{4}\\) = 2, \\(i_{5}\\) = 6; N=5, because \\(i\\) went from 1 to 5 Divide em: mean = 27 / 5 = 5.4 Or, to put the numbers in the formula, it looks like this: \\(\\text{Mean} = \\bar{X} = \\frac{\\sum_{i=1}^{N} X_{i}}{N} = \\frac{3+7+9+2+6}{5} = \\frac{27}{5} = 5.4\\) Is the mean a good measure of central tendency? By now, you can guess: it depends. 2.5.4 What does the mean mean? It is not enough to know the formula for the mean, or to be able to use the formula to compute a mean for a set of numbers. We believe in your ability to add and divide numbers. What you really need to know is what the mean really “means.” This requires that you know what the mean does, and not just how to do it. Puzzled? Let’s explain. Let’s think about the following questions: What happens when you divide a sum of numbers by the number of numbers? What are the consequences of doing this? What is the formula doing? What kind of properties does the result give us? Of course, the key word here is divide. We literally carve the number up top in the numerator into pieces. How many times do we split the top number? That depends on the bottom number in the denominator. Watch: \\(\\frac{12}{3} = 4\\) So, we know the answer is 4. But, what is really going on here is that we are slicing and dicing up 12 into three parts. It turns out the size of those three parts is 4. So, now we are thinking of 12 as three different pieces \\(12 = 4 + 4 + 4\\). I know this will be obvious, but what kind of properties do our pieces have? Well, obviously they are all fours. The pieces are all the same size. They are all equal. So, division equalizes the numerator by the denominator… “Umm, I think I learned this in elementary school, what does this have to do with the mean?” The number on top of the formula for the mean is just another numerator being divided by a denominator. In this case, the numerator is a sum of all the values in your data. What if it was the sum of all of the 500 happiness ratings? The sum of all of them would just be a single number adding up all the different ratings. If we split the sum up into equal parts representing one part for each person’s happiness we would get 500 identical and equal numbers for each person. It would be like taking all of the happiness in the world, then dividing it up equally, then to be fair, giving back the same equal amount of happiness to everyone in the world. This would make some people more happy than they were before, and some people less happy right. Of course, that’s because it would be equalizing the distribution of happiness for everybody. This process of equalization by dividing something into equal parts is what the mean does. See, it’s more than just a formula. It’s an idea. This is just the beginning of thinking about these kinds of ideas. We will come back to this idea about the mean, and other ideas, in later chapters. Take home: the mean is the one and only number that can take the place of every number in the data, such that when you add up all the equal parts, you get back the original sum of the data. 2.5.5 All together now Just to remind ourselves of the mode, median, and mean, take a look at the next histogram of our happiness data set. We have overlaid the location of the mode (blue), median (green), and mean (red). The location of the mode, median and mean are pretty similar. Figure 2.4: A histogram of happiness with the mode (blue), median (green), and mean (red) But that’s not always the case. Suppose I collect data on the length of phone calls to an IT call center. Most phone calls are dealt with quickly and are relatively short, but there are some people with difficult questions that require much more assistance than other callers. For this data set, the three measures of central tendency all give different answers. The mean has the largest value, because it is influenced by large numbers (the few very long phone calls), even if they occur rarely. The median is less sensitive to large numbers that occur infrequently, so the value of the median is smaller. The mode is not affected by the infrequent large numbers at all. Figure 2.5: A histogram of phone call length with the mode (blue), median (green), and mean (red) 2.6 Measures of variation (differentness) Writing a book report in high school probably meant you were comparing and contrasting things. When you summarize data, you do the same thing. Measures of central tendency give us something like comparing does, they tell us about what is the same. Measures of variation give us something like contrasting does, they tell us about what is different. First, we note that whenever you see a bunch of numbers that aren’t the same, you already know there are some differences. This means the numbers vary, and there is variation in the size of the numbers. 2.6.1 The range Consider these 10 numbers, that I already ordered from smallest to largest for you: 1 3 4 5 5 6 7 8 9 24 The numbers have variation, because they are not all the same. We can use the range to describe the width of the variation. The range refers to the minimum (smallest value) and maximum (largest value) in the set. So, the range would be 1 and 24. The range is a good way to quickly summarize the boundaries of your data in just two numbers. By computing the range we know that none of the data is larger or smaller than the range. And, it can alert you to outliers. For example, if you are expecting your numbers to be between 1 and 7, but you find the range is 1 - 3405, then you know you have at least one big number that shouldn’t be there, and you can try to figure out why that occurred (and potentially remove it and other outliers). 2.6.2 Difference scores It would be nice to summarize the amount of differentness in the data. Here’s why: if you thought that raw data (lots of numbers) is too big to look at, then you will be frightened to contemplate how many differences there are to look at. For example, these 10 numbers are easy to look at: 1 3 4 5 5 6 7 8 9 24 But, what about the difference between the numbers, what do those look like? We can compute the difference scores between each number, then put them in a matrix like the one below: 1 3 4 5 5 6 7 8 9 24 1 0 2 3 4 4 5 6 7 8 23 3 -2 0 1 2 2 3 4 5 6 21 4 -3 -1 0 1 1 2 3 4 5 20 5 -4 -2 -1 0 0 1 2 3 4 19 5 -4 -2 -1 0 0 1 2 3 4 19 6 -5 -3 -2 -1 -1 0 1 2 3 18 7 -6 -4 -3 -2 -2 -1 0 1 2 17 8 -7 -5 -4 -3 -3 -2 -1 0 1 16 9 -8 -6 -5 -4 -4 -3 -2 -1 0 15 24 -23 -21 -20 -19 -19 -18 -17 -16 -15 0 We are looking at all of the possible differences between each number and every other number. So, in the top left, the difference between 1 and itself is 0. One column over to the right, the difference between 3 and 1 (3-1) is 2, etc. As you can see, this is a 10x10 matrix, which means there are 100 differences to look at. Not too bad, but if we had 500 numbers, then we would have 500*500 = 250,000 differences to look at (go for it if you like looking at that sort of thing). For a moment, let’s think about what this matrix look like if all of the 10 numbers in our data were the same number? It should look like a bunch of 0s right? In that case, we could easily see that the numbers have no variation. But, when the numbers are different, it’s not so easy to see what the variation of our data set is. However, we could ask something like, what is the average difference that we have? For example, we could take all of our differences and compute the mean difference. What do you think would happen if we did that? Let’s try it out on these three numbers: 1 2 3 1 2 3 1 0 1 2 2 -1 0 1 3 -2 -1 0 Let’s compute the mean: \\(\\text{mean of difference scores} = \\frac{0+1+2-1+0+1-2-1+0}{9} = \\frac{0}{9} = 0\\) Uh oh, we get zero for the mean of the difference scores. This will always happen whenever you take the mean of the difference scores. We can see that there are some differences between the numbers, so using 0 as the summary value for the variation in the numbers doesn’t make much sense. Furthermore, you might also notice that the matrices of difference scores are redundant. The diagonal is always zero, and numbers on one side of the diagonal are the same as the numbers on the other side, except their signs are reversed. These are problems that can be solved by computing the variance and the standard deviation. For now, the standard deviation is a just a trick that we use to avoid getting a zero. But, later we will see it has properties that are important for other reasons. 2.6.3 The variance Variability, variation, variance, vary, variable, varying, variety. Confused yet? Before we describe the variance, we want to you be OK with how this word is used. First, don’t forget the big picture. We know that variability and variation refers to the big idea of differences between numbers. We can even use the word variance in the same way. When numbers are different, they have variance. The word variance also refers to a specific summary statistic: the sum of the squared deviations from the mean. Hold on what? In plain English: the variance is the sum of the squared difference scores, where the difference scores are computed between each number in the data set and the mean. Let’s see the formula first5: \\(\\frac{{\\sum_{i=1}^N} (X_i - \\bar{X})^2}{N}\\), or in English: \\(\\text{Variance} = \\frac{\\text{Sum of squared difference scores}}{\\text{Number of Scores}}\\) 2.6.3.1 Deviations from the mean We got a little bit complicated before when we computed the difference scores between all of the numbers in the data. Let’s do it again, but in a more manageable way. This time, we calculate the difference between each score and the mean. The idea here is: We figure out how similar our scores are by computing the mean Then we figure out how different our scores are from the mean This could tell us something about whether our scores are really all very close to the mean (which could help us know if the mean is good representative number of the data), and something about how much differences there are in the numbers. Take a look at this table: scores values mean difference_from_mean 1 1 4.5 -3.5 2 6 4.5 1.5 3 4 4.5 -0.5 4 2 4.5 -2.5 5 6 4.5 1.5 6 8 4.5 3.5 Sums 27 27 0 Means 4.5 4.5 0 The first column shows we have 6 scores in the data set, and the value columns shows each individual score. The sum of the values and the mean are presented on the last two rows. The sum and the mean were obtained by: \\(\\frac{1+6+4+2+6+8}{6} = \\frac{27}{6} = 4.5\\). The third column mean, appears a bit silly. We are just listing the mean once for every score. If you think back to our discussion about the meaning of the mean, then you will remember that it equally distributes the total sum across each data point. We can see that here, if we treat each score as the mean, then every score is a 4.5. We can also see that adding up all of the means for each score gives us back 27, which is the sum of the original values. Also, we see that if we find the mean of the mean scores, we get back the mean (4.5 again). All of the action is occurring in the fourth column, difference_from_mean. Here, we are showing the difference scores from the mean, using \\(X_{i}-\\bar{X}\\). In other words, we subtracted the mean (\\(\\bar{X}\\)) from each individual score (\\(X_{i}\\)). So, the first score, 1, is -3.5 from the mean, the second score, 6, is +1.5 from the mean, and so on. Now, we can look at our original scores and we can look at their differences from the mean. Notice, we don’t have a matrix of raw difference scores, so it is much easier to look at. But, we still have a problem: We can see that there are non-zero values in the difference scores, so we know there are a differences in the data. But, when we add them all up, we still get zero, which makes it seem like there are a total of zero differences in the data… 2.6.3.2 The squared deviations Some devious someone divined a solution to the fact that differences scores from the mean always add to zero. The devious solution is to square the numbers. Squaring numbers converts all the negative numbers to positive numbers. For example, \\(2^2 = 4\\), and \\(-2^2 = 4\\). We use the term squared deviations to refer to differences scores that have been squared. Deviations are things that move away from something. The difference scores move away from the mean, so we also call them deviations. Let’s look at our table again, but add the squared deviations. scores values mean difference_from_mean squared_deviations 1 1 4.5 -3.5 12.25 2 6 4.5 1.5 2.25 3 4 4.5 -0.5 0.25 4 2 4.5 -2.5 6.25 5 6 4.5 1.5 2.25 6 8 4.5 3.5 12.25 Sums 27 27 0 35.5 Means 4.5 4.5 0 5.91666666666667 OK, now we have a new column called squared_deviations. These are just the difference scores squared. So, \\(-3.5^2 = 12.25\\), etc. You can confirm this for yourself with your calculator. Now that all of the squared deviations are positive, we can add them up. When we do this we create something very special called the sum of squares (SS), also known as the sum of the squared deviations from the mean. 2.6.3.3 Finally, the variance Guess what, we already computed the variance. It already happened, and maybe you didn’t notice. First, see if you can remember what we are trying to do here. Take a pause, and see if you can tell yourself what problem we are trying solve. pause Without further ado, we are trying to get a summary of the differences in our data. There are just as many difference scores from the mean as there are data points, which can be a lot, so it would be nice to have a single number to look at, something like a mean, that would tell us about the average differences in the data. If you look at the table, you can see we already computed the mean of the squared deviations. First, we found the sum of squares (SS), then below that we calculated the mean of the sum of squares = 5.916 repeating. This is the variance. The variance is the mean of the sum of the squared deviations: \\(\\text{variance} = \\frac{SS}{N}\\), where SS is the sum of the squared deviations, and N is the number of observations. OK, now what. What do I do with the variance? What does this number mean? Good question. The variance is often an unhelpful number to look at, because it is not in the same scale as the original data. This is because we squared the difference scores before taking the mean. Squaring produces large numbers. For example, we see a 12.25 in there. That’s a big difference, bigger than any difference between any two original values. How can we bring the numbers back down to their original unsquared size? That’s easy: we can always unsquare anything by taking the square root. So, let’s do that to 5.916: \\(\\sqrt{5.916} =\\) 2.4322829. 2.6.4 The standard deviation Oops, we did it again. We already computed the standard deviation, and we didn’t tell you. The standard deviation is the square root of the variance…At least, it is right now, until we complicate matters for you in later chapters. Here is the formula for the standard deviation: \\(\\text{standard deviation} = \\sqrt{\\text{variance}} = \\sqrt{\\frac{SS}{N}}\\). We could also expand this to say: \\(\\text{standard deviation} = \\sqrt{\\frac{\\sum_{i=1}^{N}({X_{i}-\\bar{X})^2}}{N}}\\) Don’t let those big square root signs put you off. You know what they are doing there: they are just bringing our measure of the variance back down to the original size of the data. Let’s look at our table again: scores values mean difference_from_mean squared_deviations 1 1 4.5 -3.5 12.25 2 6 4.5 1.5 2.25 3 4 4.5 -0.5 0.25 4 2 4.5 -2.5 6.25 5 6 4.5 1.5 2.25 6 8 4.5 3.5 12.25 Sums 27 27 0 35.5 Means 4.5 4.5 0 5.91666666666667 We measured the standard deviation as 2.4322829. Notice this number fits right in the with differences scores from the mean. All of the scores are kind of in and around + or - 2.4322829. Whereas, if we looked at the variance, 5.916 is just too big, it doesn’t summarize the actual differences very well. What does all this mean? Well, if someone told they had some number with a mean of 4.5 (like the values in our table), and a standard deviation of 2.4322829, you would get a pretty good summary of the numbers. You would know that many of the numbers are around 4.5, and you would know that not all of the numbers are 4.5. You would know that the numbers spread around 4.5. You also know that the spread isn’t super huge, it’s only + or - 2.4322829 on average. That’s a good starting point for describing numbers. If you had loads of numbers, you could reduce them down to the mean and the standard deviation, and still be pretty well off in terms of getting a sense of those numbers. 2.6.5 Closing thoughts on measures of variation We spent many paragraphs talking about variation in numbers, and how to use the variance and standard deviation to summarize the average differences between numbers in a data set. The basic process was to 1) calculate some measure of the differences, then 2) average the differences to create a summary. We found that we couldn’t average the raw difference scores, because we would always get a zero. So, we squared the differences from the mean, then averaged the squared differences differences. Finally, we square rooted our measure to bring the summary back down to the scale of the original numbers. Perhaps you were thinking that the problem of summing difference scores (so that they don’t equal zero), can be solved in more than one way. How about just taking the absolute value of the difference scores?6 Many things are possible. The important aspect to any of this is to have a reason for what you are doing, and to choose a method that works for the data-analysis problem you are trying to solve. Note also, we bring up this general discussion because we want you to understand that statistics is a creative exercise. We invent things when we need them, and we use things that have already been invented when they work for the problem at hand. 2.7 Remember to look at your data Using numbers to describe data is great and we will use it a lot during this course, but you may suspect these descriptive statistics also have some short-comings. They are compressed summaries of large piles of numbers and will almost always be unable to represent all of the numbers fairly. There are also different kinds of descriptive statistics that you could use and it sometimes not clear which one’s you should use. Perhaps the most important thing you can do when describing data is to use both graphs and numbers. This can help you see whether or not your descriptive statistics are doing a good job of representing the data. 2.7.1 Anscombe’s Quartet To hit this point home, and to get you thinking about the issues we discuss in the next chapter, check out the following. It’s called Anscombe’s Quartet, because these interesting graphs and numbers were produced by Anscombe (1973). You are looking at several scatterplots of different measurements and each of the plots look very different, right? It is maybe surprising to learn that the descriptive statistics for the numbers in these graphs are (almost) exactly the same. In the table below I present the mean and variance for the x-values in each graph, and the mean and the variance for the y-values in each graph. quartet mean_x var_x mean_y var_y 1 9 11 7.500909 4.127269 2 9 11 7.500909 4.127629 3 9 11 7.500000 4.122620 4 9 11 7.500909 4.123249 Anscombe put these special numbers together to illustrate the point of visualizing your numbers. If you only look at your descriptive statistics, you don’t know what patterns in the data they are hiding. If you look at your descriptive statistics in combination with a graph, then you can get a better understanding. 2.7.2 Datasaurus Dozen If you thought that Anscombe’s quartet was neat, you should take a look at the Datasaurus Dozen (Matejka and Fitzmaurice 2017). The scatterplots show many different patterns, including dinosaurs! What’s amazing is that all of the scatterplots have very nearly the same descriptive statistics. Just another reminder to look at your data, it might look like a dinosaur! Figure 2.6: Datasaurus: different scatterplots with nearly identical descriptive statistics 2.8 That’s it for this week That’s it for the readings of the second week. During the lab you will learn about graphing and generating descriptive statistics in R. Additional practice materials for this week can be found on SOWISO. The practice materials are by no means mandatory, are ideally made after the lab, and are a bit more advanced, but they can help you further understand descriptive statistics in R. Finally, if you haven’t done so already, make sure you’ve signed up for an assignment group. Chapter by Matthew Crump↩︎ The formulas for variance and standard deviation depend on whether you think your data represents an entire population of numbers, or is sample from the population. We discuss this issue later on. For now, we divide by N (the number of observations), later we discuss why you will often divide by N-1 instead.↩︎ For a discussion on why we tend to use squared deviations in statistics instead of absolute deviations see here↩︎ "],["chcorrelationandcaus.html", " 3 Week 3: Correlation and Causation7 3.1 If something caused something else to change, what would that look like? 3.2 Pearson’s \\(r\\) 3.3 Examples of \\(r\\) with data 3.4 Interpreting correlations 3.5 Relationships between variables 3.6 Establishing causal relationships 3.7 Meaningful comparisons 3.8 Taxonomy of research design 3.9 Range of research design 3.10 The validity of your study 3.11 Threats to experimental validity 3.12 That’s it for this week", " 3 Week 3: Correlation and Causation7 Correlation does not equal causation —Every Statistics and Research Methods Instructor Ever Last week we explored fake human happiness data. We imagined that we asked a bunch of people to tell us how happy they were, then we looked at the numbers they gave us. There were too many numbers to look at directly, but we could summarize happiness using graphs and their central tendencies (sameness) and variability (differentness). Before moving on, you should be skeptical of what the numbers might mean. For example, if you force people to give a number to rate their happiness, does this number truly reflect how happy they are? Does how the question is phrased affect the answers? Is happiness even a real thing? These are all good questions about the validity of the construct (happiness itself) and the measure (numbers) you are using to quantify it. For now, though, we will side-step those very important questions until later in this chapter. OK, after we have measured some happiness, I bet you can think of some interesting questions. For example: what causes happiness to go up or down? If you knew the causes of happiness you could increase your own happiness; or, help people who are unhappy; or, better appreciate why Eeyore from Winnie the Pooh is unhappy; or, present valid scientific arguments that argue against incorrect claims about what causes happiness. A causal theory and understanding of happiness could be used for all of those things, so how can we get there? 3.1 If something caused something else to change, what would that look like? Before we go around determining the causes of happiness, we should prepare ourselves with some analytical tools so that we could identify what causation looks like. If we don’t prepare ourselves for what we might find, then we won’t know how to interpret our own data. Instead, we need to anticipate what the data could look like. Specifically, we need to know what data would look like when one thing does not cause another thing, and what data would look like when one thing does cause another thing. This chapter does some of this preparation. Fair warning: we will find out some tricky things. For example, we can find patterns that look like one thing is causing another, even when that one thing DOES NOT CAUSE the other thing. Hang in there. 3.1.1 Charlie and the chocolate factory Let’s imagine that a person’s supply of chocolate has a causal influence on their level of happiness. Let’s further imagine that, like Charlie, the more chocolate you have the more happy you will be, and the less chocolate you have, the less happy you will be. Finally, because we suspect happiness is caused by lots of other things in a person’s life, we anticipate that the relationship between chocolate supply and happiness won’t be perfect. What do these assumptions mean for how the data should look? Our first step is to collect some imaginary data from 100 people. We walk around and ask the first 100 people we meet to answer two questions: how much chocolate do you have, and how happy are you. For convenience, both the scales will go from 0 to 100. For the chocolate scale, 0 means no chocolate, 100 means lifetime supply of chocolate. Any other number is somewhere in between. For the happiness scale, 0 means no happiness, 100 means all of the happiness, and in between means some amount in between. Below is how the data was generated in R and in the table you can find the sample data from the first 10 imaginary subjects. Again, note this is simulated data (using the runif() function), we didn’t actually go around asking people about their happiness and chocolate consumption. # uniform dist to generate pretend happiness and chocolate variables chocolate &lt;- round(1:100 * runif(100, 0.5, 1)) happiness &lt;- round(1:100 * runif(100, 0.5, 1)) # create subject column (numbers 1 to 100) subject &lt;- seq(1, 100, 1) # put all variables in a dataframe df_charlie &lt;- data.frame(subject, chocolate, happiness) subject chocolate happiness 1 1 1 2 1 2 3 2 3 4 3 2 5 4 5 6 5 4 7 4 7 8 6 5 9 5 7 10 10 6 We asked each subject two questions so there are two scores for each subject, one for their chocolate supply, and one for their level of happiness. You might already notice some relationships between amount of chocolate and level of happiness in the table. To make those relationships even more clear, let’s plot all of the data in a graph. When you have two variables worth of data, you can turn the data into a scatterplot where you get to choose which variable goes on which axis. Let’s put chocolate supply on the x-axis, and happiness level on the y-axis. library(tidyverse) ggplot(df_charlie, aes(x = chocolate, y = happiness))+ geom_point() + theme_classic() Figure 3.1: Imaginary data showing a positive relationship between amount of chocolate and amount happiness What do the dots mean? Each dot has two coordinates, an x-coordinate for chocolate, and a y-coordinate for happiness. The first dot, all the way on the bottom left is the first subject in the table, who had close to 0 chocolate and close to zero happiness. You can look at any dot and draw a straight line down to the x-axis: that will tell you how much chocolate that subject has. When you draw a straight line left to the y-axis for the same dot it will tell you how much happiness that particular subject has. Now that we are looking at the scatterplot, we can clearly see that the dots show a relationship between chocolate supply and happiness. Happiness is lower for people with smaller supplies of chocolate, and higher for people with larger supplies of chocolate. It looks like the more chocolate you have the happier you will be, and vice-versa. This kind of relationship is called a positive relationship or positive correlation. 3.1.2 Positive, negative or no correlation Seeing as we are in the business of imagining data, let’s imagine some more. We’ve already seen what data looks like if larger chocolate supplies increase happiness. What do you imagine the scatterplot would look like if the relationship was reversed, and larger chocolate supplies decreased happiness? Or, what do you imagine the scatter plot would look like if there was no relationship, and the amount of chocolate that you have doesn’t do anything to your happiness? Let’s look at the following graph showing exactly that: Figure 3.2: Three scatterplots showing positive, negative, and zero correlation The first panel shows a positive correlation, like in Figure 3.1: happiness goes up as chocolate as chocolate supply increases. The second panel shows a negative correlation. Negative correlations occur when one thing goes up and the other thing goes down; or, when more of X is less of Y, and vice-versa. The third panel shows no correlation. Here, there doesn’t appear to be any obvious relationship between chocolate supply and happiness. The dots are scattered all over the place, the “truest of the scatterplots”8. 3.2 Pearson’s \\(r\\) If Beyoncé was a statistician, she might look at these scatterplots and want to “put a number on it.” We think this is a good idea too. We’ve already learned how to create descriptive statistics for a single measure, like chocolate, or happiness (i.e., means, variances, etc.). A descriptive statistic that summarizes the relationship between two measures, all in one number, was invented by Karl Pearson9. Everyone now calls it: “Pearson’s \\(r\\).” Karl Pearson was a big-wig editor at Biometrika in the 1930s and all around horrible person. He took a hating to another big-wig statistician, Sir Ronald Fisher (who we learn about later, but was also generally a horrible person), and they had some fights about statistics… Seen as the founding fathers of modern statistics, both Pearson and Fisher held deeply racist views and actively contributed to the field of eugenics. You can read more about the troubled history of modern statistics in many, many different places. For now, we will focus about how different statistics work and how to use statistics (for good, hopefully), but it’s important to keep this troubled history in mind. How does Pearson’s \\(r\\) work? Let’s look again at the first 10 subjects in our fake experiment: subject chocolate happiness 1 1 1 2 1 2 3 2 3 4 3 2 5 4 5 6 5 4 7 4 7 8 6 5 9 5 7 10 10 6 Sums 41 42 Means 4.1 4.2 What could we do to these numbers to produce a single summary value that represents the relationship between the chocolate supply and happiness? 3.2.1 The idea of covariance Remember: variance tells us something about the differentness of a measure. In this example, we can see that there is variance in chocolate supply across the 10 subjects and that there is variance in happiness across the 10 subjects. In the scatterplot we saw that as happiness increases, chocolate supply increases (a positive relationship). In other words: the two measures vary together. When we have two measures that vary together, they are like a happy couple who share their variance. This is what covariance refers to: the idea that the pattern of varying numbers in one measure is shared by the pattern of varying numbers in another measure. Covariance is very important. We suspect that the word covariance is initially confusing, especially if you are not yet fully comfortable with the meaning of variance for a single measure. Nevertheless, we must proceed and use the idea of covariance to firmly implant it into your statistical mind. Note: A three-legged race can be seen as a metaphor for covariance. Two people tie one leg to each other, then try to walk. It works when they co-vary their legs together (positive relationship). They can also co-vary in an unhelpful way, when one person tries to move forward exactly when the other person tries to move backward. This is still covariance (negative relationship). Funny random walking happens when there is no covariance. This means one person does whatever they want, and so does the other person. There is a lot of variance, but the variance is shared randomly, so it’s just a bunch of legs moving around accomplishing nothing. Note #2: Succesfully playing pattycake occurs when two people coordinate their actions so they have postively shared covariance. 3.2.2 A measure of covariance “OK, so you are saying that covariance is just another word for the association or relationship between two measures. I suppose we could use some way to measure that.” Yes! Back to our table…notice anything new? subject chocolate happiness chocolate_X_happiness 1 1 1 1 2 1 2 2 3 2 3 6 4 3 2 6 5 4 5 20 6 5 4 20 7 4 7 28 8 6 5 30 9 5 7 35 10 10 6 60 Sums 41 42 208 Means 4.1 4.2 20.8 We’ve added a new column called “chocolate_X_happiness,” which stands for chocolate scores multiplied by happiness scores. Each row in the new column is the product, or multiplication, of the chocolate and happiness score for that row. Why would we want to do this? Last chapter we took you back to elementary school and had you think about division. Now it’s time to do the same thing with multiplication. One number times another, means taking the first number, and adding it as many times as the second says to do: \\(2*2= 2+2=4\\) \\(2*6= 2+2+2+2+2+2 = 12\\), or \\(6+6=12\\), same thing. You know all that. All we have to think about next are the consequences of multiplying sets of numbers together. For example, what happens when you multiply two small numbers together, compared to multiplying two big numbers together? The first product should be smaller than the second product right? How about things like multiplying a small number by a big number? Those products should be in between, right? The next step is to think about how the products of two measures sum together, depending on how they line up. Let’s look at another table: scores X Y A B XY AB 1 1 1 1 10 1 10 2 2 2 2 9 4 18 3 3 3 3 8 9 24 4 4 4 4 7 16 28 5 5 5 5 6 25 30 6 6 6 6 5 36 30 7 7 7 7 4 49 28 8 8 8 8 3 64 24 9 9 9 9 2 81 18 10 10 10 10 1 100 10 Sums 55 55 55 55 385 220 Means 5.5 5.5 5.5 5.5 38.5 22 Look at the \\(X\\) and \\(Y\\) column. The scores for \\(X\\) and \\(Y\\) perfectly co-vary. When \\(X\\) is 1, \\(Y\\) is 1; when \\(X\\) is 2, \\(Y\\) is 2, etc. They are perfectly aligned. The scores for \\(A\\) and \\(B\\) also perfectly co-vary, just in the opposite manner. When \\(A\\) is 1, \\(B\\) is 10; when \\(A\\) is 2, \\(B\\) is 9, etc. \\(B\\) is a reversed copy of \\(A\\). Now, look at the column \\(XY\\). These are the products we get when we multiply the values of \\(X\\) across with the values of Y. Also, look at the column \\(AB\\). These are the products we get when we multiply the values of \\(A\\) across with the values of \\(B\\). So far so good. Next, look at the Sums for the \\(XY\\) and \\(AB\\) columns. They are not the same. The sum of the \\(XY\\) products is 385, and the sum of the \\(AB\\) products is 220. For this specific set of data, the numbers 385 and 220 are very important. They represent the biggest possible sum of products (385), and the smallest possible sum of products (220). There is no way of re-ordering the numbers 1 to 10 for \\(X\\), and the numbers 1 to 10 for \\(Y\\), that would ever produce larger or smaller numbers. Check this out: The above graph shows 1000 computer simulations. I convinced my computer to randomly order the numbers 1 to 10 for \\(X\\), and randomly order the numbers 1 to 10 for \\(Y\\). Then, I multiplied \\(X\\) and \\(Y\\), and added the products together. I did this 1000 times. The dots show the sum of the products for each simulation. The two red lines show the maximum possible sum (385), and the minimum possible sum (220), for this set of numbers. Notice, how all of the dots are in between the maximum and minimum possible values. “Who cares?” Well, for these numbers, we have found a way to summarize the covariance between two measures. We know that when the sum of the products is 385, we have found a perfect, positive relationship. We also know that when the sum of the products is 220, we have found a perfect negative relationship. What about the numbers in between? What could we conclude about the relationship if we found the sum of the products to be 350? Well, it’s likely going to be positive, because it’s close to 385, which is perfectly positive. If the sum of the products was 240, the relationship is likely going to be negative, because it’s close to the perfectly negative 220. What about no relationship? Well, that’s going to be in the middle between 220 and 385. We have just come up with a data-specific summary measure for the relationship between the numbers 1 to 10 in \\(X\\), and the numbers 1 to 10 in \\(Y\\): it’s the sum of the products. We know the maximum (385) and minimum values (220), so we can now interpret any product sum for this kind of data with respect to that scale. Note: when the relationship between two measures increases in the positive direction, the sum of their products increases to its maximum possible value. This is because the bigger numbers in \\(X\\) will tend to line up with the bigger numbers in \\(Y\\), creating the biggest possible sum of products. When the relationship between two measures increases in the negative direction, the sum of their products decreases to its minimum possible value. This is because the bigger numbers in \\(X\\) will tend to line up with the smaller numbers in \\(Y\\), creating the smallest possible sum of products. When there is no correlation, the big numbers in X will be randomly lined up with the big and small numbers in \\(Y\\), making the sum of the products somewhere in the middle. 3.2.3 Covariance formalized We took some time to see what happens when you multiply sets of numbers together. We found that \\(\\text{big*big = bigger}\\) and \\(\\text{small*small=still small}\\), and \\(\\text{big*small=in the middle}\\). The purpose of this was to give you some conceptual idea of how the covariance between two measures is reflected in the sum of their products. We did something very straightforward. We just multiplied \\(X\\) with \\(Y\\), and looked at how the product sums get big and small, as \\(X\\) and \\(Y\\) co-vary in different ways. Now, we can get a little bit more formal. In statistics, covariance is not just the straight multiplication of values in \\(X\\) and \\(Y\\). Instead, it’s the multiplication of the deviations in \\(X\\) from the mean of \\(X\\), and the deviation in \\(Y\\) from the mean of \\(Y\\). Remember those difference scores from the mean we talked about last chapter? They’re coming back to haunt you now, but in a good way, like Casper the friendly ghost. Let’s see what this look like in a table: subject chocolate happiness c_d h_d cd_X_hd 1 1 1 -3.1 -3.2 9.92 2 1 2 -3.1 -2.2 6.82 3 2 3 -2.1 -1.2 2.52 4 3 2 -1.1 -2.2 2.42 5 4 5 -0.1 0.8 -0.08 6 5 4 0.9 -0.2 -0.18 7 4 7 -0.1 2.8 -0.28 8 6 5 1.9 0.8 1.52 9 5 7 0.9 2.8 2.52 10 10 6 5.9 1.8 10.62 Sums 41 42 0 0 36 Means 4.1 4.2 0 0 3.58 We have computed the deviations from the mean for the chocolate scores (column c_d), and the deviations from the mean for the happiness scores (column h_d). Then, we multiplied them together (last column). Finally, you can see the mean of the products listed in the bottom right corner of the table, the covariance. The formula for the covariance is: \\(cov(X,Y) = \\frac{\\sum_{i=1}^{N}(X_{i}-\\bar{X})(Y_{i}-\\bar{Y})}{N}\\) These are simply the steps we just took, but in the form of a formula. OK, so now we have a formal single number to calculate the relationship between two variables. This is great, it’s what we’ve been looking for. However, there is still a problem. Remember when we learned how to compute just the plain old variance. We looked at that number, and we didn’t know what to make of it. It was squared, it wasn’t in the same scale as the original data. So, we square rooted the variance to produce the standard deviation, which gave us a more interpretable number in the range of our data. The covariance has a similar problem. When you calculate the covariance as we just did, we don’t know immediately know its scale. Is a 3 big? is a 6 big? is a 100 big? How big or small is this thing? From our prelude discussion on the idea of covariance, we learned the sum of products between two measures ranges between a maximum and minimum value. The same is true of the covariance. For a given set of data, there is a maximum possible positive value for the covariance (which occurs when there is perfect positive relationship). And, there is a minimum possible negative value for the covariance (which occurs when there is a perfect negative relationship). When there is zero co-variation: zeroes. So, at the very least, when we look at a co-variation statistic, we can see what direction it points, positive or negative. But, we don’t know how big or small it is compared to the maximum or minimum possible value, so we don’t know the relative size, which means we can’t say how strong the relationship is. What to do? 3.2.4 \\(r\\) we there yet? Yes, we are here now. Wouldn’t it be nice if we could force our measure of co-variation to be between -1 and +1? -1 would be the minimum possible value for a perfect negative association. +1 would be the maximum possible value for a perfect positive association. 0 would mean no association. Everything in between 0 and -1 would be increasingly large negative associations. Everything between 0 and +1 would be increasingly large positive associations. It would be a fantastic, sensible, easy to interpret system. If only we could force the co-variation number to be between -1 and 1. Fortunately, Pearson’s \\(r\\) does precisely this wonderful thing. Let’s take a look at a formula: \\(r = \\frac{cov(X,Y)}{\\sigma_{X}\\sigma_{Y}} = \\frac{cov(X,Y)}{SD_{X}SD_{Y}}\\) We see the symbol \\(\\sigma\\) here, that’s more Greek for you. \\(\\sigma\\) is often used as a symbol for the standard deviation (SD). If we read out the formula in English, we see that \\(r\\) is the covariance of \\(X\\) and \\(Y\\), divided by the product of the standard deviation of \\(X\\) and the standard deviation of \\(Y\\). Dividing the covariance by the product of the standard deviations has the effect of normalizing the covariance into the range -1 to 1. For now, we will call this mathematical magic10. It works, but we don’t have space to tell you why it works right now. Note: it’s worth saying that there are loads of different formulas for computing Pearson’s \\(r\\). You can find them by Googling them. However, they all give you the same answer. And, they are all not as pretty as each other. Some of them might even look scary. In other statistics textbook you will often find formulas that are easier to use for calculation purposes. For example, if you only had a pen and paper, you might use one or another formula because it helps you compute the answer faster by hand. To be honest, we are not very interested in teaching you how to plug numbers into formulas. Nowadays you have a computer that you should use for this kind of stuff. So, we are more interested in teaching you what the calculations mean, rather than how to do them. Of course, every week we are showing you how to do the calculations in the labs using computers. Does Pearson’s \\(r\\) really stay between -1 and 1 no matter what? It’s true, take a look at the following simulation. Here I randomly ordered the numbers 1 to 10 for an \\(X\\) measure, and did the same for a \\(Y\\) measure. Then, I computed Pearson’s \\(r\\), and repeated this process 1000 times. As you can see all of the dots are between -1 and 1. Neat huh. Figure 3.3: A simulation of 1000 correlations. Each dot represents the \\(r\\)-value for the correlation between an \\(X\\) and \\(Y\\) variable that each contain the numbers 1 to 10 in random orders. 3.3 Examples of \\(r\\) with data During the labs you will be shown how to compute correlations in real datasets using software. To give you a brief preview, let’s look at some data from the world happiness report (2018). This report measured various attitudes across people from different countries over the time period 2006-2017. For example, one question asked about how much freedom people thought they had to make life choices. Another question asked how confident people were in their national government. Here is a scatterplot showing the relationship between these two measures and how to generate that plot in R. Each dot represents a different country in 2017. # import the data whr_data &lt;- read_csv(&#39;https://raw.githubusercontent.com/thomashulst/quantrma/master/data/WHR2018.csv&#39;) # select the relevant variables and filter missing data (NA) smaller_df &lt;- whr_data %&gt;% select(country, `Freedom to make life choices`, `Confidence in national government`, `year`) %&gt;% filter(`year` == 2017) %&gt;% filter(!is.na(`Freedom to make life choices`), !is.na(`Confidence in national government`)) # plot the data with best fit line ggplot(smaller_df, aes(x=`Freedom to make life choices`, y=`Confidence in national government`))+ geom_point(alpha=.5)+ geom_smooth(method=lm, se=FALSE)+ theme_classic() Figure 3.4: Relationship between freedom to make life choices and confidence in national government. Data for the year 2017 from the world happiness report for 2018. We put a blue line on the scatterplot to visualize the positive relationship. It appears that as “freedom to make life choices goes up,” so to does confidence in national government. It’s a positive correlation. The actual correlation, as measured by Pearson’s \\(r\\) is: # calculate correlation cor(smaller_df$`Freedom to make life choices`, smaller_df$`Confidence in national government`) ## [1] 0.4419082 You will do a lot more of this kind of thing during the lab. Looking at the graph and the value of the correlation, you might start to wonder: does freedom to make life choices cause changes how confident people are in their national government? Our does it work the other way? Does being confident in your national government give you a greater sense of freedom to make life choices? Or, is this just a random relationship that doesn’t mean anything? The correlation does not provide an answer to these questions other than suggesting a possible relationship. How to interpret a correlation is the topic of the next section. 3.4 Interpreting correlations What does the presence or the absence of a correlation between two measures mean? How should correlations be interpreted? What kind of inferences can be drawn from correlations? These are all very good questions. A first piece of advice is to use caution when interpreting correlations. Perhaps you have heard that correlation does not equal causation. There are lots of reasons why not. However, before listing some of the reasons, let’s start with a case where we would expect a causal connection between two measurements. Consider buying a snake plant for your home. Snake plants are supposed to be easy to take care of because you can mostly ignore them. Like most plants, snake plants need some water to stay alive. However, they also need just the right amount of water. Imagine an experiment where 1000 snake plants were grown in a house. Each snake plant is given a different amount of water per day, from zero teaspoons of water per day to 1000 teaspoons of water per day. We will assume that water is part of the causal process that allows snake plants to grow. The amount of water given to each snake plant per day is our first measure. Imagine further that every week the experimenter measures snake plant growth, which will be the second measurement. Now, can you imagine for yourself what a scatter plot of weekly snake plant growth by tablespoons of water would look like? 3.4.1 Causation without correlation The first plant given no water at all would have a very hard time and eventually die. It should have the least amount of weekly growth. How about the plants given only a few teaspoons of water per day. This could be just enough water to keep the plants alive, so they will grow a little bit but not a lot. If you are imagining a scatter plot, with each dot being a snake plant, then you should imagine some dots starting in the bottom left hand corner (no water &amp; no plant growth), moving up and to the right (a bit of water, and a bit of growth). As we look at snake plants getting more and more water, we should see more and more plant growth, right? But only up to a point… There’s a likely positive correlation with increasing plant growth as amount of water per day increases. But, what happens when you give snake plants too much water? From personal experience, they tend to die. So, at some point, the dots in the scatter plot will start moving back down again. Snake plants that get way too much water will not grow very well. The imaginary scatter plot you should be envisioning could have an upside U shape. Going from left to right, the dot’s go up, they reach a maximum, then they go down again reaching a minimum. Computing Pearson’s \\(r\\) for data like this gives you \\(r\\) values close to zero, while the scatter plot could look something like this: Figure 3.5: Illustration of a possible relationship between amount of water and snake plant growth. Growth goes up with water, but eventually goes back down as too much water makes snake plants die. Granted this looks more like an inverted V, than an inverted U, but you get the picture right? There is clearly a relationship between watering and snake plant growth. But, the relationship isn’t in one direction. As a result, when we compute the correlation in terms of Pearson’s r, we get a value very close to 0, suggesting no relationship. cor(growth,water) ## [1] -0.003107585 This example illustrates some conundrums in interpreting correlations. We already know that water is needed for plants to grow, so we are rightly expecting there to be a relationship between our measure of amount of water and plant growth. If we look at the first half of the data we see a positive correlation, if we look at the last half of the data we see a negative correlation, and if we look at all of the data we see no correlation. Yikes. So, even when there is a causal connection between two measures, we won’t necessarily obtain clear evidence of the connection just by computing a correlation coefficient. Note: This is one reason why plotting your data is so important. If you see an upside U shape pattern, then a correlation is probably not the best way of analyzing your data. 3.4.2 Third variables Anybody can correlate any two things that can be quantified and measured. For example, we could find a hundred people, ask them all sorts of questions like: how happy are you how old are you how tall are you how much money do you make per year how long are your eyelashes how many books have you read in your life how loud is your inner voice Let’s say we found a positive correlation between yearly salary and happiness. Would you be willing to infer that yearly salary causes happiness? Perhaps it does play a part. But, something like happiness probably has a lot of contributing causes. Money could directly cause some people to be happy. But, more likely, money buys people access to all sorts of things, and some of those things might contribute happiness. These “other” things are called third variables. For example, perhaps people living in nicer places in more expensive houses are more happy than people in worse places in cheaper houses. In this scenario, money isn’t causing happiness, it’s the places and houses that money buys. But, even is this were true, people can still be more or less happy in lots of different situations. A more absurd example comes from the (seemingly) very strong correlation between ice cream sales and shark attacks: Figure 3.6: A relationship between ice cream sales and shark attacks? Data obtained here. If you were to calculate the correlation between ice cream sales and shark attacks you would find a value close to 1. In fact, that’s what I did and I found a correlation of 0.79, indicating a very strong positive relationship between the two variables. Are sharks allergic to ice cream and taking out their frustration on random swimmers-by? Should we ban ice cream in beach towns for public safety reasons? What is going on? Here, as well, the relationship is better explained by a third variable that wasn’t measured: during hot weather people are more likely to buy ice cream and also more likely to go swimming, increasing the overall likelihood of being attacked by a shark. The lesson here is that a correlation can occur between two measures because of a third variable that is not directly measured. So, just because we find a correlation, does not mean we can conclude anything about a causal connection between two measurements. 3.5 Relationships between variables These ideas lie at the core of empirical research. To enhance our understanding, we will develop an analytical framework which will help us see the various ways three variables might be related to each other. Causal relationships can occur either directly or indirectly. As the names suggest, a direct causal relationship refers to the un-intervening impact of one variable on another, whereas an indirect causal relationship refers to the intervening impact of one variable on another. For example, the direct causal relationship between salary and happiness can be understood as the intrinsic value of money in one’s level of happiness. In contrast, if it turns out that a salary increase makes people happier because they can consume more, the causal relationship is indirect, since consumption lies in-between the independent and dependent variable. In other words, consumption is an intervening variable. The figures below visualize this idea: Figure 3.7: Direct and indirect relationships between salary and happiness. However, things might not be as simple as the figures above suggest. In fact, researchers are usually confronted with a multitude of associations operating at the same time. Think of the example above. What would be the most accurate representation of the association between salary and happiness? Could a direct and indirect effect operate simultaneously? Most likely yes! Could there be several indirect effects operating simultaneously? Again, most likely yes! Figure 3.8: Simultaneous direct and multiple indirect effects between salary and happiness. Direct and indirect relationships only partially describe what is going on behind the scenes when researchers evaluate hypotheses. In some of your previous courses, you might have encountered the term alternative explanations. An alternative explanation is an explanation not accounted for by the researcher (hence alternative) and can bias the conclusions of the study. We will use the term confounder to refer to variables that generate alternative explanations. To better understand the function of confounders and how they differ from intervening variables, we will visualize a simple analytical framework that will allow us to understand the various ways three (or more) variables might be related to each other. We start with the example above and then generalize. What could potentially bias our efforts to estimate the causal relationship between salary and happiness? In other words, what could be a confounder? Let’s think about one’s level of education. If you attend college, you will likely end up with a higher salary. At the same time, the experience of attending college can help you develop certain personality traits, such as resilience and confidence, which in turn might affect happiness. Let’s visualize what we just said: Figure 3.9: College education as a confounder of salary and happiness. Notice the difference between the role of college education in this example and the role of consumption in the example prior (Figure 3.7). We should always pay attention to how a third variable \\(Z\\) might relate to the independent variable \\(X\\) (salary) and the dependent variable \\(Y\\) (happiness): if \\(X\\) affects \\(Z\\) which in turn affects \\(Y\\), \\(Z\\) is an intervening variable and the whole path can be described as an indirect causal relationship. If \\(X\\) and \\(Y\\) are affected by \\(Z\\), \\(Z\\) is a confounder and the path can be described as a spurious relationship. Why spurious? Because, if the researcher does not consider whether an individual has attended college education or not, they will mistakenly interpret the observed correlation between salary and happiness as evidence suggesting a causal relationship between the two, where in fact both are driven by something else. Let’s put everything we have discussed so far in an example together. The following diagram represents a direct and indirect causal relationship with a spurious component. Figure 3.10: Simultaneous direct and multiple indirect effects between salary and happiness with college education as a confounder. As you may have guessed, the more variables we end up including in our conceptual representation of our research, the more complex our diagrams will be. However, the following key ideas remain the same as the researcher should always try to specify: whether relationships between variables are presumed to be causal or spurious; whether causal relationships are expected to be direct or indirect; the mechanisms (i.e. intervening variables) underlying any indirect causal relationship. Any relationship between two variables will consist of two components: a causal component (the one we try to uncover) and a spurious component (the one we try to eliminate). The value of this exercise rests on our ability to articulate our research question and the most plausible line of explanation: the more accurate our understanding of empirical reality, the more likely it will be to get closer to the true causal relationship between \\(X\\) and \\(Y\\). 3.6 Establishing causal relationships We will further explore how to establish causal relationships using research design techniques with a motivating example from economics. Economists have long theorized about the importance of human capital on productivity. The widely held belief is that investments in human capital result in productivity growth (Becker 2009). Suppose we would like to establish this relationship with an empirical study using quantitative methods. Where do we start? Let’s first unpack the theory posed by economists: “investments in human capital result in productivity growth.” What is meant by human capital? Human capital are basically all personality traits and individual characteristics embodied in the ability to perform labor that produces economic value. For example: your habits, knowledge, social skills, analytical skills, creativity and many more individual characteristics. Then, what is meant by productivity? Productivity reflects the amount of output one unit of input can produce. Since we are talking about humans, productivity can be thought of as labor productivity, or the output of one hour of work. So far, so good. Since we want to conduct an empirical study on the relationship between human capital and productivity, we need to operationalize these concepts to enable measurement of them. Suppose we operationalize human capital with education and productivity with hourly wage. Now, we could investigate an observation like: college graduates enjoy high hourly wages. Can we use this observation to claim a causal relationship between having a college degree (human capital) and hourly wages (productivity)? Clearly not, the observation itself provides no evidence in support of the claim. As long as we do not have a comparative framework in place, we are not able to eliminate alternative explanations of the apparent relationship between having a college degree and earning a high hourly wage. 3.6.1 A frame of reference It becomes clear that unless we look at hourly wages of both college and non-college graduates we are not able to say anything about the association between the two: it is the difference in the hourly wages between the two groups that provides evidence regarding the alleged effect of college education on hourly wages. But we can probably do better than comparing just the two groups. Perhaps, the type of education might portray our effect of interest more accurately. For instance, we could compare hourly wages across college graduates of economics, political science, law, life science and non-college graduates. Our research design will look as follows: \\(X\\) \\(Y\\) Economics Hourly wage Political science Hourly wage Law Hourly wage Life science Hourly wage Non-college Hourly wage We can take this further by looking at productivity growth for different college and non-college graduates. If we understand productivity growth as the rate at which productivity grows over time, or in our example the rate at which hourly wages increase over time, we could track the rate at which hourly wages increase for economics, political science, law, and life science college graduates and compare them with non-college graduates: \\(X\\) \\(Y_1\\) \\(Y_2\\) \\(Y_3\\) Economics Hourly wage Hourly wage Hourly wage Political science Hourly wage Hourly wage Hourly wage Law Hourly wage Hourly wage Hourly wage Life science Hourly wage Hourly wage Hourly wage Non-college Hourly wage Hourly wage Hourly wage Note that time might as well appear in our research design in a slightly different flavor. What if we look at how much the hourly wage of non-college graduates changed after attending college education? In other words, we can compare the hourly wages of the same individuals before and after attending college. At this point we need to introduce some additional terminology. Let us name the measurement of hourly wages before college education as pre-test, the measurement of hourly wages after college education as post-test and the act of attending college education as the intervention. Our research design will look as follows: Pre-test (\\(Y_1\\)) Intervention (\\(X\\)) Post-test (\\(Y_2\\)) Group of individuals Hourly wage College education Hourly wage Of course, we could do the same thing and also keeping track of the type of education. The research design will look as follows: Pre-test (\\(Y_1\\)) Intervention (\\(X\\)) Post-test (\\(Y_2\\)) Economics Hourly wage College education Hourly wage Political science Hourly wage College education Hourly wage Law Hourly wage College education Hourly wage Life science Hourly wage College education Hourly wage Non-college Hourly wage College education Hourly wage It is of course possible to expand on this and make even larger and more complicated research designs that will allow you to uncover a more detailed effect. Nevertheless, it will always be the case that you have to compare some groups with some other groups. This raises our next important question: under what conditions are comparisons meaningful? 3.7 Meaningful comparisons Making meaningful comparisons is central to any research design. We must ensure that any comparison allows us to estimate the true causal effect of the relationship that we are interested in. We already know the general condition that would allow for this: alternative explanations must be eliminated. Alternative explanations are grounded on confounders which are variables affecting both \\(X\\) and \\(Y\\) (Figure 3.9). In our example: a confounder could have both an impact on an individual’s choice to attend college education (or the type of college education) and on the hourly wage. Perhaps, intrinsic motivation for success in life is a driving force behind the decision to enroll in college and one’s performance in the labor market (thereby one’s hourly wage). What about family background? It is plausible that well educated parents can support their children financially and through networking opportunities, thereby affecting both enrollment in college education and compensation in the labor market. We will discuss two strategies for maximizing the comparability of groups below and they both rely on the same key principle: making sure confounders are not systematically different across groups. 3.7.1 Randomization The simplest and most effective way to ensure the comparability of the groups is to randomly allocate people to different groups. Random assignment of individuals to different groups means that differences with respect to individual background characteristics are random and not systematic. Therefore, if groups are large enough, they should be comparable on both known and unknown factors. For instance, in the binary classification of college and non-college education, random assignment would produce two groups with very similar intrinsic motivation, family background, innate ability and any other factor that might be related to our study. But… can we do such a thing in this particular example? Is random assignment to different educational groups possible? No, it is not! Education is a choice variable, thereby it almost by definition correlates with individual characteristics which are by themselves important in the labor market. In fact, it is precisely for this reason that it has proven to be notoriously difficult to estimate the true causal effect of education on hourly wages (Fuente 2011; Kampelmann et al. 2018). Economists have spent years developing advanced econometric techniques allowing them to overcome the fact that people are not randomly allocated in different educational groups. Before we discuss research design techniques for making meaningful comparisons when randomization is not possible, let us first look at an example where randomization is possible. Pharmaceutical companies need to test their products before administering them to the population. They also want to measure the effectiveness and side effects of various types of treatments. In this particular case it is easy, at least from a practical point of view, to randomly allocate people in various groups. The researcher is in full control and can actively manipulate the levels of the independent variable. For example, we could administer treatment A to group A, treatment B to group B and nothing to group C and random allocation will ensure that groups A, B and C are, on average, similar in terms of background characteristics that might have an impact on the effectiveness of the treatment. Therefore, through random allocation, we make sure that group differences in the dependent variable \\(Y\\) can be attributed to the treatment and not confounders. 3.7.2 Matching How can we meaningfully compare groups when allocation is a matter of individual choice? Through a procedure that by convention is called matching, researchers can deliberately match the characteristics of individuals in one group with those of individuals in another group. For example, we would like to compare hourly wages of college and non-college graduates with similar intrinsic motivation and family backgrounds, if we believe that these two factors are important determinants of hourly wages. Perhaps you can already see why this procedure is inferior to randomization. Even though we might be able to accurately operationalize family background through parents’ income and educational level, it is hard to measure intrinsic motivation. In addition, matching can only eliminate alternative explanations rooted in the confounders that are known to us, but it leaves the door open to confounders not known to us. 3.8 Taxonomy of research design The discussion so far has identified six core elements of research design. In fact, any research design, no matter how simple or complex, will always be some mix of these elements. So, let us summarize what we have seen so far by listing the six dimensions of research design: The number of groups in the design: designs vary from those with only 2 groups, to those with more. In principle, there is no upper limit to the number of groups a design might contain. However, one should not be willing to increase the level of complexity at the expense of interpretability: the simpler the design, the clearer the interpretation of the results. The number of pre-test measurement phases: designs vary from those with no pre-test (i.e. when measurements are obtained only once) to those with a series of pre-tests aiming to establish pre-existing differences between the groups that are being compared against each other. The number of post-tests measurements: designs need to have at least one post-test (i.e. when measurements are obtained only once) to those with a series of post-tests aiming to distinguish between short- and long-term effects. The method of allocation to groups: designs might employ randomization or matching. The nature of the intervention: in research design language, the terms intervention and independent variable refer to the same thing: the variable that is presumed to be causing changes in the outcome (dependent) variable11. Interventions can be either active or passive. A pharmaceutical company interested in the effectiveness of a newly developed drug employs an active intervention, since they can decide who gets what variation of treatment and randomly allocate people to different groups. A passive (or naturally occurring) intervention is when the researcher does not actively control the intervention. For example: the retirement of an individual when we want to study the effect of retirement on depression, or when a local government issues a new policy reform and we want to study its effect on employment rates. Finally, levels of the independent variable can also be (relatively) fixed attributes, such as eye color, country of origin or sex. The number of interventions: designs with an intervention can have either one or more interventions. Multiple interventions can be used to elicit the cumulative effect of various treatments. 3.9 Range of research design Now that we have summarized the six building blocks of research design, it is time to explore the combinations of the possibilities created by combining these building blocks. We will focus on three of the most fundamental types of research design: experimental, longitudinal and cross-sectional designs. They are the foundation of more elaborate and complex research designs. They also help us understand the importance and relevance of the six core principles identified before12. 3.9.1 Experimental designs The classic version of the experimental design satisfies the following: One pre-test measurement of the outcome variable. Two groups: one group is exposed to the intervention (usually called the experimental group) and one that is not exposed to the intervention (usually called the control group). E.g. the group receiving a new drug is the experimental group. Random allocation to groups before the pre-test: this implies that only active interventions can be tested through an experimental design. One intervention (test/treatment). One post-test measure of the outcome variable. The key feature of experimental research is that the researcher controls all aspects of the study, especially what participants experience during the study. In particular, the researcher manipulates or varies something (\\(X\\)), and then allows the outcome variable (\\(Y\\)) to vary naturally. The idea here is to deliberately vary the something in the world to see if it has any causal effects on the outcome. Moreover, in order to ensure that there’s no chance that something other than the manipulated variable is causing the outcome, everything else is kept constant or in some other way “balanced” to ensure no effect on the results. In practice, it’s almost impossible to think of everything that might have an influence on the outcome of an experiment, much less keep it constant. As we have seen already, the standard solution to this is randomization: that is, we randomly assign people to different groups, and then give each group a different treatment (i.e., assign them different values of the independent variables). Randomization minimizes, but does not eliminate, the possibility of systematic differences between treatment groups. Let’s consider a very simple, completely unrealistic and grossly unethical example. Suppose you wanted to find out if smoking causes lung cancer. One way to do this would be to find people who smoke and people who don’t smoke and look to see if smokers have a higher rate of lung cancer. This is not a proper experiment, since the researcher doesn’t have a lot of control over who is and isn’t a smoker. And this really matters: for instance, it might be that people who choose to smoke cigarettes also tend to have poor diets, or maybe they tend to work in asbestos mines, or whatever. The point here is that the groups (smokers and non-smokers) actually differ on lots of things, not just smoking. So, it might be that the higher incidence of lung cancer among smokers is caused by something else, not by smoking per se. In research design terms, these other things (e.g. diet) are confounders. In the meantime, let’s now consider what a proper experiment might look like. Recall that our concern was that smokers and non-smokers might differ in lots of ways. The solution, as long as you have no ethics, is to control who smokes and who doesn’t. Specifically, if we randomly divide participants into two groups, and force half of them to become smokers, it’s very unlikely that the groups will differ in any respect other than the fact that half of them smoke. That way, if our smoking group gets cancer at a higher rate than the non-smoking group, we can feel pretty confident that (a) smoking does cause cancer and (b) we’re murderers. Allocation Group Pre-test Intervention (\\(X\\)) Post-test Effect Random Experimental \\(Y\\text{e}_1\\) “Treatment” (smoking) \\(Y\\text{e}_2\\) E = \\(Y\\text{e}_2 - Y\\text{e}_1\\) Random Control \\(Y\\text{c}_1\\) “No treatment” (not smoking) \\(Y\\text{c}_2\\) C = \\(Y\\text{c}_2 - Y\\text{c}_1\\) T = E - C Data obtained from this experimental design can be analyzed by taking the difference between post-test and pre-test measure in both the experimental and control group. Then, we subtract the rate of change in the control group (C) from the rate of change in the experimental group (E) to calculate the total effect of the intervention (T). If the change in the experimental group is greater than the change in the control group the researcher can attribute this to the impact of the “treatment,” to the extent that randomization was successful and alternative explanations were successfully eliminated. 3.9.2 Longitudinal designs The most basic form of the longitudinal design looks as follows: One group One pre-test measurement of the outcome variable One intervention where everyone receives the treatment (hence one group only) One post-test measurement of the outcome variable (though normally you see more than one) Allocation Pre-test Intervention (\\(X\\)) Post-test Effect Random \\(Y\\text{pre}\\) “Treatment” \\(Y\\text{post}\\) \\(Y\\text{post} - Y\\text{pre}\\) This design is similar to the classic experimental design without a control group. Data obtained from such a design is analyzed by looking at the difference between post-test and pre-test measurements. The implicit assumption here is that any difference between \\(Y\\text{post}\\) and \\(Y\\text{pre}\\) is attributed to the treatment. However, the absence of a randomized control group makes it difficult to rule out the possibility that a similar difference would have been observed in the absence of a treatment. 3.9.3 Cross-sectional designs The most basic form of the cross-sectional design satisfies the following: There is no intervention, in the sense that variation in the independent variable relies on existing differences between groups. There is at least one independent variable with at least two categories The outcome variable is measured only once There is no random allocation to groups Allocation Group Pre-test Intervention (\\(X\\)) Post-test Effect Non-random Experimental none “Treatment” \\(Ye_{post}\\) E = \\(Ye_{post}\\) Non-random Control none “No treatment” \\(Yc_{post}\\) C = \\(Yc_{post}\\) T = E - C This research design resembles a classic experimental design without a pre-test, and individuals are not randomly allocated to groups. Data are collected at one point in time only and analyzed by measuring to what extent variation in the independent variable matches the variation in the outcome variable. The absence of random allocation poses certain limitations to our efforts to interpret this association as evidence of causality. To overcome this difficulty, researchers employ a technique called statistical controls whereby associations between \\(X\\) and \\(Y\\) are measured by keeping the values of some other relevant factor constant, eliminating it as a source of alternative explanations. Statistical controls, thus, work in a way similar to matching, but are implemented after data have been collected as long as we have access to the necessary information. The most common example of a cross-sectional design is data obtained through surveys where, for example, individual preferences on certain topics are measured at one point in time. There are many such databases publicly available on the internet and you can easily download the data they provide. The European Social Survey or the General Social Survey in the US are examples of cross-sectional designs. These surveys measure individual preferences on a wide range of sociopolitical values. So, one might be able to estimate the association between gender and political preferences. Since these surveys include questions on education, income and occupation the researcher is also able to statistically control for such factors in their efforts to get closer to the true causal effect of interest. 3.10 The validity of your study More than any other thing, a scientist wants their research to be “valid.” We explored validity before, when it referred to the validity of our measurement. Here, we discuss the validity of a study or experimental validity. The conceptual idea behind experimental validity is very simple: can you trust the results of your study? If not, the study is invalid. However, while it’s easy to state, in practice it’s much harder to check. And in all honesty, there’s no precise, clearly agreed upon notion of what experimental validity actually is. In fact, there’s lots of different kinds of validity, each of which raises it’s own issues, and not all forms of validity are relevant to all studies. I’m going to talk about three different types: Internal validity External validity Construct validity Internal and external validity are really important, since they tie directly to the fundamental question of whether your study really works. Construct validity asks whether you’re measuring what you think you are. 3.10.1 Internal validity Internal validity refers to the extent to which you are able draw the correct conclusions about the causal relationships between variables. It’s called “internal” because it refers to the relationships between things “inside” the study. Let’s illustrate the concept with a simple example. Suppose you’re interested in finding out whether a university education makes you write better. To do so, you get a group of first year students, ask them to write a 1000 word essay, and count the number of spelling and grammatical errors they make. Then you find some third-year students, who obviously have had more of a university education than the first-years, and repeat the exercise. And let’s suppose it turns out that the third-year students produce fewer errors. And so you conclude that a university education improves writing skills. Right? Except… the big problem that you have with this experiment is that the third-year students are older, and they’ve had more experience with writing things. So it’s hard to know for sure what the causal relationship is: do older people write better? Or people who have had more writing experience? Or people who have had more education? Which of the above is the true cause of the superior performance of the third-years? Age? Experience? Education? You can’t tell. This is an example of a failure of internal validity, because your study doesn’t properly tease apart the causal relationships between the different variables. 3.10.2 External validity External validity relates to the generalizability of your findings. That is, to what extent do you expect to see the same pattern of results in “real life” as you saw in your study. To put it a bit more precisely, any study that you do in psychology will involve a fairly specific set of questions or tasks, will occur in a specific environment, and will involve participants that are drawn from a particular subgroup. So, if it turns out that the results don’t actually generalize to people and situations beyond the ones that you studied, then what you’ve got is a lack of external validity. The classic example of this issue is the fact that a very large proportion of studies in psychology will use undergraduate psychology students as the participants. Obviously, however, the researchers don’t care only about psychology students; they care about people in general. Given that, a study that uses only psych students as participants always carries a risk of lacking external validity. That is, if there’s something “special” about psychology students that makes them different to the general populace in some relevant respect, then we may start worrying about a lack of external validity. That said, it is absolutely critical to realize that a study that uses only psychology students does not necessarily have a problem with external validity. I’ll talk about this again later, but it’s such a common mistake that I’m going to mention it here. The external validity is threatened by the choice of population if (a) the population from which you sample your participants is very narrow (e.g., psych students), and (b) the narrow population that you sampled from is systematically different from the general population, in some respect that is relevant to the psychological phenomenon that you intend to study. The italicized part is the bit that lots of people forget: it is true that psychology undergraduates differ from the general population in lots of ways, and so a study that uses only psych students may have problems with external validity. However, if those differences aren’t very relevant to the phenomenon that you’re studying, then there’s nothing to worry about. To make this a bit more concrete, here’s two extreme examples: You want to measure “attitudes of the general public towards psychotherapy,” but all of your participants are psychology students. This study would almost certainly have a problem with external validity. You want to measure the effectiveness of a visual illusion, and your participants are all psychology students. This study is very unlikely to have a problem with external validity. Having just spent the last couple of paragraphs focusing on the choice of participants (since that’s the big issue that everyone tends to worry most about), it’s worth remembering that external validity is a broader concept. The following are also examples of things that might pose a threat to external validity, depending on what kind of study you’re doing: People might answer a “psychology questionnaire” in a manner that doesn’t reflect what they would do in real life. Your lab experiment on (say) “human learning” has a different structure to the learning problems people face in real life. 3.10.3 Construct validity Construct validity is basically a question of whether you’re measuring what you want to be measuring. A measurement has good construct validity if it is actually measuring the correct theoretical construct, and bad construct validity if it doesn’t. To give very simple (if ridiculous) example, suppose I’m trying to investigate the rates with which university students cheat on their exams. And the way I attempt to measure it is by asking the cheating students to stand up in the lecture theatre so that I can count them. When I do this with a class of 300 students, 0 people claim to be cheaters. So I therefore conclude that the proportion of cheaters in my class is 0%. Clearly this is a bit ridiculous. But the point here is not that this is a very deep methodological example, but rather to explain what construct validity is. The problem with my measure is that while I’m trying to measure “the proportion of people who cheat” what I’m actually measuring is “the proportion of people stupid enough to own up to cheating, or bloody minded enough to pretend that they do.” Obviously, these aren’t the same thing! So my study has gone wrong, because my measurement has very poor construct validity. 3.11 Threats to experimental validity If we look at the issue of validity in the most general fashion, the two biggest worries that we have are confounds and artifacts. We have already discussed confounds but let us summarize what we have seen by examining their relationship with artifacts. These two terms are defined in the following way: Confound: A confound is an additional, often unmeasured variable that turns out to be related to both the predictors and the outcomes. The existence of confounds threatens the internal validity of the study because you can’t tell whether the predictor causes the outcome, or if the confounding variable causes it, etc. Artifact: A result is said to be “artifactual” if it only holds in the special situation that you happened to test in your study. The possibility that your result is an artifact describes a threat to your external validity, because it raises the possibility that you can’t generalize your results to the actual population that you care about. As a general rule confounds are a bigger concern for non-experimental studies, precisely because they’re not proper experiments: by definition, you’re leaving lots of things uncontrolled, so there’s a lot of scope for confounds working their way into your study. Experimental research tends to be much less vulnerable to confounds: the more control you have over what happens during the study, the more you can prevent confounds from appearing. However, there’s always swings and roundabouts, and when we start thinking about artifacts rather than confounds, the shoe is very firmly on the other foot. For the most part, artifactual results tend to be a concern for experimental studies than for non-experimental studies. To see this, it helps to realize that the reason that a lot of studies are non-experimental is precisely because what the researcher is trying to do is examine human behaviour in a more naturalistic context. By working in a more real-world context, you lose experimental control (making yourself vulnerable to confounds) but because you tend to be studying human psychology “in the wild” you reduce the chances of getting an artifactual result. Or, to put it another way, when you take psychology out of the wild and bring it into the lab (which we usually have to do to gain our experimental control), you always run the risk of accidentally studying something different than you wanted to study: which is more or less the definition of an artifact. So, normally there is a tradeoff between internal and external validity: maximizing one comes at the expense of the other. Be warned though: the above is a rough guide only. It’s absolutely possible to have confounds in an experiment, and to get artifactual results with non-experimental studies. This can happen for all sorts of reasons, not least of which is researcher error. In practice, it’s really hard to think everything through ahead of time, and even very good researchers make mistakes. But other times it’s unavoidable, simply because the researcher has ethics (e.g., see differential attrition below). Okay. There’s a sense in which almost any threat to validity can be characterized as a confound or an artifact: they’re pretty vague concepts. So let’s have a look at some of the most common examples… 3.11.1 History effects History effects refer to the possibility that specific events may occur during the study itself that might influence the outcomes. For instance, something might happen in between a pre-test and a post-test. Or, in between testing participant 23 and participant 24. Alternatively, it might be that you’re looking at an older study, which was perfectly valid for its time, but the world has changed enough since then that the conclusions are no longer trustworthy. Examples of things that would count as history effects: You’re interested in how people think about risk and uncertainty. You started your data collection in December 2010. But finding participants and collecting data takes time, so you’re still finding new people in February 2011. Unfortunately for you (and even more unfortunately for others), the Queensland (Australia) floods occurred in January 2011, causing billions of dollars of damage and killing many people. Not surprisingly, the people tested in February 2011 express quite different beliefs about handling risk than the people tested in December 2010. Which (if any) of these reflects the “true” beliefs of participants? I think the answer is probably both: the Queensland floods genuinely changed the beliefs of the Australian public, though possibly only temporarily. The key thing here is that the “history” of the people tested in February is quite different to people tested in December. You’re testing the psychological effects of a new anti-anxiety drug. So what you do is measure anxiety before administering the drug (e.g., by self-report, and taking physiological measures, let’s say), then you administer the drug, and then you take the same measures afterwards. In the middle, however, because your labs are in Los Angeles, there’s an earthquake, which increases the anxiety of the participants. 3.11.2 Maturation effects As with history effects, maturational effects are fundamentally about change over time. However, maturation effects aren’t in response to specific events. Rather, they relate to how people change on their own over time: we get older, we get tired, we get bored, etc. Some examples of maturation effects: When doing developmental psychology research, you need to be aware that children grow up quite rapidly. So, suppose that you want to find out whether some educational trick helps with vocabulary size among 3 year olds. One thing that you need to be aware of is that the vocabulary size of children that age is growing at an incredible rate (multiple words per day), all on its own. If you design your study without taking this maturational effect into account, then you won’t be able to tell if your educational trick works. When running a very long experiment in the lab (say, something that goes for 3 hours), it’s very likely that people will begin to get bored and tired, and that this maturational effect will cause performance to decline, regardless of anything else going on in the experiment. 3.11.3 Repeated testing effects An important type of history effect is the effect of repeated testing. Suppose I want to take two measurements of some psychological construct (e.g., anxiety). One thing I might be worried about is if the first measurement has an effect on the second measurement. In other words, this is a history effect in which the “event” that influences the second measurement is the first measurement itself! This is not at all uncommon. Examples of this include: Learning and practice: e.g., “intelligence” at time 2 might appear to go up relative to time 1 because participants learned the general rules of how to solve “intelligence-test-style” questions during the first testing session. Familiarity with the testing situation: e.g., if people are nervous at time 1, this might make performance go down; after sitting through the first testing situation, they might calm down a lot precisely because they’ve seen what the testing looks like. Auxiliary changes caused by testing: e.g., if a questionnaire assessing mood is boring, then mood at measurement at time 2 is more likely to become “bored,” precisely because of the boring measurement made at time 1. 3.11.4 Selection bias Selection bias is a pretty broad term. Suppose that you’re running an experiment with two groups of participants, where each group gets a different “treatment,” and you want to see if the different treatments lead to different outcomes. However, suppose that, despite your best efforts, you’ve ended up with a gender imbalance across groups (say, group A has 80% females and group B has 50% females). It might sound like this could never happen, but trust me, it can. This is an example of a selection bias, in which the people “selected into” the two groups have different characteristics. If any of those characteristics turns out to be relevant (say, your treatment works better on females than males) then you’re in a lot of trouble. Another good example of selection bias is the one we discussed earlier on education and hourly wages. Education is a choice variable since people allocate themselves in different educational groups: the alternative explanation originates to the extent to which factors driving people’s educational choices correlate with their competitiveness in the labor market. 3.11.5 Differential attrition One quite subtle danger to be aware of is called differential attrition, which is a kind of selection bias that is caused by the study itself. Suppose that, for the first time ever in the history of psychology, I manage to find the perfectly balanced and representative sample of people. I start running “Thomas’s incredibly long and tedious experiment” on my perfect sample, but then, because my study is incredibly long and tedious, lots of people start dropping out. I can’t stop this: participants absolutely have the right to stop doing any experiment, any time, for whatever reason they feel like, and as researchers we are morally (and professionally) obliged to remind people that they do have this right. So, suppose that “Thomas’s incredibly long and tedious experiment” has a very high drop out rate. What do you suppose the odds are that this drop out is random? Answer: zero. Almost certainly, the people who remain are more conscientious, more tolerant of boredom etc than those that leave. To the extent that (say) conscientiousness is relevant to the psychological phenomenon that I care about, this attrition can decrease the validity of my results. When thinking about the effects of differential attrition, it is sometimes helpful to distinguish between two different types. The first is homogeneous attrition, in which the attrition effect is the same for all groups, treatments or conditions. In the example I gave above, the differential attrition would be homogeneous if (and only if) the easily bored participants are dropping out of all of the conditions in my experiment at about the same rate. In general, the main effect of homogeneous attrition is likely to be that it makes your sample unrepresentative. As such, the biggest worry that you’ll have is that the generalisability of the results decreases: in other words, you lose external validity. The second type of differential attrition is heterogeneous attrition, in which the attrition effect is different for different groups. This is a much bigger problem: not only do you have to worry about your external validity, you also have to worry about your internal validity too. To see why this is the case, let’s consider a very dumb study in which I want to see if insulting people makes them act in a more obedient way. Why anyone would actually want to study that I don’t know, but let’s suppose I really, deeply cared about this. So, I design my experiment with two conditions. In the “treatment” condition, the experimenter insults the participant and then gives them a questionnaire designed to measure obedience. In the “control” condition, the experimenter engages in a bit of pointless chitchat and then gives them the questionnaire. Leaving aside the questionable scientific merits and dubious ethics of such a study, let’s have a think about what might go wrong here. As a general rule, when someone insults me to my face, I tend to get much less co-operative. So, there’s a pretty good chance that a lot more people are going to drop out of the treatment condition than the control condition. And this drop out isn’t going to be random. The people most likely to drop out would probably be the people who don’t care all that much about the importance of obediently sitting through the experiment. Since the most bloody minded and disobedient people all left the treatment group but not the control group, we’ve introduced a confound: the people who actually took the questionnaire in the treatment group were already more likely to be dutiful and obedient than the people in the control group. In short, in this study insulting people doesn’t make them more obedient: it makes the more disobedient people leave the experiment! The internal validity of this experiment is completely shot. 3.11.6 Non-response bias Non-response bias is closely related to selection bias and to differential attrition. The simplest version of the problem goes like this. You mail out a survey to 1000 people, and only 300 of them reply. The 300 people who replied are almost certainly not a random subsample. People who respond to surveys are systematically different to people who don’t. This introduces a problem when trying to generalize from those 300 people who replied, to the population at large; since you now have a very non-random sample. The issue of non-response bias is more general than this, though. Among the (say) 300 people that did respond to the survey, you might find that not everyone answers every question. If (say) 80 people chose not to answer one of your questions, does this introduce problems? As always, the answer is maybe. If the question that wasn’t answered was on the last page of the questionnaire, and those 80 surveys were returned with the last page missing, there’s a good chance that the missing data isn’t a big deal: probably the pages just fell off. However, if the question that 80 people didn’t answer was the most confrontational or invasive personal question in the questionnaire, then almost certainly you’ve got a problem. In essence, what you’re dealing with here is what’s called the problem of missing data. If the data that is missing was “lost” randomly, then it’s not a big problem. If it’s missing systematically, then it can be a big problem. 3.11.7 Regression to the mean Regression to the mean is a curious variation on selection bias. It refers to any situation where you select data based on an extreme value on some measure. Because the measure has natural variation, it almost certainly means that when you take a subsequent measurement, that later measurement will be less extreme than the first one, purely by chance. Here’s an example. Suppose I’m interested in whether a psychology education has an adverse effect on very smart kids. To do this, I find the 20 psych I students with the best high school grades and look at how well they’re doing at university. It turns out that they’re doing a lot better than average, but they’re not topping the class at university, even though they did top their classes at high school. What’s going on? The natural first thought is that this must mean that the psychology classes must be having an adverse effect on those students. However, while that might very well be the explanation, it’s more likely that what you’re seeing is an example of “regression to the mean.” To see how it works, let’s take a moment to think about what is required to get the best mark in a class, regardless of whether that class be at high school or at university. When you’ve got a big class, there are going to be lots of very smart people enrolled. To get the best mark you have to be very smart, work very hard, and be a bit lucky. The exam has to ask just the right questions for your idiosyncratic skills, and you have to not make any dumb mistakes (we all do that sometimes) when answering them. And that’s the thing: intelligence and hard work are transferrable from one class to the next. Luck isn’t. The people who got lucky in high school won’t be the same as the people who get lucky at university. That’s the very definition of “luck.” The consequence of this is that, when you select people at the very extreme values of one measurement (the top 20 students), you’re selecting for hard work, skill and luck. But because the luck doesn’t transfer to the second measurement (only the skill and work), these people will all be expected to drop a little bit when you measure them a second time (at university). So their scores fall back a little bit, back towards everyone else. This is regression to the mean. Regression to the mean is surprisingly common. For instance, if two very tall people have kids, their children will tend to be taller than average, but not as tall as the parents. The reverse happens with very short parents: two very short parents will tend to have short children, but nevertheless those kids will tend to be taller than the parents. It can also be extremely subtle. For instance, there have been studies done that suggested that people learn better from negative feedback than from positive feedback. However, the way that people tried to show this was to give people positive reinforcement whenever they did good, and negative reinforcement when they did bad. And what you see is that after the positive reinforcement, people tended to do worse; but after the negative reinforcement they tended to do better. But! Notice that there’s a selection bias here: when people do very well, you’re selecting for “high” values, and so you should expect (because of regression to the mean) that performance on the next trial should be worse, regardless of whether reinforcement is given. Similarly, after a bad trial, people will tend to improve all on their own. The apparent superiority of negative feedback is an artifact caused by regression to the mean (Kahneman and Tversky 1973). 3.11.8 Experimenter bias Experimenter bias can come in multiple forms. The basic idea is that the experimenter, despite the best of intentions, can accidentally end up influencing the results of the experiment by subtly communicating the “right answer” or the “desired behaviour” to the participants. Typically, this occurs because the experimenter has special knowledge that the participant does not – either the right answer to the questions being asked, or knowledge of the expected pattern of performance for the condition that the participant is in, and so on. The classic example of this happening is the case study of “Clever Hans,” which dates back to 1907 (Pfungst 1911; Hothersall 2004). Clever Hans was a horse that apparently was able to read and count, and perform other human like feats of intelligence. After Clever Hans became famous, psychologists started examining his behaviour more closely. It turned out that – not surprisingly – Hans didn’t know how to do maths. Rather, Hans was responding to the human observers around him. Because they did know how to count, and the horse had learned to change its behaviour when people changed theirs. The general solution to the problem of experimenter bias is to engage in double blind studies, where neither the experimenter nor the participant knows which condition the participant is in, or knows what the desired behaviour is. This provides a very good solution to the problem, but it’s important to recognize that it’s not quite ideal, and hard to pull off perfectly. For instance, the obvious way that I could try to construct a double blind study is to have one of my Ph.D. students (one who doesn’t know anything about the experiment) run the study. That feels like it should be enough. The only person (me) who knows all the details (e.g., correct answers to the questions, assignments of participants to conditions) has no interaction with the participants, and the person who does all the talking to people (the Ph.D. student) doesn’t know anything. Except, that last part is very unlikely to be true. In order for the Ph.D. student to run the study effectively, they need to have been briefed by me, the researcher. And, as it happens, the Ph.D. student also knows me, and knows a bit about my general beliefs about people and psychology (e.g., I tend to think humans are much smarter than psychologists give them credit for). As a result of all this, it’s almost impossible for the experimenter to avoid knowing a little bit about what expectations I have. And even a little bit of knowledge can have an effect: suppose the experimenter accidentally conveys the fact that the participants are expected to do well in this task. Well, there’s a thing called the “Pygmalion effect”: if you expect great things of people, they’ll rise to the occasion; but if you expect them to fail, they’ll do that too. In other words, the expectations become a self-fulfilling prophecy. 3.11.9 Demand effects and reactivity When talking about experimenter bias, the worry is that the experimenter’s knowledge or desires for the experiment are communicated to the participants, and that these affect people’s behaviour (Rosenthal 1966). However, even if you manage to stop this from happening, it’s almost impossible to stop people from knowing that they’re part of a psychological study. And the mere fact of knowing that someone is watching/studying you can have a pretty big effect on behaviour. This is generally referred to as reactivity or demand effects. The basic idea is captured by the Hawthorne effect: people alter their performance because of the attention that the study focuses on them. The effect takes its name from a the “Hawthorne Works” factory outside of Chicago (Adair 1984). A study done in the 1920s looking at the effects of lighting on worker productivity at the factory turned out to be an effect of the fact that the workers knew they were being studied, rather than the lighting. To get a bit more specific about some of the ways in which the mere fact of being in a study can change how people behave, it helps to think like a social psychologist and look at some of the roles that people might adopt during an experiment, but might not adopt if the corresponding events were occurring in the real world: The good participant tries to be too helpful to the researcher: he or she seeks to figure out the experimenter’s hypotheses and confirm them. The negative participant does the exact opposite of the good participant: he or she seeks to break or destroy the study or the hypothesis in some way. The faithful participant is unnaturally obedient: he or she seeks to follow instructions perfectly, regardless of what might have happened in a more realistic setting. The apprehensive participant gets nervous about being tested or studied, so much so that his or her behaviour becomes highly unnatural, or overly socially desirable. 3.11.10 Placebo effects The placebo effect is a specific type of demand effect that we worry a lot about. It refers to the situation where the mere fact of being treated causes an improvement in outcomes. The classic example comes from clinical trials: if you give people a completely chemically inert drug and tell them that it’s a cure for a disease, they will tend to get better faster than people who aren’t treated at all. In other words, it is people’s belief that they are being treated that causes the improved outcomes, not the drug. 3.12 That’s it for this week Whew. That’s it for the readings of the third week. It is perfectly normal if you feel that all this information is overwhelming and perhaps to some extent redundant. However, discussing all these threats allows us to explore different flavors of the same key principles, hoping that the examples of different manifestations will make it easier for you to identify various threats in yours’ or others’ studies. Practice materials for this week can be found on SOWISO. The practice materials are not mandatory, but give you the opportunity to refine your critical skills by reading some mini case-studies and trying to identify, if any, relevant threats to internal validity. Original chapter by Matthew Crump. Extended with our own materials about causation. Materials about validity from Chapter 2 of Learning Statistics with R by Danielle Navarro.↩︎ We are wading into the idea that measures of two things can be related, or correlated with one another. It is possible for the relationships to be more complicated than just going up, or going down. For example, we could have a relationship that where the dots go up for the first half of X, and then go down for the second half.↩︎ The stories about the invention of various statistics are very interesting, you can read more about them in the book, “The Lady Tasting Tea” (Salsburg 2001)↩︎ Brief explanation here is that dividing each measure by its standard deviation ensures that the values in each measure are in the same range as one another.↩︎ The term intervention is often used to refer to categorical independent variables.↩︎ During the next ACC skills course (the basestone project) we will explore these designs in more detail.↩︎ "],["chance.html", " 4 Week 4: Chance and Probability Theory13 4.1 Correlation and random chance 4.2 How are probability and statistics different? 4.3 What does probability mean? 4.4 Basic probability theory 4.5 Probability distributions 4.6 z-scores 4.7 That’s it for this week", " 4 Week 4: Chance and Probability Theory13 I have studied many languages-French, Spanish and a little Italian, but no one told me that statistics was a foreign language. —Charmaine J. Forde Up to this point in the book, we’ve discussed some of the key ideas in research design, and we’ve talked a little about how you can summarize a data set. To a lot of people, this is all there is to statistics: it’s about calculating averages, collecting all the numbers, drawing graphs, and putting them all in a report somewhere. Kind of like stamp collecting, but with numbers. However, statistics covers much more than that. In fact, descriptive statistics is only a small part of statistics. Another, very useful, part of statistics is that it provides tools that let you make inferences about data. Once you start thinking about statistics in these terms – that statistics is there to help us draw inferences from data – you start seeing examples of it everywhere. For instance, here’s a tiny extract from a newspaper article in the Sydney Morning Herald (30 Oct 2010): “I have a tough job” the Premier said in response to a poll which found her government is now the most unpopular Labor administration in polling history, with a primary vote of just 23 per cent. This kind of remark is entirely unremarkable in the papers or in everyday life, but let’s have a think about what it entails. A polling company has conducted a survey, usually a pretty big one because they can afford it. I’m too lazy to track down the original survey, so let’s just imagine that they called 1000 voters at random, and 230 (23%) of those claimed that they intended to vote for the party. For the 2010 Federal election, the Australian Electoral Commission reported 4,610,795 enrolled voters in New South Whales; so the opinions of the remaining 4,609,795 voters (about 99.98% of voters) remain unknown to us. Even assuming that no-one lied to the polling company the only thing we can say with confidence is that the true primary vote is somewhere between 230/4610795 (about 0.005%) and 4610025/4610795 (about 99.83%). So, on what basis is it legitimate for the polling company, the newspaper, and the readership to conclude that the Australian Labor Party (ALP) primary vote is about 23%? The answer to the question is pretty obvious: if I call 1000 people at random, and 230 of them say they intend to vote for the ALP, then it seems very unlikely that these are the only 230 people out of the entire voting public who actually intend to do so. In other words, we assume that the data collected by the polling company is representative of the population at large. But how representative? Would we be surprised to discover that the true ALP primary vote is actually 24%? 29%? 37%? At this point everyday intuition starts to break down a bit. No-one would be surprised by 24%, and everybody would be surprised by 37%, but it’s a bit hard to say whether 29% is plausible. We need some more powerful tools than just looking at the numbers and guessing. Inferential statistics provide the tools that we need to answer these sorts of questions and will be the topic of the remainder of this course. This week, we start with our journey into inferential statistics by looking at how correlations are affected by random chance to build some intuitions about inference. Then, we will look more formally at an important building block of inferential statistics: probability theory. Next week will focus on another building block of inferential statistics: estimation and sampling theory. 4.1 Correlation and random chance Last week, we discussed several ways in which correlation did not mean causation. For example, we looked at causation without correlation and the third variable problem. However, there is another important important aspect of correlations and that is the fact that they can be produced by random chance. This means that you can find a positive or negative correlation between two measures, when they have absolutely nothing to do with one another. You might have hoped to find zero correlation when two measures are totally unrelated to each other. Although this certainly happens, unrelated measures can produce spurious correlations, just by chance alone. Let’s demonstrate how correlations can occur by chance when there is no causal connection between two measures. Imagine two participants. One is at the North pole with a lottery machine full of balls with numbers from 1 to 10. The other is at the South pole with a different lottery machine full of balls with numbers from 1 to 10. There are an endless supply of balls in the machine, so every number could be picked for any ball. Each participant randomly chooses 10 balls, then records the number on the ball. In this situation we will assume that there is no possible way that balls chosen by the first participant could causally influence the balls chosen by the second participant. They are on the other side of the world. Here is what the numbers on each ball could look like for each participant: ball north_pole south_pole 1 2 4 2 3 3 3 8 8 4 9 8 5 8 6 6 4 7 7 2 9 8 4 5 9 3 7 10 4 4 In this one case, if we computed Pearson’s \\(r\\), we would find that \\(r =\\) 0.36. But, we already know that this value does not tell us anything about the relationship between the balls chosen on the North and South pole. We know that the relationship is completely random, because that is how we set up the game. The better question here is to ask what can random chance do? For example, if we ran our game over and over again thousands of times, each time choosing new balls, and each time computing the correlation, what would we find? The \\(r\\) value will sometimes be positive, sometimes be negative, sometimes be big and sometimes be small. Let’s look at what this random fluctuations would look like. This will give us a window into the kinds of correlations that chance alone can produce. 4.1.1 Monte-carlo simulation of random correlations It is possible to use a computer to simulate our game as many times as we want. This process is termed a monte-carlo simulation, after the code name for the procedure developped during the Manhattan project. Below is a script written for R14. We won’t go into the details of the code here, you will do more of this during the labs, but let’s briefly explain what is going on. Notice, the part that says for(sim in 1:1000). This creates a loop that repeats our game 1000 times. Inside the loop there are variables named north_pole and south_pole. During each simulation, we sample 10 random numbers (between 1 to 10) using runif(10,1,10) into each variable. These random numbers stand for the numbers that would have been on the balls from the lottery machine. Once we have 10 random numbers for each, we compute the correlation using cor(north_pole,south_pole). Then, we save the correlation value and move on to the next simulation. At the end, we will have 1000 individual Pearson \\(r\\) values. library(ggplot2) simulated_correlations &lt;- c() # create empty vector set.seed(123) for(sim in 1:1000){ # pick 10 random numbers between 1 and 10 and round the result to the nearest integer north_pole &lt;- round(runif(10,1,10)) south_pole &lt;- round(runif(10,1,10)) # save each calculated correlation in the vector simulated_correlations[sim] &lt;- cor(north_pole,south_pole) } # Generate a scatterplot with the simulated correlations sim_df &lt;- data.frame(sims=1:1000,simulated_correlations) ggplot(sim_df, aes(x = sims, y = simulated_correlations))+ geom_point()+ theme_classic()+ geom_hline(yintercept = -1, color=&quot;red&quot;, linetype = 2)+ geom_hline(yintercept = 1, color=&quot;red&quot;, linetype = 2)+ ggtitle(&quot;Simulation of 1000 r values&quot;) Figure 4.1: Figure showing a range of r-values that can be obtained by chance Each dot in the scatter plot shows the Pearson \\(r\\) for each simulation from 1 to 1000. As you can see the dots are all over of the place, in between the range -1 to 1. The important lesson here is that random chance produced all of these correlations. This means we can find “correlations” in the data that are completely meaningless, and do not reflect any causal relationship between one measure and another. Let’s illustrate the idea of finding “random” correlations one more time, with an animation. This time, we will show you a scatter plot of the random values sampled for the balls chosen from the North and South pole. If there is no relationship we should see dots going everywhere. If there happens to be a positive relationship (purely by chance), we should see the dots going from the bottom left to the top right. If there happens to be a negative relationship (purely by chance), we should see the dots going from the top left down to the bottom right. On more thing to prepare you for the animation. There are three scatter plots below, showing negative, positive, and zero correlations between two variables. You’ve already seen these types of graphs before. We are just reminding you that the blue lines are helpful for seeing the correlation. Negative correlations occur when a line goes down from the top left to bottom right. Positive correlations occur when a line goes up from the bottom left to the top right. Zero correlations occur when the line is flat (doesn’t go up or down). Figure 4.2: A reminder of what positive, negative, and zero correlation looks like OK, now we are ready for the animation. You are looking at the process of sampling two sets of numbers randomly, one for the X variable (north_pole), and one for the Y variable (south_pole). Each time we sample 10 numbers for each, plot them, then draw a line through them. Remember, these numbers are all completely random, so we should expect, on average that there should be no correlation between the numbers. However, this is not what happens. You can the line going all over the place. Sometimes we find a negative correlation (line goes down), sometimes we see a positive correlation (line goes up), and sometimes it looks like zero correlation (line is more flat). Figure 4.3: Completely random data points drawn from a uniform distribution with a small sample-size of 10. The blue line twirls around sometimes showing large correlations that are produced by chance You might be thinking this is kind of disturbing. If we know that there should be no correlation between two random variables, how come we are finding correlations? This is a big problem right? I mean, if someone showed me a correlation between two things, and then claimed one thing was related to another, how could know I if it was true? After all, it could be chance! Fortunately, all is not lost. We can look at our simulated data in another way, using a histogram. Remember, just before the animation, we simulated 1000 different correlations using random numbers. By, putting all of those \\(r\\) values into a histogram, we can get a better sense of how chance behaves. We can see what kind of correlations chance is likely or unlikely to produce. Here is a histogram of the simulated \\(r\\) values. Figure 4.4: A histogram showing the frequency distribution of r-values for completely random values between an X and Y variable (sample-size=10). A full range of r-values can be obtained by chance alone. Larger r-values are less common than smaller r-values Notice that this histogram is not flat. Most of the simulated \\(r\\) values are close to zero. Notice, also that the bars get smaller as you move away from zero in the positive or negative direction. The general take home here is that chance can produce a wide range of correlations. However, not all correlations happen very often. For example, the bars for -1 and 1 are very small. Chance does not produce nearly perfect correlations very often. The bars around -.5 and .5 are smaller than the bars around zero, as medium correlations do not occur as often as small correlations by chance alone. You can think of this histogram as the window of chance. It shows what chance often does, and what it often does not do. If you found a correlation under these very same circumstances (e.g., measured the correlation between two sets of 10 random numbers), then you could consult this window. What should you ask the window? How about, could my observed correlation (the one that you found in your data) have come from this window? Let’s say you found a correlation of \\(r = .1\\). Could a .1 have come from the histogram? Well, look at the histogram around where the .1 mark on the x-axis is. Is there a big bar there? If so, this means that chance produces this value fairly often. You might be comfortable with the inference: Yes, this .1 could have been produced by chance, because it is well inside the window of chance. How about \\(r = .5\\)? The bar is much smaller here, you might think, “well, I can see that chance does produce .5 some times, so chance could have produced my .5. Did it? Maybe, maybe not, not sure.” Here, your confidence in a strong inference about the role of chance might start getting a bit shakier. How about an \\(r = .95\\)?. You might see that the bar for .95 is very very small, perhaps too small to see. What does this tell you? It tells you that chance does not produce .95 very often, hardly if at all, pretty much never. So, if you found a .95 in your data, what would you infer? Perhaps you would be comfortable inferring that chance did not produce your .95, after all, .95 is mostly outside the window of chance. 4.1.2 Increasing sample-size decreases the opportunity for spurious correlations Before moving on, let’s do one more thing with correlations. In our pretend lottery game, each participant only sampled 10 balls each. We found that this could lead to a range of correlations between the numbers randomly drawn from either sides of the pole. Indeed, we even found some correlations that were medium to large in size. If you were a researcher who found such correlations, you might be tempted to believe there was a relationship between your measurements. However, we know in our little game, that those correlations would be spurious, just a product of random sampling15. The good news is that, as a researcher, you get to make the rules of the game. You get to determine how chance can play. This is all still a little bit metaphorical, so let’s make it concrete. Let’s see what happens in four different scenarios. First, we will repeat what we already did. Each participant will draw 10 balls, then we compute the correlation, and do this over 1000 times and look at a histogram. Second, we will change the game so each participant draws 50 balls each, and then repeat our simulation. Third, and fourth, we will change the game so each participant draws 100 balls each, and then 1000 balls each, and repeat etc. The graph below shows four different histograms of the Pearson \\(r\\) values in each of the different scenarios. Each scenario involves a different sample-size, from, 10, 50, 100 to 1000. Figure 4.5: Four histograms showing the frequency distributions of r-values between completely random X and Y variables as a function of sample-size. The width of the distributions shrink as sample-size increases. Smaller sample-sizes are more likely to produce a wider range of r-values by chance. Larger sample-sizes always produce a narrower range of small r-values ## List of 93 ## $ line :List of 6 ## ..$ colour : chr &quot;black&quot; ## ..$ size : num 0.5 ## ..$ linetype : num 1 ## ..$ lineend : chr &quot;butt&quot; ## ..$ arrow : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; ## $ rect :List of 5 ## ..$ fill : chr &quot;white&quot; ## ..$ colour : chr &quot;black&quot; ## ..$ size : num 0.5 ## ..$ linetype : num 1 ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; ## $ text :List of 11 ## ..$ family : chr &quot;&quot; ## ..$ face : chr &quot;plain&quot; ## ..$ colour : chr &quot;black&quot; ## ..$ size : num 11 ## ..$ hjust : num 0.5 ## ..$ vjust : num 0.5 ## ..$ angle : num 0 ## ..$ lineheight : num 0.9 ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ title : NULL ## $ aspect.ratio : NULL ## $ axis.title : NULL ## $ axis.title.x :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 1 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 2.75points 0points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.title.x.top :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 0 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 2.75points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.title.x.bottom : NULL ## $ axis.title.y :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 1 ## ..$ angle : num 90 ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 2.75points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.title.y.left : NULL ## $ axis.title.y.right :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 0 ## ..$ angle : num -90 ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 0points 2.75points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : chr &quot;grey30&quot; ## ..$ size : &#39;rel&#39; num 0.8 ## ..$ hjust : NULL ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.x :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 1 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 2.2points 0points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.x.top :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : num 0 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 2.2points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.x.bottom : NULL ## $ axis.text.y :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 1 ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 2.2points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.text.y.left : NULL ## $ axis.text.y.right :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 0 ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 0points 2.2points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ axis.ticks :List of 6 ## ..$ colour : chr &quot;grey20&quot; ## ..$ size : NULL ## ..$ linetype : NULL ## ..$ lineend : NULL ## ..$ arrow : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; ## $ axis.ticks.x : NULL ## $ axis.ticks.x.top : NULL ## $ axis.ticks.x.bottom : NULL ## $ axis.ticks.y : NULL ## $ axis.ticks.y.left : NULL ## $ axis.ticks.y.right : NULL ## $ axis.ticks.length : &#39;simpleUnit&#39; num 2.75points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ axis.ticks.length.x : NULL ## $ axis.ticks.length.x.top : NULL ## $ axis.ticks.length.x.bottom: NULL ## $ axis.ticks.length.y : NULL ## $ axis.ticks.length.y.left : NULL ## $ axis.ticks.length.y.right : NULL ## $ axis.line :List of 6 ## ..$ colour : chr &quot;black&quot; ## ..$ size : &#39;rel&#39; num 1 ## ..$ linetype : NULL ## ..$ lineend : NULL ## ..$ arrow : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; ## $ axis.line.x : NULL ## $ axis.line.x.top : NULL ## $ axis.line.x.bottom : NULL ## $ axis.line.y : NULL ## $ axis.line.y.left : NULL ## $ axis.line.y.right : NULL ## $ legend.background :List of 5 ## ..$ fill : NULL ## ..$ colour : logi NA ## ..$ size : NULL ## ..$ linetype : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; ## $ legend.margin : &#39;margin&#39; num [1:4] 5.5points 5.5points 5.5points 5.5points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ legend.spacing : &#39;simpleUnit&#39; num 11points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ legend.spacing.x : NULL ## $ legend.spacing.y : NULL ## $ legend.key : list() ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_blank&quot; &quot;element&quot; ## $ legend.key.size : &#39;simpleUnit&#39; num 1.2lines ## ..- attr(*, &quot;unit&quot;)= int 3 ## $ legend.key.height : NULL ## $ legend.key.width : NULL ## $ legend.text :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : &#39;rel&#39; num 0.8 ## ..$ hjust : NULL ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ legend.text.align : NULL ## $ legend.title :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 0 ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ legend.title.align : NULL ## $ legend.position : chr &quot;right&quot; ## $ legend.direction : NULL ## $ legend.justification : chr &quot;center&quot; ## $ legend.box : NULL ## $ legend.box.just : NULL ## $ legend.box.margin : &#39;margin&#39; num [1:4] 0cm 0cm 0cm 0cm ## ..- attr(*, &quot;unit&quot;)= int 1 ## $ legend.box.background : list() ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_blank&quot; &quot;element&quot; ## $ legend.box.spacing : &#39;simpleUnit&#39; num 11points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ panel.background :List of 5 ## ..$ fill : chr &quot;white&quot; ## ..$ colour : logi NA ## ..$ size : NULL ## ..$ linetype : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; ## $ panel.border : list() ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_blank&quot; &quot;element&quot; ## $ panel.spacing : &#39;simpleUnit&#39; num 5.5points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ panel.spacing.x : NULL ## $ panel.spacing.y : NULL ## $ panel.grid :List of 6 ## ..$ colour : chr &quot;grey92&quot; ## ..$ size : NULL ## ..$ linetype : NULL ## ..$ lineend : NULL ## ..$ arrow : logi FALSE ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; ## $ panel.grid.major : list() ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_blank&quot; &quot;element&quot; ## $ panel.grid.minor : list() ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_blank&quot; &quot;element&quot; ## $ panel.grid.major.x : NULL ## $ panel.grid.major.y : NULL ## $ panel.grid.minor.x : NULL ## $ panel.grid.minor.y : NULL ## $ panel.ontop : logi FALSE ## $ plot.background :List of 5 ## ..$ fill : NULL ## ..$ colour : chr &quot;white&quot; ## ..$ size : NULL ## ..$ linetype : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; ## $ plot.title :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : &#39;rel&#39; num 1.2 ## ..$ hjust : num 0 ## ..$ vjust : num 1 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 5.5points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ plot.title.position : chr &quot;panel&quot; ## $ plot.subtitle :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : num 0 ## ..$ vjust : num 1 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 0points 0points 5.5points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ plot.caption :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : &#39;rel&#39; num 0.8 ## ..$ hjust : num 1 ## ..$ vjust : num 1 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 5.5points 0points 0points 0points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ plot.caption.position : chr &quot;panel&quot; ## $ plot.tag :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : &#39;rel&#39; num 1.2 ## ..$ hjust : num 0.5 ## ..$ vjust : num 0.5 ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ plot.tag.position : chr &quot;topleft&quot; ## $ plot.margin : &#39;margin&#39; num [1:4] 5.5points 5.5points 5.5points 5.5points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ strip.background :List of 5 ## ..$ fill : chr &quot;white&quot; ## ..$ colour : chr &quot;black&quot; ## ..$ size : &#39;rel&#39; num 2 ## ..$ linetype : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; ## $ strip.background.x : NULL ## $ strip.background.y : NULL ## $ strip.placement : chr &quot;inside&quot; ## $ strip.text :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : chr &quot;grey10&quot; ## ..$ size : &#39;rel&#39; num 0.8 ## ..$ hjust : NULL ## ..$ vjust : NULL ## ..$ angle : NULL ## ..$ lineheight : NULL ## ..$ margin : &#39;margin&#39; num [1:4] 4.4points 4.4points 4.4points 4.4points ## .. ..- attr(*, &quot;unit&quot;)= int 8 ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ strip.text.x : NULL ## $ strip.text.y :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : NULL ## ..$ angle : num -90 ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## $ strip.switch.pad.grid : &#39;simpleUnit&#39; num 2.75points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ strip.switch.pad.wrap : &#39;simpleUnit&#39; num 2.75points ## ..- attr(*, &quot;unit&quot;)= int 8 ## $ strip.text.y.left :List of 11 ## ..$ family : NULL ## ..$ face : NULL ## ..$ colour : NULL ## ..$ size : NULL ## ..$ hjust : NULL ## ..$ vjust : NULL ## ..$ angle : num 90 ## ..$ lineheight : NULL ## ..$ margin : NULL ## ..$ debug : NULL ## ..$ inherit.blank: logi TRUE ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;theme&quot; &quot;gg&quot; ## - attr(*, &quot;complete&quot;)= logi TRUE ## - attr(*, &quot;validate&quot;)= logi TRUE By inspecting the four histograms you should notice a clear pattern. The width or range of each histogram shrinks as the sample-size increases. What is going on here? Well, we already know that we can think of these histograms as windows of chance. They tell us which \\(r\\) values occur fairly often, which do not. When our sample-size is 10, lots of different \\(r\\) values happen. That histogram is very spread out. However, as the sample-size increases, we see that the window of chance gets pulled in. For example, by the time we get to 1000 balls each, almost all of the Pearson \\(r\\) values are very close to 0. One take home here, is that increasing sample-size narrows the window of chance. So, for example, if you ran a study involving 1000 samples of two measures, and you found a correlation of .5, then you can clearly see in the bottom right histogram that .5 does not occur very often by chance alone. In fact, there is no bar, because it didn’t happen even once in the simulation. As a result, when you have a large sample size like n = 1000, you might be more confident that your observed correlation (say of .5) was not a spurious correlation. If chance is not producing your result, then something else is. Finally, notice how your confidence about whether or not chance is mucking about with your results depends on your sample size. If you only obtained 10 samples per measurement, and found \\(r = .5\\), you should not be as confident that your correlation reflects a real relationship. Instead, you can see that \\(r\\)’s of .5 happen fairly often by chance alone. Pro tip: when you run an experiment, under ideal circumstances, you get to decide how many samples you will collect. This means narrowing the window of chance. Let’s ingrain these ideas with some more animations. When our sample-size is small (referred to as “n is small”), sampling error can cause all sorts of “patterns” in the data. This makes it possible, and indeed common, for “correlations” to occur between two sets of numbers. When we increase the sample-size, sampling error is reduced, making it less possible for correlations to occur just by chance alone. 4.1.3 Animation of no relationship between variables Below we randomly sample numbers for two variables, plot them, and show the correlation using a line. There are four panels, each showing the number of observations in the samples, from 10, 50, 100, to 1000 in each sample. Remember, because we are randomly sampling numbers, there should be no relationship between the X and Y variables. But, as we have been discussing, we can sometimes observe a correlation due to chance. The important thing to watch is how the line behaves across the four panels. The line twirls around in all directions when the sample size is 10. It is also moves around quite a bit when the sample size is 50 or 100. It still moves a bit when the sample size is 1000, but much less. In all cases we expect the line to be flat, but sometimes the line shows us a pseudo relationship. Figure 4.6: Animation of how correlation behaves for completely random X and Y variables as a function of sample size. The best fit line is not very stable for small sample-sizes, but becomes more reliably flat as sample-size increases Which line should you trust? Well, hopefully you can see that the line for 1000 samples is the most stable. It tends to be very flat every time, and it does not depend so much on the particular sample. The line with 10 observations per sample goes all over the place. The take home here, is that if someone told you that they found a correlation, you should want to know how many observations they had in their sample. If they only had 10 observations, how could you trust the claim that there was a correlation? Not now that you know samples that are that small can do all sorts of things by chance alone. If instead, you found out the sample was very large, then you might trust that finding a little bit more. For example, in the above animation you can see that when there are 1000 samples, we never see a strong or even weak correlation; the line is almost always completely flat. This is because chance almost never produces strong correlations when the sample size is very large. Let’s look at an animation when there actually is a correlation between variables. 4.1.4 Animation with a relationship between variables Sometimes there are correlations between two variables that are not caused by chance. Below, we get to watch an animation of four scatter plots. Each shows the correlation between two variables. Again, we change the sample-size in steps of 10, 50 100, and 1000. The data have been programmed to contain a real positive correlation. So, we should expect that the line will be going up from the bottom left to the top right. However, there is still variability in the data. So this time, sampling error due to chance will fuzz the correlation. We know it is there, but sometimes chance will cause the correlation to be eliminated. Notice that in the top left panel (sample-size 10), the line is twirling around much more than the other panels. Every new set of samples produces different correlations. Sometimes, the line even goes flat or downward. However, as we increase sample-size, we can see that the line doesn’t change very much, it is always going up showing a positive correlation. Figure 4.7: How correlation behaves as a function of sample-size when there is a true correlation between X and Y variables The main takeaway here is that even when there is a positive correlation between two things, you might not be able to see it if your sample size is small. For example, you might get unlucky with the one sample that you measured. Your sample could show a negative correlation, even when the actual correlation is positive! Unfortunately, in the real world we usually only have the sample that we collected, so we always have to wonder if we got lucky or unlucky. If you want to remove luck, you need to collect larger samples. Then you will be much more likely to observe the real pattern, rather the a pattern that can be introduced by chance. This concludes the first part of this chapter: building an intuition about inferential statistics by seeing how random chance underlies our observations. Now, we move on to the second part of this chapter: probability theory. 4.2 How are probability and statistics different? Before we start talking about probability theory in more detail, it’s helpful to spend a moment thinking about the relationship between probability and statistics. The two disciplines are closely related but they’re not identical. Probability theory is “the doctrine of chances.” It’s a branch of mathematics that tells you how often different kinds of events will happen. For example, all of these questions are things you can answer using probability theory: What are the chances of a fair coin coming up heads 10 times in a row? If I roll two six sided dice, how likely is it that I’ll roll two sixes? How likely is it that five cards drawn from a perfectly shuffled deck will all be hearts? What are the chances that I’ll win the lottery? Notice that all of these questions have something in common. In each case the “truth of the world” is known, and my question relates to the “what kind of events” will happen. In the first question I know that the coin is fair, so there’s a 50% chance that any individual coin flip will come up heads. In the second question, I know that the chance of rolling a 6 on a single die is 1 in 6. In the third question I know that the deck is shuffled properly. And in the fourth question, I know that the lottery follows specific rules. You get the idea. The critical point is that probabilistic questions start with a known model of the world, and we use that model to do some calculations. The underlying model can be quite simple. For instance, in the coin flipping example, we can write down the model like this: \\(P(\\mbox{heads}) = 0.5\\) which you can read as “the probability of heads is 0.5.” As we’ll see later, in the same way that percentages are numbers that range from 0% to 100%, probabilities are just numbers that range from 0 to 1. When using this probability model to answer the first question, I don’t actually know exactly what’s going to happen. Maybe I’ll get 10 heads, like the question says. But maybe I’ll get three heads. That’s the key thing: in probability theory, the model is known, but the data are not. So that’s probability. What about statistics? Statistical questions work the other way around. In statistics, we do not know the truth about the world. All we have is the data, and it is from the data that we want to learn the truth about the world. Statistical questions tend to look more like these: If my friend flips a coin 10 times and gets 10 heads, are they playing a trick on me? If five cards off the top of the deck are all hearts, how likely is it that the deck was shuffled? If the lottery commissioner’s spouse wins the lottery, how likely is it that the lottery was rigged? This time around, the only thing we have are data. What I know is that I saw my friend flip the coin 10 times and it came up heads every time. And what I want to infer is whether or not I should conclude that what I just saw was actually a fair coin being flipped 10 times in a row, or whether I should suspect that my friend is playing a trick on me. The data I have looks like this: H H H H H H H H H H H and what I’m trying to do is work out which “model of the world” I should put my trust in. If the coin is fair, then the model I should adopt is one that says that the probability of heads is 0.5; that is, \\(P(\\mbox{heads}) = 0.5\\). If the coin is not fair, then I should conclude that the probability of heads is not 0.5, which we would write as \\(P(\\mbox{heads}) \\neq 0.5\\). In other words, the statistical inference problem is to figure out which of these probability models is right. Clearly, the statistical question isn’t the same as the probability question, but they’re deeply connected to one another. Because of this, a good introduction to statistical theory will start with a discussion of what probability is and how it works. 4.3 What does probability mean? Let’s start with the first of these questions. What is “probability?” It might seem surprising to you, but while statisticians and mathematicians (mostly) agree on what the rules of probability are, there’s much less of a consensus on what the word really means. It seems weird because we’re all very comfortable using words like “chance,” “likely,” “possible” and “probable,” and it doesn’t seem like it should be a very difficult question to answer. If you had to explain “probability” to a five year old, you could do a pretty good job. But if you’ve ever had that experience in real life, you might walk away from the conversation feeling like you didn’t quite get it right, and that (like many everyday concepts) it turns out that you don’t really know what it’s all about. So I’ll have a go at it. Let’s suppose I want to bet on a soccer game between two teams of robots, Arduino Arsenal and CPU Milan. After thinking about it, I decide that there is an 80% probability that Arduino Arsenal wins. What do I mean by that? Here are three possibilities… They’re robot teams, so I can make them play over and over again, and if I did that, Arduino Arsenal would win 8 out of every 10 games on average. For any given game, I would only agree that betting on this game is “fair” if a $1 bet on CPU Milan gives a $5 payoff (i.e. I get my $1 back plus a $4 reward for being correct), as would a $4 bet on Arduino Arsenal (i.e., my $4 bet plus a $1 reward). My subjective “belief” or “confidence” in an Arduino Arsenal victory is four times as strong as my belief in a CPU Milan victory. Each of these seems sensible. However they’re not identical, and not every statistician would endorse all of them. The reason is that there are different statistical ideologies (yes, really!) and depending on which one you subscribe to, you might say that some of those statements are meaningless or irrelevant. In this section, I give a brief introduction the two main approaches that exist in the literature. These are by no means the only approaches, but they’re the two big ones. 4.3.1 The frequentist view The first of the two major approaches to probability, and the more dominant one in statistics, is referred to as the frequentist view, and it defines probability as a long-run frequency. Suppose we were to try flipping a fair coin, over and over again. By definition, this is a coin that has \\(P(H) = 0.5\\). What might we observe? One possibility is that the first 20 flips might look like this: T,H,H,H,H,T,T,H,H,H,H,T,H,H,T,T,T,T,T,H In this case 11 of these 20 coin flips (55%) came up heads. Now suppose that I’d been keeping a running tally of the number of heads (which I’ll call \\(N_H\\)) that I’ve seen, across the first \\(N\\) flips, and calculate the proportion of heads \\(N_H / N\\) every time. Here’s what I’d get (I did literally flip coins to produce this!): number of flips 1 2 3 4 5 6 7 8 9 10 number of heads 0 1 2 3 4 4 4 5 6 7 proportion .00 .50 .67 .75 .80 .67 .57 .63 .67 .70 number of flips 11 12 13 14 15 16 17 18 19 20 number of heads 8 8 9 10 10 10 10 10 10 11 proportion .73 .67 .69 .71 .67 .63 .59 .56 .53 .55 Notice that at the start of the sequence, the proportion of heads fluctuates wildly, starting at .00 and rising as high as .80. Later on, one gets the impression that it dampens out a bit, with more and more of the values actually being pretty close to the “right” answer of .50. This is the frequentist definition of probability in a nutshell: flip a fair coin over and over again, and as \\(N\\) grows large (approaches infinity, denoted \\(N\\rightarrow \\infty\\)), the proportion of heads will converge to 50%. There are some subtle technicalities that the mathematicians care about, but qualitatively speaking, that’s how the frequentists define probability. Unfortunately, I don’t have an infinite number of coins, or the infinite patience required to flip a coin an infinite number of times. However, I do have a computer, and computers excel at mindless repetitive tasks. So I asked my computer to simulate flipping a coin 1000 times, and then drew a picture of what happens to the proportion \\(N_H / N\\) as \\(N\\) increases. Actually, I did it four times, just to make sure it wasn’t a fluke. The results are shown in Figure 4.8. As you can see, the proportion of observed heads eventually stops fluctuating, and settles down; when it does, the number at which it finally settles is (close to) the “true” probability of heads. Figure 4.8: An illustration of how frequentist probability works. If you flip a fair coin over and over again, the proportion of heads that you’ve seen eventually settles down, and converges to the true probability of 0.5. Each panel shows four different simulated experiments: in each case, we pretend we flipped a coin 1000 times, and kept track of the proportion of flips that were heads as we went along. Although none of these sequences actually ended up with an exact value of .5, if we’d extended the experiment for an infinite number of coin flips they would have. The frequentist definition of probability has some desirable characteristics. First, it is objective: the probability of an event is necessarily grounded in the world. The only way that probability statements can make sense is if they refer to (a sequence of) events that occur in the physical universe. Second, it is unambiguous: any two people watching the same sequence of events unfold, trying to calculate the probability of an event, must inevitably come up with the same answer. However, it also has undesirable characteristics. Infinite sequences don’t exist in the physical world. For example, suppose you picked up a coin from your pocket and started to flip it. Every time it lands, it impacts on the ground. Each impact wears the coin down a bit; eventually, the coin will be destroyed. So, one might ask whether it really makes sense to pretend that an “infinite” sequence of coin flips is even a meaningful concept, or an objective one. We can’t say that an “infinite sequence” of events is a real thing in the physical universe, because the physical universe doesn’t allow infinite anything. More seriously, the frequentist definition has a narrow scope. There are lots of things out there that human beings are happy to assign probability to in everyday language, but cannot (even in theory) be mapped onto a hypothetical sequence of events. For instance, if a meteorologist comes on TV and says, “the probability of rain in Rotterdam on 2 November 2048 is 60%” we humans are happy to accept this. But it’s not clear how to define this in frequentist terms. There’s only one city of Rotterdam, and only one November 2, 2048. There’s no infinite sequence of events here, just a once-off thing. Frequentist probability genuinely forbids us from making probability statements about a single event. From the frequentist perspective, it will either rain tomorrow or it will not; there is no “probability” that attaches to a single non-repeatable event. Now, it should be said that there are some very clever tricks that frequentists can use to get around this. One possibility is that what the meteorologist means is something like this: “There is a category of days for which I predict a 60% chance of rain; if we look only across those days for which I make this prediction, then on 60% of those days it will actually rain.” It’s very weird and counterintuitive to think of it this way, but you do see frequentists do this sometimes. 4.3.2 The Bayesian view The Bayesian view of probability is often called the subjectivist view, and it is a minority view among statisticians, but one that has been steadily gaining traction for the last several decades. There are many flavours of Bayesianism, making hard to say exactly what “the” Bayesian view is. The most common way of thinking about subjective probability is to define the probability of an event as the degree of belief that an intelligent and rational agent assigns to that truth of that event. From that perspective, probabilities don’t exist in the world, but rather in the thoughts and assumptions of people and other intelligent beings. However, in order for this approach to work, we need some way of operationalising the “degree of belief.” One way that you can do this is to formalise it in terms of “rational gambling,” though there are many other ways. Suppose that I believe that there’s a 60% probability of rain tomorrow. If someone offers me a bet: if it rains tomorrow, then I win $5, but if it doesn’t rain then I lose $5. Clearly, from my perspective, this is a pretty good bet. On the other hand, if I think that the probability of rain is only 40%, then it’s a bad bet to take. Thus, we can operationalise the notion of a “subjective probability” in terms of what bets I’m willing to accept. What are the advantages and disadvantages to the Bayesian approach? The main advantage is that it allows you to assign probabilities to any event you want to. You don’t need to be limited to those events that are repeatable. The main disadvantage (to many people) is that we can’t be purely objective – specifying a probability requires us to specify an entity that has the relevant degree of belief. This entity might be a human, an alien, a robot, or even a statistician, but there has to be an intelligent agent out there that believes in things. To many people this is uncomfortable: it seems to make probability arbitrary. While the Bayesian approach does require that the agent in question be rational (i.e., obey the rules of probability), it does allow everyone to have their own beliefs; I can believe the coin is fair and you don’t have to, even though we’re both rational. The frequentist view doesn’t allow any two observers to attribute different probabilities to the same event: when that happens, then at least one of them must be wrong. The Bayesian view does not prevent this from occurring. Two observers with different background knowledge can legitimately hold different beliefs about the same event. In short, where the frequentist view is sometimes considered to be too narrow (forbids lots of things that that we want to assign probabilities to), the Bayesian view is sometimes thought to be too broad (allows too many differences between observers). 4.3.3 What’s the difference? And who is right? Now that you’ve seen each of these two views independently, it’s useful to make sure you can compare the two. Go back to the hypothetical robot soccer game at the start of the section. What do you think a frequentist and a Bayesian would say about these three statements? Which statement would a frequentist say is the correct definition of probability? Which one would a Bayesian do? Would some of these statements be meaningless to a frequentist or a Bayesian? If you’ve understood the two perspectives, you should have some sense of how to answer those questions. Okay, assuming you understand the difference, you might be wondering which of them is right? Honestly, I don’t know that there is a right answer. As far as I can tell there’s nothing mathematically incorrect about the way frequentists think about sequences of events, and there’s nothing mathematically incorrect about the way that Bayesians define the beliefs of a rational agent. In fact, when you dig down into the details, Bayesians and frequentists actually agree about a lot of things. Many frequentist methods lead to decisions that Bayesians agree a rational agent would make. Many Bayesian methods have very good frequentist properties. For the most part, I’m a pragmatist so I’ll use any statistical method that I trust. As it turns out, that makes me prefer Bayesian methods, but I’m not fundamentally opposed to frequentist methods. Not everyone is quite so relaxed. For instance, consider Sir Ronald Fisher (yes, that Fisher), a vehement opponent to all things Bayesian, whose paper on the mathematical foundations of statistics referred to Bayesian probability as “an impenetrable jungle [that] arrests progress towards precision of statistical concepts” Fisher (1922, 311). Or the psychologist Paul Meehl, who suggests that relying on frequentist methods could turn you into “a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring” Meehl (1967, 114). The history of statistics, as you might gather, is not devoid of entertainment. 4.4 Basic probability theory Ideological arguments between Bayesians and frequentists notwithstanding, it turns out that people mostly agree on the rules that probabilities should obey. There are lots of different ways of arriving at these rules. The most commonly used approach is based on the work of Andrey Kolmogorov, one of the great Soviet mathematicians of the 20th century. I won’t go into a lot of detail, but I’ll try to give you a bit of a sense of how it works. And in order to do so, I’m going to have to talk about my pants. One of the disturbing truths about my life is that I only own 5 pairs of pants: three pairs of jeans, the bottom half of a suit, and a pair of tracksuit pants. Even sadder, I’ve given them names: I call them \\(X_1\\), \\(X_2\\), \\(X_3\\), \\(X_4\\) and \\(X_5\\). I really do: that’s why they call me Mister Imaginative. Now, on any given day, I pick out exactly one of pair of pants to wear. Not even I’m so stupid as to try to wear two pairs of pants, and thanks to years of training I never go outside without wearing pants anymore. If I were to describe this situation using the language of probability theory, I would refer to each pair of pants (i.e., each \\(X\\)) as an elementary event. The key characteristic of elementary events is that every time we make an observation (e.g., every time I put on a pair of pants), then the outcome will be one and only one of these events. Like I said, these days I always wear exactly one pair of pants, so my pants satisfy this constraint. Similarly, the set of all possible events is called a sample space. Granted, some people would call it a “wardrobe,” but that’s because they’re refusing to think about my pants in probabilistic terms. Sad. Okay, now that we have a sample space (a wardrobe), which is built from lots of possible elementary events (pants), what we want to do is assign a probability to one of these elementary events. For an event \\(X\\), the probability of that event \\(P(X)\\) is a number that lies between 0 and 1. The bigger the value of \\(P(X)\\), the more likely the event is to occur. So, for example, if \\(P(X) = 0\\), it means the event \\(X\\) is impossible (i.e., I never wear those pants). On the other hand, if \\(P(X) = 1\\) it means that event \\(X\\) is certain to occur (i.e., I always wear those pants). For probability values in the middle, it means that I sometimes wear those pants. For instance, if \\(P(X) = 0.5\\) it means that I wear those pants half of the time. At this point, we’re almost done. The last thing we need to recognise is that “something always happens.” Every time I put on pants, I really do end up wearing pants (crazy, right?). What this somewhat trite statement means, in probabilistic terms, is that the probabilities of the elementary events need to add up to 1. This is known as the law of total probability, not that any of us really care. More importantly, if these requirements are satisfied, then what we have is a probability distribution. For example, this is an example of a probability distribution Which pants? Label Probability Blue jeans \\(X_1\\) \\(P(X_1) = .5\\) Grey jeans \\(X_2\\) \\(P(X_2) = .3\\) Black jeans \\(X_3\\) \\(P(X_3) = .1\\) Black suit \\(X_4\\) \\(P(X_4) = 0\\) Blue tracksuit \\(X_5\\) \\(P(X_5) = .1\\) Each of the events has a probability that lies between 0 and 1, and if we add up the probability of all events, they sum to 1. Awesome. We can even draw a nice bar graph to visualise this distribution, as shown in Figure 4.9. And at this point, we’ve all achieved something. You’ve learned what a probability distribution is, and I’ve finally managed to find a way to create a graph that focuses entirely on my pants. Everyone wins! Figure 4.9: A visual depiction of the “pants” probability distribution. There are five “elementary events,” corresponding to the five pairs of pants that I own. Each event has some probability of occurring: this probability is a number between 0 to 1. The sum of these probabilities is 1. The only other thing that I need to point out is that probability theory allows you to talk about non elementary events as well as elementary ones. The easiest way to illustrate the concept is with an example. In the pants example, it’s perfectly legitimate to refer to the probability that I wear jeans. In this scenario, the “Thomas wears jeans” event said to have happened as long as the elementary event that actually did occur is one of the appropriate ones; in this case “blue jeans,” “black jeans” or “grey jeans.” In mathematical terms, we defined the “jeans” event \\(E\\) to correspond to the set of elementary events \\((X_1, X_2, X_3)\\). If any of these elementary events occurs, then \\(E\\) is also said to have occurred. Having decided to write down the definition of the \\(E\\) this way, it’s pretty straightforward to state what the probability \\(P(E)\\) is: we just add everything up. In this particular case \\[P(E) = P(X_1) + P(X_2) + P(X_3)\\] and, since the probabilities of blue, grey and black jeans respectively are .5, .3 and .1, the probability that I wear jeans is equal to .9. At this point you might be thinking that this is all terribly obvious and simple and you’d be right. All we’ve really done is wrap some basic mathematics around a few common sense intuitions. However, from these simple beginnings it’s possible to construct some extremely powerful mathematical tools. I’m definitely not going to go into the details in this book, but what I will do is list some of the other rules that probabilities satisfy. These rules can be derived from the simple assumptions that I’ve outlined above, but since we don’t actually use these rules for anything in this book, I won’t do so here. English Notation Formula not \\(A\\) \\(P(\\neg A)\\) \\(=\\) \\(1-P(A)\\) \\(A\\) or \\(B\\) \\(P(A \\cup B)\\) \\(=\\) \\(P(A) + P(B) - P(A \\cap B)\\) \\(A\\) and \\(B\\) \\(P(A \\cap B)\\) \\(=\\) \\(P(A|B) \\cdot P(B)\\) You don’t really need to know these rules in order to understand the analyses that we’ll talk about later in the book, but they are important if you want to understand probability theory a bit more deeply. 4.5 Probability distributions You just saw your first probability distribution in Figure 4.9. The concept of a probability distributions is hugely important for understanding inferential statistics. As you might imagine, probability distributions can vary enormously, and there’s a large range of different distributions out there. However, not all probability distributions are equally important. In fact, the vast majority of the content in this book relies on one of three distributions: the binomial distribution, the normal distribution and the \\(t\\) distribution. Given this, what I’ll do over the next few sections is provide a brief introduction to these distributions, paying special attention to the binomial and the normal. I’ll start with the binomial distribution, since it’s the simplest of the three. 4.5.1 The binomial distribution The theory of probability originated in the attempt to describe how games of chance work, so it seems fitting that our discussion of the binomial distribution should involve a discussion of rolling dice and flipping coins. Let’s imagine a simple “experiment”: in my hot little hand I’m holding 20 identical six-sided dice. On one face of each die there’s a picture of a skull; the other five faces are all blank. If I proceed to roll all 20 dice, what’s the probability that I’ll get exactly 4 skulls? Assuming that the dice are fair, we know that the chance of any one die coming up skulls is 1 in 6; to say this another way, the skull probability for a single die is approximately \\(.167\\). This is enough information to answer our question, so let’s have a look at how it’s done. As usual, we have to introduce some names and some notation. We’ll let \\(N\\) denote the number of dice rolls in our experiment; which is often referred to as the size parameter of our binomial distribution. We’ll also use \\(\\theta\\) (theta) to refer to the the probability that a single die comes up skulls, a quantity that is usually called the success probability of the binomial. Finally, we’ll use \\(X\\) to refer to the results of our experiment, namely the number of skulls I get when I roll the dice. Since the actual value of \\(X\\) is due to chance, we refer to it as a random variable. In any case, now that we have all this terminology and notation, we can use it to state the problem a little more precisely. The quantity that we want to calculate is the probability that \\(X = 4\\) given that we know that \\(\\theta = .167\\) and \\(N=20\\). The general “form” of the thing I’m interested in calculating could be written as \\[P(X \\ | \\ \\theta, N)\\] (say: the probability of \\(X\\) given \\(\\theta\\) and \\(N\\)) and we’re interested in the special case where \\(X=4\\), \\(\\theta = .167\\) and \\(N=20\\). There’s only one more piece of notation I want to refer to before moving on to discuss the solution to the problem. If I want to say that \\(X\\) is generated randomly from a binomial distribution with parameters \\(\\theta\\) and \\(N\\), the notation I would use is as follows: \\[X \\sim \\mbox{Binomial}(\\theta, N)\\] Yeah, yeah. I know what you’re thinking: notation, notation, notation. Really, who cares? Very few readers of this book are here for the notation, so I should probably move on and talk about how to use the binomial distribution. To that end, Figure 4.10 plots the binomial probabilities for all possible values of \\(X\\) for our dice rolling experiment, from \\(X=0\\) (no skulls) all the way up to \\(X=20\\) (all skulls). Note that this is basically a bar chart, and is no different to the “pants probability” plot I drew in Figure 4.9. On the horizontal axis we have all the possible events, and on the vertical axis we can read off the probability of each of those events. So, the probability of rolling 4 skulls out of 20 times is about 0.20 (the actual answer is 0.2022036, as we’ll see in a moment). In other words, you’d expect that to happen about 20% of the times you repeated this experiment. Figure 4.10: The binomial distribution with size parameter of N =20 and an underlying success probability of 1/6. Each vertical bar depicts the probability of one specific outcome (i.e., one possible value of X). Because this is a probability distribution, each of the probabilities must be a number between 0 and 1, and the heights of the bars must sum to 1 as well. 4.5.2 Working with the binomial distribution in R Although some people find it handy to know the formula for calculating probabilities from a binomial distribution, most people just want to know how to use the distributions without worrying too much about the maths. To that end, R has a function called dbinom() that calculates binomial probabilities for us. The main arguments to the function are: x: a number, or vector of numbers, specifying the outcomes whose probability you’re trying to calculate. size: a number telling R the size of the experiment. prob: the success probability for any one trial in the experiment. So, in order to calculate the probability of getting skulls, from an experiment of trials, in which the probability of getting a skull on any one trial is … well, the command I would use is simply this: dbinom( x = 4, size = 20, prob = 1/6 ) ## [1] 0.2022036 To give you a feel for how the binomial distribution changes when we alter the values of \\(\\theta\\) and \\(N\\), let’s suppose that instead of rolling dice, I’m actually flipping coins. This time around, my experiment involves flipping a fair coin repeatedly, and the outcome that I’m interested in is the number of heads that I observe. In this scenario, the success probability is now \\(\\theta = 1/2\\). Suppose I were to flip the coin \\(N=20\\) times. In this example, I’ve changed the success probability, but kept the size of the experiment the same. What does this do to our binomial distribution? Figure 4.11: Two binomial distributions, involving a scenario in which I’m flipping a fair coin, so the underlying success probability is 1/2. In panel (a), we assume I’m flipping the coin N = 20 times. In panel (b) we assume that the coin is flipped N = 100 times. Well, as Figure 4.11a shows, the main effect of this is to shift the whole distribution, as you’d expect. Okay, what if we flipped a coin \\(N=100\\) times? Well, in that case, we get Figure 4.11b. The distribution stays roughly in the middle, but there’s a bit more variability in the possible outcomes. At this point, I should probably explain the name of the dbinom function. Obviously, the “binom” part comes from the fact that we’re working with the binomial distribution, but the “d” prefix is probably a bit of a mystery. In this section I’ll give a partial explanation: specifically, I’ll explain why there is a prefix. As for why it’s a “d” specifically, you’ll have to wait until the next section. What’s going on here is that R actually provides four functions in relation to the binomial distribution. These four functions are dbinom, pbinom, rbinom and qbinom, and each one calculates a different quantity of interest. Not only that, R does the same thing for every probability distribution that it implements. No matter what distribution you’re talking about, there’s a d function, a p function, r a function and a q function. Let’s have a look at what all four functions do. Firstly, all four versions of the function require you to specify the size and prob arguments: no matter what you’re trying to get R to calculate, it needs to know what the parameters are. However, they differ in terms of what the other argument is, and what the output is. So let’s look at them one at a time. The d form we’ve already seen: you specify a particular outcome x, and the output is the probability of obtaining exactly that outcome. (the “d” is short for density, but ignore that for now). The p form calculates the cumulative probability. You specify a particular quantile q , and it tells you the probability of obtaining an outcome smaller than or equal to q. The q form calculates the quantiles of the distribution. You specify a probability value p, and it gives you the corresponding quantile/percentile. That is, the value of the variable for which there’s a probability p of obtaining an outcome lower than that value. The r form is a random number generator: specifically, it generates n random outcomes from the distribution. Note: Probably you already know what a quantile is (they’re more commonly called percentiles), but if not: the 10th quantile/percentile of a data set is the smallest number \\(x\\) such that 10% of the data is less than \\(x\\). In fact, we’ve already come across the idea: the median of a data set is its 50th quantile / percentile! This is a little abstract, so let’s look at some concrete examples. Again, we’ve already covered dbinom so let’s focus on the other three versions. We’ll start with pbinom, and we’ll go back to the skull-dice example. Again, I’m rolling 20 dice, and each die has a 1 in 6 chance of coming up skulls. Suppose, however, that I want to know the probability of rolling 4 or fewer skulls. If I wanted to, I could use the dbinom function to calculate the exact probability of rolling 0 skulls, 1 skull, 2 skulls, 3 skulls and 4 skulls and then add these up, but there’s a faster way. Instead, I can calculate this using the pbinom function. Here’s the command: pbinom(q= 4, size = 20, prob = 1/6) ## [1] 0.7687492 In other words, there is a 76.9% chance that I will roll 4 or fewer skulls. Or, to put it another way, R is telling us that a value of 4 is actually the 76.9th percentile of this binomial distribution. Next, let’s consider the qbinom function. Let’s say I want to calculate the 75th percentile of the binomial distribution. If we’re sticking with our skulls example, I would use the following command to do this: qbinom(p = 0.75, size = 20, prob = 1/6 ) ## [1] 4 Hm. There’s something odd going on here. Let’s think this through. What the qbinom function appears to be telling us is that the 75th percentile of the binomial distribution is 4, even though we saw from the function that 4 is actually the 76.9th percentile. And it’s definitely the pbinom function that is correct. I promise. The weirdness here comes from the fact that our binomial distribution doesn’t really have a 75th percentile. Not really. Why not? Well, there’s a 56.7% chance of rolling 3 or fewer skulls (you can type pbinom(3, 20, 1/6) to confirm this if you want), and a 76.9% chance of rolling 4 or fewer skulls. So there’s a sense in which the 75th percentile should lie “in between” 3 and 4 skulls. But that makes no sense at all! You can’t roll 20 dice and get 3.9 of them come up skulls. This issue can be handled in different ways: you could report an in between value (or interpolated value, to use the technical name) like 3.9, you could round down (to 3) or you could round up (to 4). The qbinom function rounds upwards: if you ask for a percentile that doesn’t actually exist (like the 75th in this example), R finds the smallest value for which the the percentile rank is at least what you asked for. In this case, since the “true” 75th percentile (whatever that would mean) lies somewhere between 3 and 4 skulls, R rounds up and gives you an answer of 4. This subtlety is tedious, I admit, but thankfully it’s only an issue for discrete distributions like the binomial. The other distributions that I’ll talk about (normal and \\(t\\)) are continuous, and so R can always return an exact quantile whenever you ask for it. Finally, we have the random number generator. To use the rbinom function, you specify how many times R should “simulate” the experiment using the n argument, and it will generate random outcomes from the binomial distribution. So, for instance, suppose I were to repeat my die rolling experiment 100 times. I could get R to simulate the results of these experiments by using the following command: rbinom(n = 100, size = 20, prob = 1/6 ) ## [1] 3 3 6 3 2 5 2 3 3 2 4 2 2 2 3 6 2 4 6 2 2 3 7 6 2 5 2 1 1 2 6 6 3 1 2 4 4 ## [38] 1 2 2 1 3 5 5 5 2 2 1 3 1 4 3 3 3 3 5 4 4 2 3 2 4 4 4 6 4 3 1 3 2 2 1 4 3 ## [75] 3 4 2 2 2 3 3 1 3 4 5 4 3 1 3 1 6 5 4 4 4 5 1 4 4 7 Note: Since computers are deterministic machines, they can’t actually produce truly random behaviour. Instead, what they do is take advantage of various mathematical functions that share a lot of similarities with true randomness. What this means is that any random numbers generated on a computer are pseudorandom, and the quality of those numbers depends on the specific method used. By default R uses the “Mersenne twister” method. In any case, you can find out more by typing ?Random, but as usual the R help files are fairly dense. As you can see, these numbers are pretty much what you’d expect given the distribution shown in Figure 4.10. Most of the time I roll somewhere between 1 to 5 skulls. There are a lot of subtleties associated with random number generation using a computer, but for the purposes of this book we don’t need to worry too much about them. 4.5.3 The normal distribution While the binomial distribution is conceptually the simplest distribution to understand, it’s not the most important one. That particular honour goes to the normal distribution, which is also referred to as “the bell curve” or a “Gaussian distribution.” Figure 4.12: The normal distribution with mean = 0 and standard deviation = 1. The x-axis corresponds to the value of some variable, and the y-axis tells us something about how likely we are to observe that value. However, notice that the y-axis is labelled Probability Density and not Probability. There is a subtle and somewhat frustrating characteristic of continuous distributions that makes the y axis behave a bit oddly: the height of the curve here isn’t actually the probability of observing a particular x value. On the other hand, it is true that the heights of the curve tells you which x values are more likely (the higher ones!). A normal distribution is described using two parameters, the mean of the distribution \\(\\mu\\) and the standard deviation of the distribution \\(\\sigma\\). The notation that we sometimes use to say that a variable \\(X\\) is normally distributed is as follows: \\[X \\sim \\mbox{Normal}(\\mu,\\sigma)\\] Of course, that’s just notation. It doesn’t tell us anything interesting about the normal distribution itself. The mathematical formula for the normal distribution is: Figure 4.13: Formula for the normal distribution The formula is important enough that everyone who learns statistics should at least look at it, but since this is an introductory text I don’t want to focus on it to much. Instead, we look at how R can be used to work with normal distributions. The R functions for the normal distribution are dnorm(), pnorm(), qnorm() and rnorm(). However, they behave in pretty much exactly the same way as the corresponding functions for the binomial distribution, so there’s not a lot that you need to know. The only thing that I should point out is that the argument names for the parameters are mean and sd. In pretty much every other respect, there’s nothing else to add. Instead of focusing on the maths, let’s try to get a sense for what it means for a variable to be normally distributed. To that end, have a look at Figure 4.12, which plots a normal distribution with mean \\(\\mu = 0\\) and standard deviation \\(\\sigma = 1\\). You can see where the name “bell curve” comes from: it looks a bit like a bell. Notice that, unlike the plots that I drew to illustrate the binomial distribution, the picture of the normal distribution in Figure 4.12 shows a smooth curve instead of “histogram-like” bars. This isn’t an arbitrary choice: the normal distribution is continuous, whereas the binomial is discrete. For instance, in the die rolling example from the last section, it was possible to get 3 skulls or 4 skulls, but impossible to get 3.9 skulls. With this in mind, let’s see if we can get an intuition for how the normal distribution works. Firstly, let’s have a look at what happens when we play around with the parameters of the distribution. One parameter we can change is the mean. This will shift the distribution to the right or left. The animation below shows a normal distribution with mean = 0, moving up and down from mean = 0 to mean = 5. Note, when you change the mean the whole shape of the distribution does not change, it just shifts from left to right. In the animation the normal distribution bounces up and down a little, but that’s just a quirk of the animation (plus it looks fun that way). Figure 4.14: A normal distribution with a moving mean In contrast, if we increase the standard deviation while keeping the mean constant, the peak of the distribution stays in the same place, but the distribution gets wider. The next animation shows what happens when you start with a small standard deviation (sd=0.5), and move to larger and larger standard deviation (up to sd =5). As you can see, the distribution spreads out and becomes wider as the standard deviation increases. Figure 4.15: A normal distribution with a shifting sd Notice, though, that when we widen the distribution, the height of the peak shrinks. This has to happen: in the same way that the heights of the bars that we used to draw a discrete binomial distribution have to sum to 1, the total area under the curve for the normal distribution must equal 1. Before moving on, I want to point out one important characteristic of the normal distribution. Irrespective of what the actual mean and standard deviation are, approximately 68% of the area falls within 1 standard deviation of the mean (68.3% to be exact). Similarly, approximately 95% of the distribution falls within 2 standard deviations of the mean (95.4% to be exact), and 99.7% of the distribution is within 3 standard deviations. This idea is illustrated in the figure below. Figure 4.16: The area under the curve tells you the probability that an observation falls within a particular range. The solid lines plot normal distributions with mean \\(\\mu=0\\) and standard deviation \\(\\sigma=1\\). The shaded areas illustrate “areas under the curve” for several cases. In the upper left panel we can see there is a 68.3% chance that an observation will fall within one standard deviation of the mean. Next to it we see that there is a 95.4% chance that an observation will fall within two standard deviations of the mean. On the bottom row two more examples of the “area under the curve idea” are given; there is a 15.9% chance that an observation is one standard deviation below the mean or smaller and a 34.1% chance that the observation is greater than one standard deviation below the mean but still below the mean. Notice that if you add these two numbers together you get \\(15.9 + 34.1 = 50\\). For normally distributed data, there is a 50% chance that an observation falls below the mean. And of course that also implies that there is a 50% chance that it falls above the mean. 4.5.4 Probability density There’s something I’ve been trying to hide throughout my discussion of the normal distribution, something that some introductory textbooks omit completely. They might be right to do so: this “thing” that I’m hiding is weird and counterintuitive even by the admittedly distorted standards that apply in statistics. Fortunately, it’s not something that you need to understand at a deep level in order to do basic statistics: rather, it’s something that starts to become important later on when you move beyond the basics. So, if it doesn’t make complete sense, don’t worry: try to make sure that you follow the gist of it. Throughout my discussion of the normal distribution, there’s been one or two things that don’t quite make sense. Perhaps you noticed that the \\(y\\)-axis in these figures is labelled “Probability Density” rather than density. Maybe you noticed that I used \\(p(X)\\) instead of \\(P(X)\\) when giving the formula for the normal distribution. Maybe you’re wondering why R uses the “d” prefix for functions like dnorm(). And maybe, just maybe, you’ve been playing around with the dnorm() function, and you accidentally typed in a command like this: dnorm( x = 1, mean = 1, sd = 0.1 ) ## [1] 3.989423 And if you’ve done the last part, you’re probably very confused. I’ve asked R to calculate the probability that x = 1, for a normally distributed variable with mean = 1 and standard deviation sd = 0.1; and it tells me that the probability is 3.99. But, as we discussed earlier, probabilities can’t be larger than 1. So either I’ve made a mistake, or that’s not a probability. As it turns out, the second answer is correct. What we’ve calculated here isn’t actually a probability: it’s something else. To understand what that something is, you have to spend a little time thinking about what it really means to say that \\(X\\) is a continuous variable. Let’s say we’re talking about the temperature outside. The thermometer tells me it’s 23 degrees, but I know that’s not really true. It’s not exactly 23 degrees. Maybe it’s 23.1 degrees, I think to myself. But I know that that’s not really true either, because it might actually be 23.09 degrees. But, I know that… well, you get the idea. The tricky thing with genuinely continuous quantities is that you never really know exactly what they are. Now think about what this implies when we talk about probabilities. Suppose that tomorrow’s maximum temperature is sampled from a normal distribution with mean 23 and standard deviation 1. What’s the probability that the temperature will be exactly 23 degrees? The answer is “zero,” or possibly, “a number so close to zero that it might as well be zero.” Why is this? It’s like trying to throw a dart at an infinitely small dart board: no matter how good your aim, you’ll never hit it. In real life you’ll never get a value of exactly 23. It’ll always be something like 23.1 or 22.99998 or something. In other words, it’s completely meaningless to talk about the probability that the temperature is exactly 23 degrees. However, in everyday language, if I told you that it was 23 degrees outside and it turned out to be 22.9998 degrees, you probably wouldn’t call me a liar. Because in everyday language, “23 degrees” usually means something like “somewhere between 22.5 and 23.5 degrees.” And while it doesn’t feel very meaningful to ask about the probability that the temperature is exactly 23 degrees, it does seem sensible to ask about the probability that the temperature lies between 22.5 and 23.5, or between 20 and 30, or any other range of temperatures. The point of this discussion is to make clear that, when we’re talking about continuous distributions, it’s not meaningful to talk about the probability of a specific value. However, what we can talk about is the probability that the value lies within a particular range of values. To find out the probability associated with a particular range, what you need to do is calculate the “area under the curve.” Okay, so that explains part of the story. I’ve explained a little bit about how continuous probability distributions should be interpreted (i.e., area under the curve is the key thing), but I haven’t actually explained what the dnorm() function actually calculates. Equivalently, what does the formula for \\(p(x)\\) that I described earlier actually mean? Obviously, \\(p(x)\\) doesn’t describe a probability, but what is it? The name for this quantity \\(p(x)\\) is a probability density, and in terms of the plots we’ve been drawing, it corresponds to the height of the curve. The densities themselves aren’t meaningful in and of themselves: but they’re “rigged” to ensure that the area under the curve is always interpretable as genuine probabilities. To be honest, that’s about as much as you really need to know for now. 4.5.5 Other useful distributions The normal distribution is the distribution that statistics makes most use of (for reasons to be discussed shortly), and the binomial distribution is a very useful one for lots of purposes. But the world of statistics is filled with probability distributions (like the the \\(\\chi^2\\) distribution or the \\(F\\) distribution), some of which we’ll run into in passing. In particular, the \\(t\\) distribution will appear later in this book. I won’t give formulas for the \\(t\\) distribution, or talk about it in too much detail, but I will show you a picture: Figure 4.17: A \\(t\\) distribution with 3 degrees of freedom (solid line). A \\(t\\) distribution looks similar to a normal distribution, but it’s not quite the same. For comparison purposes, I’ve plotted a standard normal distribution as the dashed line. Notice that the \"tails\" of the \\(t\\) distribution are \"heavier\" (i.e., extend further outwards) than the tails of the normal distribution? That’s the important difference between the two. 4.6 z-scores We are now in a position to combine some of things we’ve been talking about in this chapter, and introduce you to a new tool: z-scores. It turns out we won’t use z-scores very much in this course. However, you can’t take a class on statistics and not learn about z-scores. The idea behind a z-score is to express your raw data in terms of its standard deviation under the assumption that your data is normally distributed. In a previous section I told you that, regardless of the actual mean and standard deviation of normally distributed data, approximately 68% of the area under a normal distribution falls within 1 standard deviation of the mean and approximately 95% within 2 standard deviations of the mean. Why is this knowledge useful? Let’s apply it to a concrete example: suppose you scored a 75% on a test. Just receiving a 75% wouldn’t tell you how you did compared to the rest of the class. However, if we assume the grades in your class are normally distributed and I told you that you scored 2 standard deviations above the mean, you’d have a pretty good idea how your score compares to the rest of the class. Most grades, assuming they are distributed normally, fall within 2 standard deviations of the mean (95.4% to be exact), so if you scored 2 standard deviations from the mean, you’ve done better than most students in your class (better than 97.7% of your class to be exact)16. To calculate a z-score, all you have to do is figure out how many standard deviations from the mean an observation is. Let’s say the mean score of your class is 65, and the standard deviation is 5. A friend scores a 68. How many standard deviations from the mean is her score? First compute the difference between her score and the mean: \\(68 - 65 = 3\\) How many standard deviations does 3 represent if 1 standard deviation is 5? Clearly 3 is smaller than 5, so it’s going to be less than 1. To figure it out, just divide 3 by the standard deviation. \\(z = \\frac{3}{5} = 0.60\\) Here’s the general formula: \\(z = \\frac{x-\\mu}{\\sigma}\\), or in English: \\(z = \\frac{\\text{raw score} - \\text{mean}}{\\text{standard deviation}}\\) So, for example if we had the following 5 scores from a normal distribution with \\(\\mu = 65\\), and \\(\\sigma = 5\\): scores &lt;- round(rnorm(5,65,5),digits=1) print(scores) ## [1] 60.8 71.7 58.4 56.7 62.0 The z-scores would be: round((scores-65)/5,2) ## [1] -0.84 1.34 -1.32 -1.66 -0.60 Once you have the z-scores, you could use them as another way to describe your data. For example, now just by looking at a z-score you know if it is likely or unlikely to occur, because you know how the area under the normal curve looks (Figure 4.16): z-scores between -1 and 1 happen pretty often, scores greater than 1 or -1 still happen fairly often, but not as often. And, scores bigger than 2 or -2 don’t happen very often. This is a convenient thing to do if you want to look at your numbers and get a general sense of how often they happen. We will learn next week that many measures can be assumed normally distributed. You might wonder why we bothered telling you about z-scores, when we won’t use them very much during this course. First, it’s worth knowing they are a thing. Second, they become more important as your statistical prowess becomes more advanced. Third, some statistical concepts, like correlation, can be re-written in terms of z-scores, and this illuminates aspects of those statistics. Finally, they are super useful when you are dealing with a normal distribution that has a known mean and standard deviation. 4.7 That’s it for this week We started this chapter by looking at “the window of chance” and developing an intuition for inferential statistics. Then, we talked about what probability means, and why statisticians can’t agree on what it means. We talked about the rules that probabilities have to obey. And we introduced the idea of a probability distribution, and spent a good chunk talking about some of the more important probability distributions that statisticians work with. As you’d expect, this coverage is by no means exhaustive. Probability theory is a large branch of mathematics in its own right, entirely separate from its application to statistics and data analysis. As such, there are thousands of books written on the subject and universities generally offer multiple classes devoted entirely to probability theory. Even the “simpler” task of documenting standard probability distributions is a big topic. Fortunately for you, very little of this is necessary. You’re unlikely to need to know dozens of statistical distributions when you go out and do real world data analysis, and you definitely won’t need them for this book, but it never hurts to know that there’s other possibilities out there. Picking up on that last point, there’s a sense in which this whole chapter is something of a digression. Many undergraduate psychology classes on statistics skim over this content very quickly, and even the more advanced classes will often “forget” to revisit the basic foundations of the field. Most academic psychologists would not know the difference between probability and density, and until recently very few would have been aware of the difference between Bayesian and frequentist probability. However, I think it’s important to understand these things before moving onto the applications. For example, there are a lot of rules about what you’re “allowed” to say when doing statistical inference, and many of these can seem arbitrary and weird. However, they start to make sense if you understand that there is this Bayesian/frequentist distinction. Similarly, in a later chapter, we’re going to talk about something called the \\(t\\)-test, and if you really want to have a grasp of the mechanics of the \\(t\\)-test it really helps to have a sense of what a \\(t\\)-distribution actually looks like. As a reminder, there are additional practice materials for this week on SOWISO. The materials on SOWISO have a slightly different take on probability theory and show you how to do many of the calculations we did in R by hand. Mix of Matthew Crump &amp; Danielle Navarro↩︎ We did something similar last week, but I didn’t show the code.↩︎ See this website by Tyler Vigen for some interesting spurious correlations. You can even use his website to discover a spurious correlation of your own!↩︎ You can look up the proportions of a normal distribution above/below a given z-score in a z-table. Alternatively, you can use the pnorm() function, e.g.: pnorm(2)↩︎ "],["week-5-estimation-and-sampling-theory.html", " 5 Week 5: Estimation and Sampling Theory17 5.1 Defining a population 5.2 The law of large numbers 5.3 Sampling distributions 5.4 The central limit theorem 5.5 Estimating population parameters 5.6 Estimating a confidence interval 5.7 That’s it for this week", " 5 Week 5: Estimation and Sampling Theory17 Remember, the role of descriptive statistics is to concisely summarize what we do know. In contrast, the purpose of inferential statistics is to “learn what we do not know from what we do.” What kinds of things would we like to learn about? And how do we learn them? These are the questions that lie at the heart of inferential statistics. Sampling theory plays a huge role in specifying the assumptions upon which your statistical inferences rely. And in order to talk about “making inferences” the way statisticians think about it, we need to be a bit more explicit about what it is that we’re drawing inferences from (the sample) and what it is that we’re drawing inferences about (the population). In almost every situation of interest, what we have available to us as researchers is a sample of data. We might have run experiment with some number of participants; a polling company might have phoned some number of people to ask questions about voting intentions; etc. Regardless: the data set available to us is finite, and incomplete. We can’t possibly get every person in the world to do our experiment; a polling company doesn’t have the time or the money to ring up every voter in the country etc. In our earlier discussion of descriptive statistics, the sample was the only thing we were interested in. Our only goal was to find ways of describing, summarizing and graphing that sample. This is about to change. 5.1 Defining a population A sample is a concrete thing. You can open up a data file, and there’s the data from your sample. A population, on the other hand, is a more abstract idea. It refers to the set of all possible people, or all possible observations, that you want to draw conclusions about, and is generally much bigger than the sample. In an ideal world, the researcher would begin the study with a clear idea of what the population of interest is, since the process of designing a study and testing hypotheses about the data that it produces does depend on the population about which you want to make statements. However, that doesn’t always happen in practice: usually the researcher only has a vague idea of what the population is and designs the study as best they can on that basis. Sometimes it’s easy to state the population of interest. For instance, in the “polling company” example given last week, the population consisted of all voters enrolled at the a time of the study – millions of people. The sample was a set of 1000 people who all belong to that population. In most situations the situation is much less simple. In a typical a psychological experiment, determining the population of interest is a bit more complicated. Suppose I run an experiment using 100 undergraduate students as my participants. My goal is to try to learn something about how the mind works. So, which of the following would count as “the population”: All of the undergraduate psychology students at the Erasmus University? Undergraduate psychology students in general, anywhere in the world? Dutch people currently living? People of similar ages to my sample? Anyone currently alive? Any human being, past, present or future? Any biological organism with a sufficient degree of intelligence operating in a terrestrial environment? Any intelligent being? Each of these defines a real group of mind-possessing entities, all of which might be of interest to me as a cognitive scientist, and it’s not at all clear which one ought to be the true population of interest. 5.1.1 Simple random samples Irrespective of how we define the population, the critical point is that the sample is a subset of the population, and our goal is to use our knowledge of the sample to draw inferences about the properties of the population. The relationship between the two depends on the procedure by which the sample was selected. This procedure is referred to as a sampling method, and it is important to understand why it matters. To keep things simple, imagine we have a bag containing 10 chips. Each chip has a unique letter printed on it, so we can distinguish between the 10 chips. The chips come in two colors, black and white. Figure 5.1: Simple random sampling without replacement from a finite population This set of chips is the population of interest, and it is depicted graphically on the left of Figure 5.1. As you can see from looking at the picture, there are 4 black chips and 6 white chips, but of course in real life we wouldn’t know that unless we looked in the bag. Now imagine you run the following “experiment”: you shake up the bag, close your eyes, and pull out 4 chips without putting any chips back into the bag. First out comes the \\(a\\) chip (black), then the \\(c\\) chip (white), then \\(j\\) (white) and then finally \\(b\\) (black). Each time you repeat this procedure (the right-hand side of Figure 5.1) you get different results, but the procedure is identical in each case. The fact that the same procedure can lead to different results each time, we refer to it as a random process. Because we shook the bag before pulling any chips out, it seems reasonable to think that every chip has the same chance of being selected. A procedure in which every member of the population has the same chance of being selected is called a simple random sample. The fact that we did not put the chips back in the bag while sampling, means you can’t pull out the same chip twice, and in such cases the observations are said to have been sampled without replacement. To help make sure you understand the importance of the sampling procedure, consider an alternative way in which the experiment could have been run. Suppose that my son had opened the bag, and decided to pull out only black chips without putting any of them back in the bag. This biased sampling scheme is depicted in Figure 5.2. Figure 5.2: Biased sampling without replacement from a finite population Now consider the evidentiary value of seeing 4 black chips and 0 white chips. Clearly, it depends on the sampling scheme, does it not? If you know that the sampling scheme is biased to select only black chips, then a sample that consists of only black chips doesn’t tell you very much about the population! For this reason, statisticians really like it when a data set can be considered a simple random sample, because it makes the data analysis much easier. A third procedure is worth mentioning. This time around we close our eyes, shake the bag, and pull out a chip. This time, however, we record the observation and then put the chip back in the bag. Again we close our eyes, shake the bag, and pull out a chip. We then repeat this procedure until we have 4 chips. Data sets generated in this way are still simple random samples, but because we put the chips back in the bag immediately after drawing them it is referred to as a sample with replacement. The difference between this situation and the first one is that it is possible to observe the same chip multiple times while sampling, as illustrated in Figure 5.3. Figure 5.3: Simple random sampling with replacement from a finite population Most experiments tend to be sampling without replacement, because the same person is not allowed to participate in the experiment twice. However, most statistical theory is based on the assumption that the data arise from a simple random sample with replacement. In real life, this very rarely matters. If the population of interest is large (e.g., has more than 10 entities!) the difference between sampling with- and without- replacement is too small to be concerned with. The difference between simple random samples and biased samples, on the other hand, is not such an easy thing to dismiss. 5.1.2 Most samples are not simple random samples As you can see from looking at the list of possible populations that I showed above, it is almost impossible to obtain a simple random sample from most populations of interest. When I run experiments, I’d consider it a minor miracle if my participants turned out to be a random sampling of the undergraduate psychology students at university, even though this is by far the narrowest population that I might want to generalize to. A thorough discussion of other types of sampling schemes is beyond the scope of this book, but to give you a sense of what’s out there I’ll list a few of the more important ones: Stratified sampling. Suppose your population is (or can be) divided into several different sub-populations, or strata. Perhaps you’re running a study at several different sites, for example. Instead of trying to sample randomly from the population as a whole, you try to collect a separate random sample from each of the strata. Stratified sampling is sometimes easier to do than simple random sampling, especially when the population is already divided into the distinct strata. It can also be more efficient that simple random sampling, especially when some of the sub-populations are rare. For instance, when studying schizophrenia it would be much better to divide the population into two strata (schizophrenic and not-schizophrenic), and then sample an equal number of people from each group. If you selected people randomly, you would get so few schizophrenic people in the sample that your study would be useless. This specific kind of of stratified sampling is referred to as oversampling because it makes a deliberate attempt to over-represent rare groups. Snowball sampling is a technique that is especially useful when sampling from a “hidden” or hard to access population, and is especially common in social sciences. For instance, suppose the researchers want to conduct an opinion poll among transgender people. The research team might only have contact details for a few trans folks, so the survey starts by asking them to participate (stage 1). At the end of the survey, the participants are asked to provide contact details for other people who might want to participate. In stage 2, those new contacts are surveyed. The process continues until the researchers have sufficient data. The big advantage to snowball sampling is that it gets you data in situations that might otherwise be impossible to get any. On the statistical side, the main disadvantage is that the sample is highly non-random, and non-random in ways that are difficult to address. On the real life side, the disadvantage is that the procedure can be unethical if not handled well, because hidden populations are often hidden for a reason. I chose transgender people as an example here to highlight this: if you weren’t careful you might end up outing people who don’t want to be outed (very, very bad form), and even if you don’t make that mistake it can still be intrusive to use people’s social networks to study them. It’s certainly very hard to get people’s informed consent before contacting them, yet in many cases the simple act of contacting them and saying “hey we want to study you” can be hurtful. Social networks are complex things, and just because you can use them to get data doesn’t always mean you should. Convenience sampling is more or less what it sounds like. The samples are chosen in a way that is convenient to the researcher, and not selected at random from the population of interest. Snowball sampling is one type of convenience sampling, but there are many others. A common example in psychology are studies that rely on undergraduate psychology students. These samples are generally non-random in two respects: firstly, reliance on undergraduate psychology students automatically means that your data are restricted to a single sub-population. Secondly, the students usually get to pick which studies they participate in, so the sample is a self selected subset of psychology students not a randomly selected subset. In real life, most studies are convenience samples of one form or another. This is sometimes a severe limitation, but not always. 5.1.3 How much does it matter if you don’t have a simple random sample? Okay, so real world data collection tends not to involve nice simple random samples. Does that matter? A little thought should make it clear to you that it can matter if your data are not a simple random sample: just think about the difference between Figures 5.1 and 5.2. However, it’s not quite as bad as it sounds. Some types of biased samples are entirely unproblematic. For instance, when using a stratified sampling technique you actually know what the bias is because you created it deliberately, often to increase the effectiveness of your study, and there are statistical techniques that you can use to adjust for the biases you’ve introduced (not covered in this book!). So in those situations it’s not a problem. More generally though, it’s important to remember that random sampling is a means to an end, not the end in itself. Let’s assume you’ve relied on a convenience sample, and as such you can assume it’s biased. A bias in your sampling method is only a problem if it causes you to draw the wrong conclusions. When viewed from that perspective, I’d argue that we don’t need the sample to be randomly generated in every respect: we only need it to be random with respect to the psychologically-relevant phenomenon of interest. Suppose I’m doing a study looking at working memory capacity. In study 1, I actually have the ability to sample randomly from all human beings currently alive, with one exception: I can only sample people born on a Monday. In study 2, I am able to sample randomly from the Dutch population. I want to generalize my results to the population of all living humans. Which study is better? The answer, obviously, is study 1. Why? Because we have no reason to think that being “born on a Monday” has any interesting relationship to working memory capacity. In contrast, I can think of several reasons why “being Dutch” might matter. The Netherlands is a wealthy, industrialized country with a very well-developed education system. People growing up in that system will have had life experiences much more similar to the experiences of the people who designed the tests for working memory capacity. This shared experience might easily translate into similar beliefs about how to “take a test,” a shared assumption about how psychological experimentation works, and so on. These things might actually matter. For instance, “test taking” style might have taught the Dutch participants how to direct their attention exclusively on fairly abstract test materials relative to people that haven’t grown up in a similar environment; leading to a misleading picture of what working memory capacity is. There are two points hidden in this discussion. Firstly, when designing your own studies, it’s important to think about what population you care about, and try hard to sample in a way that is appropriate to that population. In practice, you’re usually forced to put up with a “sample of convenience” (e.g., psychology lecturers sample psychology students because that’s the least expensive way to collect data, and our coffers aren’t exactly overflowing with gold), but if so you should at least spend some time thinking about what the dangers of this practice might be. Secondly, if you’re going to criticize someone else’s study because they’ve used a sample of convenience rather than laboriously sampling randomly from the entire human population, at least have the courtesy to offer a specific theory as to how this might have distorted the results. Remember, everyone in science is aware of this issue, and does what they can to alleviate it. Merely pointing out that “the study only included people from group BLAH” is entirely unhelpful, and borders on being insulting to the researchers, who are aware of the issue. They just don’t happen to be in possession of the infinite supply of time and money required to construct the perfect sample. In short, if you want to offer a responsible critique of the sampling process, then be helpful. Rehashing the blindingly obvious truisms that I’ve been rambling on about in this section isn’t helpful. 5.1.4 Population parameters and sample statistics Okay. Setting aside the thorny methodological issues associated with obtaining a random sample, let’s consider a slightly different issue. Up to this point we have been talking about populations the way a scientist might. To a psychologist, a population might be a group of people. To an ecologist, a population might be a group of bears. In most cases the populations that scientists care about are concrete things that actually exist in the real world. Statisticians, however, are a funny lot. On the one hand, they are interested in real world data and real science in the same way that scientists are. On the other hand, they also operate in the realm of pure abstraction in the way that mathematicians do. As a consequence, statistical theory tends to be a bit abstract in how a population is defined. In much the same way that psychological researchers operationalize our abstract theoretical ideas in terms of concrete measurements, statisticians operationalize the concept of a “population” in terms of mathematical objects that they know how to work with. You’ve already come across these objects: they’re called probability distributions (remember, the place where data comes from). The idea is quite simple. Let’s say we’re talking about IQ scores. To a psychologist, the population of interest is a group of actual humans who have IQ scores. A statistician “simplifies” this by operationally defining the population as the probability distribution depicted in Figure 5.4a. Figure 5.4: The population distribution of IQ scores (panel a) and two samples drawn randomly from it. In panel b we have a sample of 100 observations, and panel c we have a sample of 10,000 observations. IQ tests are designed so that the average IQ is 100, the standard deviation of IQ scores is 15, and the distribution of IQ scores is normal. These values are referred to as the population parameters because they are characteristics of the entire population. That is, we say that the population mean \\(\\mu\\) is 100, and the population standard deviation \\(\\sigma\\) is 15. Now suppose we collect some data. We select 100 people at random and administer an IQ test, getting a simple random sample from the population. The sample would consist of a collection of numbers like this: 106 101 98 80 74 ... 107 72 100 Each of these IQ scores is sampled from a normal distribution with mean 100 and standard deviation 15. So if I plot a histogram of the sample, I get something like the one shown in Figure 5.4b. As you can see, the histogram is roughly the right shape, but it’s a very crude approximation to the true population distribution shown in Figure 5.4a. The mean of the sample is fairly close to the population mean 100 but not identical. In this case, it turns out that the people in the sample have a mean IQ of 98.5, and the standard deviation of their IQ scores is 15.9. These sample statistics are properties of the data set, and although they are fairly similar to the true population values, they are not the same. In general, sample statistics are the things you can calculate from your data set, and the population parameters are the things you want to learn about. Later on in this chapter we’ll talk about how you can estimate population parameters using your sample statistics and how to work out how confident you are in your estimates but before we get to that there’s a few more ideas in sampling theory that you need to know about. 5.2 The law of large numbers We just looked at the results of one fictitious IQ experiment with a sample size of \\(N=100\\). The results were somewhat encouraging: the true population mean is 100, and the sample mean of 98.5 is a pretty reasonable approximation to it. In many scientific studies that level of precision is perfectly acceptable, but in other situations you need to be a lot more precise. If we want our sample statistics to be much closer to the population parameters, what can we do about it? The obvious answer is to collect more data. Suppose that we ran a much larger experiment, this time measuring the IQ’s of 10,000 people. We can simulate the results of this experiment using R, using the rnorm() function, which generates random numbers sampled from a normal distribution. For an experiment with a sample size of n = 10000, and a population with mean = 100 and sd = 15, R produces our fake IQ data using these commands: IQ &lt;- rnorm(n=10000, mean=100, sd=15) # generate 10000 IQ scores IQ &lt;- round(IQ) # round to nearest whole number Cool, we just generated 10,000 fake IQ scores, but 10,000 numbers is too many numbers to look at. We can look at the first 100 like this: print(IQ[1:100]) ## [1] 87 120 80 75 91 112 70 101 110 93 88 95 109 116 88 113 132 101 ## [19] 124 90 108 102 76 93 100 128 90 99 119 96 112 99 85 116 96 93 ## [37] 114 96 85 84 100 112 83 108 81 97 104 101 95 74 78 107 87 98 ## [55] 88 97 109 117 105 93 101 111 118 87 109 120 102 125 108 104 100 92 ## [73] 117 99 101 117 101 84 90 125 106 103 91 111 108 115 102 121 86 80 ## [91] 74 112 106 95 108 100 90 109 71 103 We can also compute the mean IQ using mean(IQ) and the standard deviation using sd(IQ), or draw a histogram. The histogram of this much larger sample is shown in Figure 5.4c. Even a moment’s inspections makes clear that the larger sample is a much better approximation to the true population distribution than the smaller one. This is reflected in the sample statistics: the mean IQ for the larger sample turns out to be 99.9, and the standard deviation is 15.1. These values are now very close to the true population. I feel a bit silly saying this, but the thing I want you to take away from this is that large samples generally give you better information. I feel silly saying it because it’s so bloody obvious that it shouldn’t need to be said. In fact, it’s such an obvious point that when Jacob Bernoulli – one of the founders of probability theory – formalized this idea back in 1713, he was kind of a jerk about it. Here’s how he described the fact that we all share this intuition: For even the most stupid of men, by some instinct of nature, by himself and without any instruction (which is a remarkable thing), is convinced that the more observations have been made, the less danger there is of wandering from one’s goal (see Stigler, 1986, p65). Okay, so the passage comes across as a bit condescending (not to mention sexist), but his main point is correct: it really does feel obvious that more data will give you better answers. The question is, why is this so? Not surprisingly, this intuition that we all share turns out to be correct, and statisticians refer to it as the law of large numbers. The law of large numbers is a mathematical law that applies to many different sample statistics, but the simplest way to think about it is as a law about averages. The sample mean is the most obvious example of a statistic that relies on averaging (because that’s what the mean is… an average), so let’s look at that. When applied to the sample mean, what the law of large numbers states is that as the sample gets larger, the sample mean tends to get closer to the true population mean. Or, to say it a little bit more precisely, as the sample size “approaches” infinity (written as \\(N \\rightarrow \\infty\\)) the sample mean approaches the population mean (\\(\\bar{X} \\rightarrow \\mu\\)). I don’t intend to subject you to a proof that the law of large numbers is true, but it’s one of the most important tools for statistical theory. The law of large numbers is the thing we can use to justify our belief that collecting more and more data will eventually lead us to the truth. For any particular data set, the sample statistics that we calculate from it will be wrong, but the law of large numbers tells us that if we keep collecting more data those sample statistics will tend to get closer and closer to the true population parameters. 5.3 Sampling distributions The law of large numbers is a very powerful tool, but it’s not going to be good enough to answer all our questions. Among other things, all it gives us is a “long run guarantee.” In the long run, if we were somehow able to collect an infinite amount of data, then the law of large numbers guarantees that our sample statistics will be correct. But as John Maynard Keynes famously argued in economics, a long run guarantee is of little use in real life: [The] long run is a misleading guide to current affairs. In the long run we are all dead. Economists set themselves too easy, too useless a task, if in tempestuous seasons they can only tell us, that when the storm is long past, the ocean is flat again. Keynes (1923, 80) As in economics, so too in psychology and statistics. It is not enough to know that we will eventually arrive at the right answer when calculating the sample mean. Knowing that an infinitely large sample will tell me the exact value of the population mean is cold comfort when my actual sample has a sample size of \\(N=100\\). In real life, then, we must know something about the behavior of the sample mean when it is calculated from a more modest sample! 5.3.1 Sampling distribution of the sample mean With this in mind, let’s abandon the idea that our studies will have sample sizes of 10000, and consider a very modest experiment indeed. This time around we’ll sample \\(N=5\\) people and measure their IQ scores. As before, I can simulate this experiment in R using the rnorm() function: &gt; IQ.1 &lt;- round( rnorm(n=5, mean=100, sd=15 )) &gt; IQ.1 [1] 90 82 94 99 110 The mean IQ in this sample turns out to be exactly 9518. Not surprisingly, this is much farther away from the population mean than the previous experiment (with a sample size of 10000). Now imagine that I decided to replicate the experiment. That is, I repeat the procedure as closely as possible: I randomly sample 5 new people and measure their IQ. Again, R allows me to simulate the results of this procedure: &gt; IQ.2 &lt;- round( rnorm(n=5, mean=100, sd=15 )) &gt; IQ.2 [1] 78 88 111 111 117 This time around, the mean IQ in my sample is 101. If I repeat the experiment 10 times I obtain the results shown in Table 5.1, and as you can see the sample mean varies from one replication to the next. Table 5.1: Ten replications of the IQ experiment, each with a sample size of \\(N=5\\). Replication Person.1 Person.2 Person.3 Person.4 Person.5 Sample.Mean Replication 1 90 82 94 99 110 95.0 Replication 2 78 88 111 111 117 101.0 Replication 3 111 122 91 98 86 101.6 Replication 4 98 96 119 99 107 103.8 Replication 5 105 113 103 103 98 104.4 Replication 6 81 89 93 85 114 92.4 Replication 7 100 93 108 98 133 106.4 Replication 8 107 100 105 117 85 102.8 Replication 9 86 119 108 73 116 100.4 Replication 10 95 126 112 120 76 105.8 Now suppose that I decided to keep going in this fashion, replicating this “five IQ scores” experiment over and over again. Every time I replicate the experiment I write down the sample mean. Over time, I’d be amassing a new data set, in which every experiment generates a single data point. The first 10 observations from my data set are the sample means listed in Table 5.1, so my data set starts out like this: 95.0 101.0 101.6 103.8 104.4 ... What if I continued like this for 10,000 replications, and then drew a histogram? Using the magical powers of R that’s exactly what I did, and you can see the results in Figure 5.5. As this picture illustrates, the average of 5 IQ scores is usually between 90 and 110. But more importantly, what it highlights is that if we replicate an experiment over and over again, what we end up with is a distribution of sample means! This distribution has a special name in statistics: it’s called the sampling distribution of the sample mean. Figure 5.5: The sampling distribution of the sample mean for the “five IQ scores experiment.” If you repeatedly sample 5 people at random and calculate their average IQ, you’ll almost certainly get a number between 80 and 120, even though there are quite a lot of individuals who have IQs above 120 or below 80. For comparison, the black line plots the population distribution of IQ scores. Sampling distributions are an important theoretical idea in inferential statistics, and they’re crucial for understanding the behaviour of small samples. For instance, when I ran the very first “five IQ scores” experiment, the sample mean turned out to be 95. What the sampling distribution in Figure 5.5 tells us, though, is that the “five IQ scores” experiment is not very accurate. If I repeat the experiment, the sampling distribution tells me that I can expect to see a sample mean anywhere between 80 and 120. 5.3.2 Sampling distributions exist for any sample statistic One thing to keep in mind when thinking about sampling distributions is that any sample statistic you might care to calculate has a sampling distribution. For example, suppose that each time I replicated the “five IQ scores” experiment I wrote down the largest IQ score in the experiment. This would give me a data set that started out like this: 110 117 122 119 113 ... Doing this over and over again would give me a very different sampling distribution, namely the sampling distribution of the maximum. The sampling distribution of the maximum of 5 IQ scores is shown in Figure 5.6. Not surprisingly, if you pick 5 people at random and then find the person with the highest IQ score, they’re going to have an above average IQ. Most of the time you’ll end up with someone whose IQ is measured in the 100 to 140 range. Figure 5.6: The sampling distribution of the maximum for the “five IQ scores experiment.” If you sample 5 people at random and select the one with the highest IQ score, you’ll probably see someone with an IQ between 100 and 140. 5.4 The central limit theorem At this point I hope you have a pretty good sense of what sampling distributions are, and in particular what the sampling distribution of the sample mean is. In this section I want to talk about how the sampling distribution of the sample mean changes as a function of sample size. Intuitively, you already know part of the answer: if you only have a few observations, the sample mean is likely to be quite inaccurate: if you replicate a small experiment and recalculate the mean you probably get a very different answer. In other words, the sampling distribution is quite wide. If you replicate a large experiment and recalculate the sample mean you’ll probably get a similar answer to the one you got last time, so the sampling distribution will be narrow(er). You can see this visually in Figure 5.7: the bigger the sample size, the narrower the sampling distribution gets. In the upper left corner of the Figure 5.7, our (fictitious) sample contained only a single observation, so the mean of each sample is just one person’s IQ score. As a consequence, the sampling distribution of the sample mean is of course identical to the population distribution of IQ scores. When we raise the sample size to 2, the mean of any one sample tends to be closer to the population mean than a one person’s IQ score, and so the histogram (i.e., the sampling distribution) is a bit narrower than the population distribution. By the time we raise the sample size to 10, we can see that the distribution of sample means tend to be fairly tightly clustered around the true population mean. Figure 5.7: An illustration of the how sampling distribution of the mean depends on sample size. In each panel, I generated 10,000 samples of IQ data, and calculated the mean IQ observed within each of these data sets. The histograms in these plots show the distribution of these means (i.e., the sampling distribution of the sample mean). Each individual IQ score was drawn from a normal distribution with mean 100 and standard deviation 15, which is shown as the solid black line). We can quantify this effect by calculating the standard deviation of the sampling distribution, which is referred to as the standard error. The standard error of a statistic is often denoted SE, and since we’re usually interested in the standard error of the sample mean, we often use the acronym SEM. As you can see just by looking at the picture, as the sample size \\(N\\) increases, the SEM decreases. Okay, so that’s one part of the story. However, there’s something I’ve been glossing over so far. All my examples up to this point have been based on the “IQ scores” experiments, and because IQ scores are roughly normally distributed, I’ve assumed that the population distribution is normal. What if it isn’t normal? What happens to the sampling distribution of the mean? The remarkable thing is this: no matter what shape your population distribution is, as \\(N\\) increases the sampling distribution of the mean starts to look more like a normal distribution. To give you a sense of this, I ran some simulations using R. To do this, I started with the “ramped” distribution shown in the upper left plot of Figure 5.8. As you can see by comparing the triangular shaped histogram to the bell curve plotted by the black line, the population distribution doesn’t look very much like a normal distribution at all. Next, I used R to simulate the results of a large number of experiments. In each experiment I took \\(N=2\\) samples from this distribution, and then calculated the sample mean. The upper right corner of Figure 5.8 plots the histogram of these sample means (i.e., the sampling distribution of the sample mean for \\(N=2\\)). This time, the histogram produces a \\(\\cap\\)-shaped distribution: it’s still not normal, but it’s a lot closer to the black line than the population distribution in the upper left corner. When I increase the sample size to \\(N=4\\), the sampling distribution of the mean is very close to normal, and by the time we reach a sample size of \\(N=8\\) it’s almost perfectly normal. In other words, as long as your sample size isn’t tiny, the sampling distribution of the sample mean will be approximately normal no matter what your population distribution looks like! Figure 5.8: A demonstration of the central limit theorem. In the upper left panel, we have a non-normal population distribution; the other panels show the sampling distribution of the sample mean for samples of size 2,4 and 8, for data drawn from the distribution in the upper left panel. As you can see, even though the original population distribution is non-normal, the sampling distribution of the sample mean becomes pretty close to normal by the time you have a sample of even 4 observations. On the basis of these figures, it seems like we have evidence for all of the following claims about the sampling distribution of the mean: The mean of the sampling distribution is the same as the mean of the population The standard deviation of the sampling distribution (i.e., the standard error) gets smaller as the sample size increases The shape of the sampling distribution becomes normal as the sample size increases As it happens, not only are all of these statements true, there is a very famous theorem in statistics that proves all three of them, known as the central limit theorem. Among other things, the central limit theorem tells us that if the population distribution has mean \\(\\mu\\) and standard deviation \\(\\sigma\\), then the sampling distribution of the sample mean also has mean \\(\\mu\\), and the standard error of its mean is: \\[ \\mbox{SEM} = \\frac{\\sigma}{ \\sqrt{N} } \\] Because we divide the population standard deviation \\(\\sigma\\) by the square root of the sample size \\(N\\), the SEM gets smaller as the sample size increases. It also tells us that the shape of the sampling distribution becomes normal.19 This result is useful for all sorts of things. It tells us why large experiments are more reliable than small ones, and because it gives us an explicit formula for the standard error it tells us how much more reliable a large experiment is. It tells us why the normal distribution is, well, normal. In real experiments, many of the things that we want to measure are actually averages of lots of different quantities (e.g., arguably, “general” intelligence as measured by IQ is an average of a large number of “specific” skills and abilities), and when that happens, the averaged quantity should follow a normal distribution. Because of this mathematical law, the normal distribution pops up over and over again in real data. 5.5 Estimating population parameters In all the IQ examples in the previous sections, we actually knew the population parameters ahead of time. As every undergraduate gets taught in their very first lecture on the measurement of intelligence, IQ scores are defined to have mean 100 and standard deviation 15. However, this is a bit of a lie. How do we know that IQ scores have a true population mean of 100? Well, we know this because the people who designed the tests have administered them to very large samples, and have then “rigged” the scoring rules so that their sample has mean 100. That’s not a bad thing of course: it’s an important part of designing a psychological measurement. However, it’s important to keep in mind that this theoretical mean of 100 only attaches to the population that the test designers used to design the tests. Good test designers will actually go to some lengths to provide “test norms” that can apply to lots of different populations (e.g., different age groups, nationalities etc). This is very handy, but of course almost every research project of interest involves looking at a different population of people to those used in the test norms. For instance, suppose you wanted to measure the effect of low level lead poisoning on cognitive functioning in Port Pirie, a South Australian industrial town with a lead smelter. Perhaps you decide that you want to compare IQ scores among people in Port Pirie to a comparable sample in Whyalla, a South Australian industrial town with a steel refinery.20 Regardless of which town you’re thinking about, it doesn’t make a lot of sense simply to assume that the true population mean IQ is 100. No-one has, to my knowledge, produced sensible norming data that can automatically be applied to South Australian industrial towns. We’re going to have to estimate the population parameters from a sample of data. So how do we do this? 5.5.1 Estimating the population mean Suppose we go to Port Pirie and 100 of the locals are kind enough to sit through an IQ test. The average IQ score among these people turns out to be \\(\\bar{X}=98.5\\). So what is the true mean IQ for the entire population of Port Pirie? Obviously, we don’t know the answer to that question. It could be \\(97.2\\), but if could also be \\(103.5\\). Our sampling isn’t exhaustive so we cannot give a definitive answer. Nevertheless if I was forced at gunpoint to give a “best guess” I’d have to say \\(98.5\\). That’s the essence of statistical estimation: giving a best guess. In this example, estimating the unknown poulation parameter is straightforward. I calculate the sample mean, and I use that as my estimate of the population mean. It’s pretty simple, and in the next section I’ll explain the statistical justification for this intuitive answer. However, for the moment what I want to do is make sure you recognise that the sample statistic and the estimate of the population parameter are conceptually different things. A sample statistic is a description of your data, whereas the estimate is a guess about the population. With that in mind, statisticians often different notation to refer to them. For instance, the true population mean is denoted by \\(\\mu\\), and we use \\(\\hat\\mu\\) (say: mu-hat) to refer to our estimate of the population mean. In contrast, the sample mean is denoted \\(\\bar{X}\\) (say:x-bar) or sometimes \\(m\\). However, in simple random samples, the estimate of the population mean is identical to the sample mean: if I observe a sample mean of \\(\\bar{X} = 98.5\\), then my estimate of the population mean is also \\(\\hat\\mu = 98.5\\). To help keep the notation clear, here’s a handy table: Symbol What is it? Do we know what it is? \\(\\bar{X}\\) Sample mean Yes - calculated from your sample \\(\\mu\\) True population mean Almost never known for sure \\(\\hat{\\mu}\\) Estimate of the population mean Yes - identical to the sample mean 5.5.2 Estimating the population standard deviation So far, estimation seems pretty simple, and you might be wondering why I forced you to read through all that stuff about sampling theory. In the case of the mean, our estimate of the population parameter (i.e. \\(\\hat\\mu\\)) turned out to identical to the corresponding sample statistic (i.e. \\(\\bar{X}\\)). However, that’s not always true. To see this, let’s have a think about how to construct an estimate of the population standard deviation, which we’ll denote \\(\\hat\\sigma\\). What shall we use as our estimate in this case? Your first thought might be that we could do the same thing we did when estimating the mean, and just use the sample statistic as our estimate. That’s almost the right thing to do, but not quite. Here’s why. Suppose I have a sample that contains a single observation. For this example, it helps to consider a sample where you have no intutions at all about what the true population values might be, so let’s use something completely fictitious. Suppose the observation in question measures the cromulence of my shoes. It turns out that my shoes have a cromulence of 20. So here’s my sample: 20 This is a perfectly legitimate sample, even if it does have a sample size of \\(N=1\\). It has a sample mean of 20, and because every observation in this sample is equal to the sample mean (obviously!) it has a sample standard deviation of 0. As a description of the sample this seems quite right: the sample contains a single observation and therefore there is no variation observed within the sample. A sample standard deviation of \\(s = 0\\) is the right answer here. But as an estimate of the population standard deviation, it feels completely insane, right? Admittedly, you and I don’t know anything at all about what “cromulence” is, but we know something about data: the only reason that we don’t see any variability in the sample is that the sample is too small to display any variation! So, if you have a sample size of \\(N=1\\), it feels like the right answer is just to say “no idea at all.” Notice that you don’t have the same intuition when it comes to the sample mean and the population mean. If forced to make a best guess about the population mean, it doesn’t feel completely insane to guess that the population mean is 20. Sure, you probably wouldn’t feel very confident in that guess, because you have only the one observation to work with, but it’s still the best guess you can make. Let’s extend this example a little. Suppose I now make a second observation. My data set now has \\(N=2\\) observations of the cromulence of shoes, and the complete sample now looks like this: 20, 22 This time around, our sample is just large enough for us to be able to observe some variability: two observations is the bare minimum number needed for any variability to be observed! For our new data set, the sample mean is \\(\\bar{X}=21\\), and the sample standard deviation is \\(s=1\\). What intuitions do we have about the population? Again, as far as the population mean goes, the best guess we can possibly make is the sample mean: if forced to guess, we’d probably guess that the population mean cromulence is 21. What about the standard deviation? This is a little more complicated. The sample standard deviation is only based on two observations, and if you’re at all like me you probably have the intuition that, with only two observations, we haven’t given the population “enough of a chance” to reveal its true variability to us. It’s not just that we suspect that the estimate is wrong: after all, with only two observations we expect it to be wrong to some degree. The worry is that the error is systematic. Specifically, we suspect that the sample standard deviation is likely to be smaller than the population standard deviation. This intuition feels right, but it would be nice to demonstrate this somehow. There are in fact mathematical proofs that confirm this intuition, but unless you have the right mathematical background they don’t help very much. Instead, what I’ll do is use R to simulate the results of some experiments. With that in mind, let’s return to our IQ studies. Suppose the true population mean IQ is 100 and the standard deviation is 15. I can use the rnorm() function to generate the the results of an experiment in which I measure \\(N=2\\) IQ scores, and calculate the sample standard deviation. If I do this over and over again, and plot a histogram of these sample standard deviations, what I have is the sampling distribution of the standard deviation. I’ve plotted this distribution in Figure 5.9. Even though the true population standard deviation is 15, the average of the sample standard deviations is only 8.5. Notice that this is a very different result to what we found in Figure 5.7 when we plotted the sampling distribution of the mean. If you look at that sampling distribution, what you see is that the population mean is 100, and the mean of the sampling distribution of sample means is also 100. Figure 5.9: The sampling distribution of the sample standard deviation for a “two IQ scores” experiment. The true population standard deviation is 15 (dashed line), but as you can see from the histogram, the vast majority of experiments will produce a much smaller sample standard deviation than this. On average, this experiment would produce a sample standard deviation of only 8.5, well below the true value! In other words, the sample standard deviation is a biased estimate of the population standard deviation. Now let’s extend the simulation. Instead of restricting ourselves to the situation where we have a sample size of \\(N=2\\), let’s repeat the exercise for sample sizes from 1 to 10. If we plot the average sample mean and average sample standard deviation as a function of sample size, you get the results shown in Figure 5.10. On the left hand side (panel a), I’ve plotted the average sample mean and on the right hand side (panel b), I’ve plotted the average standard deviation. The two plots are quite different: on average, the average sample mean is equal to the population mean. It is an unbiased estimator, which is essentially the reason why your best estimate for the population mean is the sample mean.21 The plot on the right is quite different: on average, the sample standard deviation \\(s\\) is smaller than the population standard deviation \\(\\sigma\\). It is a biased estimator. In other words, if we want to make a “best guess” \\(\\hat\\sigma\\) about the value of the population standard deviation \\(\\sigma\\), we should make sure our guess is a little bit larger than the sample standard deviation \\(s\\). Figure 5.10: An illustration of the fact that the sample mean is an unbiased estimator of the population mean (panel a), but the sample standard deviation is a biased estimator of the population standard deviation (panel b). To generate the figure, I generated 10,000 simulated data sets with 1 observation each, 10,000 more with 2 observations, and so on up to a sample size of 10. Each data set consisted of fake IQ data: that is, the data were normally distributed with a true population mean of 100 and standard deviation 15. On average, the sample means turn out to be 100, regardless of sample size (panel a). However, the sample standard deviations turn out to be systematically too small (panel b), especially for small sample sizes. The fix to this systematic bias turns out to be very simple. Here’s how it works. Before tackling the standard deviation, let’s look at the variance. If you recall from Section 2.6.3, the variance is defined to be the average of the squared deviations from the mean. That is: \\[ s^2 = \\frac{{\\sum_{i=1}^N} (X_i - \\bar{X})^2}{N} \\] However, the sample variance \\(s^2\\) is a biased estimator of the population variance \\(\\sigma^2\\). But as it turns out, we only need to make a tiny tweak to transform this into an unbiased estimator. All we have to do is divide by \\(N-1\\) rather than by \\(N\\). If we do that, we obtain the following formula: \\[ \\hat\\sigma^2 = \\frac{{\\sum_{i=1}^N} (X_i - \\bar{X})^2}{N-1} \\] This is an unbiased estimator of the population variance \\(\\sigma^2\\). Moreover, this finally answers the question we raised in Section 2.5.3.2 of the labs: why does R give us slightly different answers when we use the var() function than using the formula in Section 2.6.3? A similar story applies for the standard deviation. If we divide by \\(N-1\\) rather than \\(N\\), our estimate of the population standard deviation becomes: \\[ \\hat\\sigma = \\sqrt{\\frac{{\\sum_{i=1}^n} (x_i - \\bar{X})^2}{N-1}} \\] and when we use R’s built in standard deviation function sd(), what it’s doing is dividing by \\(n-1\\), not \\(N\\).22 One final point: in practice, a lot of people tend to refer to \\(\\hat{\\sigma}\\) (i.e., the formula where we divide by \\(N-1\\)) as the sample standard deviation. Technically, this is incorrect: the sample standard deviation should be equal to \\(s\\) (i.e., the formula where we divide by \\(N\\)). These aren’t the same thing, either conceptually or numerically. One is a property of the sample, the other is an estimated characteristic of the population. However, in almost every real life application, what we actually care about is the estimate of the population parameter, and so people always report \\(\\hat\\sigma\\) rather than \\(s\\). This is the right number to report, of course, it’s that people tend to get a little bit imprecise about terminology when they write it up, because “sample standard deviation” is shorter than “estimated population standard deviation.” It’s no big deal, and in practice I do the same thing everyone else does. Nevertheless, I think it’s important to keep the two concepts separate: it’s never a good idea to confuse “known properties of your sample” with “guesses about the population from which it came.” The moment you start thinking that \\(s\\) and \\(\\hat\\sigma\\) are the same thing, you start doing exactly that. To finish this section off, here’s another couple of tables to help keep things clear: Symbol What is it? Do we know what it is? \\(s\\) Sample standard deviation Yes - calculated from your sample \\(\\sigma\\) Population standard deviation Almost never known for sure \\(\\hat{\\sigma}\\) Estimate of the population standard deviation Yes - but not the same as the sample standard deviation \\(s^2\\) Sample variance Yes - calculated from your sample \\(\\sigma^2\\) Population variance Almost never known for sure \\(\\hat{\\sigma}^2\\) Estimate of the population variance Yes - but not the same as the sample variance 5.6 Estimating a confidence interval Statistics means never having to say you’re certain – Unknown origin Up to this point in this chapter, I’ve outlined the basics of sampling theory which statisticians rely on to make guesses about population parameters on the basis of a sample of data. As this discussion illustrates, one of the reasons we need all this sampling theory is that every data set leaves us with a some of uncertainty, so our estimates are never going to be perfectly accurate. The thing that has been missing from this discussion is an attempt to quantify the amount of uncertainty that attaches to our estimate. It’s not enough to be able guess that, say, the mean IQ of undergraduate students is 115 (yes, I just made that number up). We also want to be able to say something that expresses the degree of certainty that we have in our guess. For example, it would be nice to be able to say that there is a 95% chance that the true mean lies between 109 and 121. The name for this is a confidence interval for the mean. Armed with an understanding of sampling distributions, constructing a confidence interval for the mean is actually pretty easy. Here’s how it works. Suppose the true population mean is \\(\\mu\\) and the standard deviation is \\(\\sigma\\). I’ve just finished running my study that has \\(N\\) participants, and the mean IQ among those participants is \\(\\bar{X}\\). We know from our discussion of the central limit theorem (Section 5.4) that the sampling distribution of the mean is approximately normal. We also know from our discussion of the normal distribution last week (Section 4.5.3) that there is a 95% chance that a normally-distributed quantity will fall within two standard deviations of the true mean. To be more precise, we can use the qnorm() function to compute the 2.5th and 97.5th percentiles of the normal distribution qnorm( p = c(.025, .975) ) ## [1] -1.959964 1.959964 Okay, so I was slightly imprecise earlier on. The more correct answer is that there is a 95% chance that a normally-distributed quantity will fall within 1.96 standard deviations of the true mean. Next, recall that the standard deviation of the sampling distribution is referred to as the standard error, and the standard error of the mean is written as SEM. When we put all these pieces together, we learn that there is a 95% probability that the sample mean \\(\\bar{X}\\) that we have actually observed lies within 1.96 standard errors of the population mean. Mathematically, we can write this as: \\[ \\mu - \\left( 1.96 \\times \\mbox{SEM} \\right) \\ \\leq \\ \\bar{X}\\ \\leq \\ \\mu + \\left( 1.96 \\times \\mbox{SEM} \\right) \\] where the SEM is equal to \\(\\sigma / \\sqrt{N}\\), and we can be 95% confident that this is true. However, that’s not answering the question that we’re actually interested in. The equation above tells us what we should expect about the sample mean, given that we know what the population parameters are. What we want is to have this work the other way around: we want to know what we should believe about the population parameters, given that we have observed a particular sample. However, it’s not too difficult to do this. Using a little high school algebra, a sneaky way to rewrite our equation is like this: \\[ \\bar{X} - \\left( 1.96 \\times \\mbox{SEM} \\right) \\ \\leq \\ \\mu \\ \\leq \\ \\bar{X} + \\left( 1.96 \\times \\mbox{SEM}\\right) \\] What this is telling, is that the range of values has a 95% probability of containing the population mean \\(\\mu\\). We refer to this range as a 95% confidence interval, denoted \\(\\mbox{CI}_{95}\\). In short, as long as \\(N\\) is sufficiently large – large enough for us to believe that the sampling distribution of the mean is normal – then we can write this as our formula for the 95% confidence interval: \\[ \\mbox{CI}_{95} = \\bar{X} \\pm \\left( 1.96 \\times \\frac{\\sigma}{\\sqrt{N}} \\right) \\] Of course, there’s nothing special about the number 1.96: it just happens to be the multiplier you need to use if you want a 95% confidence interval. If I’d wanted a 70% confidence interval, I could have used the qnorm() function to calculate the 15th and 85th quantiles: qnorm( p = c(.15, .85) ) ## [1] -1.036433 1.036433 and so the formula for \\(\\mbox{CI}_{70}\\) would be the same as the formula for \\(\\mbox{CI}_{95}\\) except that we’d use 1.04 as our “magic number” rather than 1.96. 5.6.1 Degrees of freedom The formula that I’ve given above for the 95% confidence interval is approximately correct, but I glossed over an important detail in the discussion. Notice my formula requires you to use the standard error of the mean, SEM, which in turn requires you to use the true population standard deviation \\(\\sigma\\). Yet, in Section 5.5 I stressed the fact that we don’t actually know the true population parameters. Because we don’t know the true value of \\(\\sigma\\), we have to use an estimate of the population standard deviation \\(\\hat{\\sigma}\\) instead. This is pretty straightforward to do, but this has the consequence that we need to use the quantiles of the \\(t\\)-distribution rather than the normal distribution to calculate our magic number; and the answer depends on the sample size. When \\(N\\) is very large, we get pretty much the same value using qt() that we would if we used qnorm()… n &lt;- 10000 # suppose our sample size is 10,000 qt( p = .975, df = n-1) # calculate the 97.5th quantile of the t-dist ## [1] 1.960201 But when \\(N\\) is small, we get a much bigger number when we use the \\(t\\) distribution: n &lt;- 10 # suppose our sample size is 10 qt( p = .975, df = n-1) # calculate the 97.5th quantile of the t-dist ## [1] 2.262157 There’s nothing too mysterious about what’s happening here. Bigger values mean that the confidence interval is wider, indicating that we’re more uncertain about what the true value of \\(\\mu\\) actually is. When we use the \\(t\\) distribution instead of the normal distribution, we get bigger numbers, indicating that we have more uncertainty. And why do we have that extra uncertainty? Well, because our estimate of the population standard deviation \\(\\hat\\sigma\\) might be wrong! If it’s wrong, it implies that we’re a bit less sure about what our sampling distribution of the mean actually looks like… and this uncertainty ends up getting reflected in a wider confidence interval. The amount of uncertainty is informed by the degrees of freedom of our estimate. The degrees of freedom (df) of an estimate is the number of independent pieces of information on which the estimate is based. The degrees of freedom is both a concept, and a correction (as seen above). The concept is that if you estimate a property of numbers, and you use this estimate, you will be forcing some constraints on your numbers. To illustrate: let’s pick two random numbers: 51 and -3. I used my personal freedom to pick those two numbers. Now, if our three numbers are 51, -3, and x, and the mean of these three numbers is 2, there is only one solution to x: x has to be -42, otherwise the mean will not be 2. The degrees of freedom for these three numbers is \\(N-1 = 3-1= 2\\), because 2 of the numbers can be free, but the last number has no freedom, it becomes fixed after the first two are decided. Statisticians often apply degrees of freedom to their calculations. For example, when we calculate the standard deviation of a sample, we first calculate the mean of the sample. By estimating the mean, we are fixing an aspect of our sample, and so, our sample now has \\(N-1\\) degrees of freedom when we calculate the standard deviation. While this explains degrees of freedom as a concept, the why of it all will remain unanswered during this course. Maybe pursue a master in statistics if you are really interested in a more detailed explanation of degrees of freedom. I’m sorry. Degrees of freedom are important during this course when working with the \\(t\\)-distribution, which we will do more extensively in the next chapter. Simply put, in this course, the degrees of freedom are an additional parameter (like the mean and standard deviation) informing the shape of a \\(t\\) distribution. 5.6.2 Interpreting a confidence interval The hardest thing about confidence intervals is understanding what they mean. Whenever people first encounter confidence intervals, the first instinct is almost always to say that “there is a 95% probabaility that the true mean lies inside the confidence interval.” It’s simple, and it seems to capture the common sense idea of what it means to say that I am “95% confident.” Unfortunately, it’s not quite right. The intuitive definition relies very heavily on your own personal beliefs about the value of the population mean. I say that I am 95% confident because those are my beliefs. In everyday life that’s perfectly okay, but if you remember back to Section 4.3, you’ll notice that talking about personal belief and confidence is a Bayesian idea. Personally (speaking as a Bayesian) I have no problem with the idea that the phrase “95% probability” is allowed to refer to a personal belief. However, confidence intervals are not Bayesian tools. Like everything else in this chapter, confidence intervals are frequentist tools, and if you are going to use frequentist methods then it’s not appropriate to attach a Bayesian interpretation to them. If you use frequentist methods, you must adopt frequentist interpretations! Okay, so if that’s not the right answer, what is? Remember what we said about frequentist probability: the only way we are allowed to make “probability statements” is to talk about a sequence of events, and to count up the frequencies of different kinds of events. From that perspective, the interpretation of a 95% confidence interval must have something to do with replication. Specifically: if we replicated the experiment over and over again and computed a 95% confidence interval for each replication, then 95% of those intervals would contain the true mean. More generally, 95% of all confidence intervals constructed using this procedure should contain the true population mean. This idea is illustrated in Figure 5.11, which shows 50 confidence intervals constructed for a “measure 10 IQ scores” experiment (top panel) and another 50 confidence intervals for a “measure 25 IQ scores” experiment (bottom panel). A bit fortuitously, across the 100 replications that I simulated, it turned out that exactly 95 of them contained the true mean. Figure 5.11: 95% confidence intervals. The top (panel a) shows 50 simulated replications of an experiment in which we measure the IQs of 10 people. The dot marks the location of the sample mean, and the line shows the 95% confidence interval. In total 47 of the 50 confidence intervals do contain the true mean (i.e., 100), but the three intervals marked with asterisks do not. The lower graph (panel b) shows a similar simulation, but this time we simulate replications of an experiment that measures the IQs of 25 people. The critical difference here is that the Bayesian claim makes a probability statement about the population mean (i.e., it refers to our uncertainty about the population mean), which is not allowed under the frequentist interpretation of probability because you can’t “replicate” a population! In the frequentist claim, the population mean is fixed and no probabilistic claims can be made about it. Confidence intervals, however, are repeatable so we can replicate experiments. Therefore a frequentist is allowed to talk about the probability that the confidence interval (a random variable) contains the true mean; but is not allowed to talk about the probability that the true population mean (not a repeatable event) falls within the confidence interval. I know that this seems a little pedantic, but it does matter. It matters because the difference in interpretation leads to a difference in the mathematics. There is a Bayesian alternative to confidence intervals, known as credible intervals. In most situations credible intervals are quite similar to confidence intervals, but in other cases they are drastically different. If you are interested in learning more about Bayesian statistics, I can recommend Danielle Navarro’s book chapter about it in Learning statistics with R, or have a look at John Kruschke’s “Doing Bayesian Data Analysis”. 5.7 That’s it for this week Yay, rejoice. That wasn’t too bad, I hope! Like last week, there are additional practice materials for this week on SOWISO. The materials on SOWISO have a slightly different take on estimation and sampling theory, so have a look at them if want (or need) a different point of view. Mix of Matthew Crump &amp; Danielle Navarro. Code for figures from Emily Kothe’s Bookdown adaptation of Learning statistics with R↩︎ If you run the code above on your computer the results are going to be different due to the (pseudo) random nature of the rnorm() function↩︎ As usual, I’m being a bit sloppy here. The central limit theorem is a bit more general than this section implies. Like most introductory stats texts, I’ve discussed one situation where the central limit theorem holds: when you’re taking an average across lots of independent events drawn from the same distribution. However, the central limit theorem is much broader than this. There’s a whole class of things called “\\(U\\)-statistics” for instance, all of which satisfy the central limit theorem and therefore become normally distributed for large sample sizes. The mean is one such statistic, but it’s not the only one.↩︎ Please note that if you were actually interested in this question, you would need to be a lot more careful than I’m being here. You can’t just compare IQ scores in Whyalla to Port Pirie and assume that any differences are due to lead poisoning. Even if it were true that the only differences between the two towns corresponded to the different refineries (and it isn’t, not by a long shot), you need to account for the fact that people already believe that lead pollution causes cognitive deficits: if you recall back to Chapter 3, this means that there are different demand effects for the Port Pirie sample than for the Whyalla sample. In other words, you might end up with an illusory group difference in your data, caused by the fact that people think that there is a real difference. I find it pretty implausible to think that the locals wouldn’t be well aware of what you were trying to do if a bunch of researchers turned up in Port Pirie with lab coats and IQ tests, and even less plausible to think that a lot of people wouldn’t be pretty resentful of you for doing it. Those people won’t be as co-operative in the tests. Other people in Port Pirie might be more motivated to do well because they don’t want their home town to look bad. The motivational effects that would apply in Whyalla are likely to be weaker, because people don’t have any concept of “iron ore poisoning” in the same way that they have a concept for “lead poisoning.” Psychology is hard.↩︎ I should note that I’m hiding something here. Unbiasedness is a desirable characteristic for an estimator, but there are other things that matter besides bias. However, it’s beyond the scope of this book to discuss this in any detail. I just want to draw your attention to the fact that there’s some hidden complexity here.↩︎ Okay, I’m hiding something else here. In a bizarre and counterintuitive twist, since \\(\\hat\\sigma^2\\) is an unbiased estimator of \\(\\sigma^2\\), you’d assume that taking the square root would be fine, and \\(\\hat\\sigma\\) would be an unbiased estimator of \\(\\sigma\\). Right? Weirdly, it’s not. There’s actually a subtle, tiny bias in \\(\\hat\\sigma\\). This is just bizarre: \\(\\hat\\sigma^2\\) is and unbiased estimate of the population variance \\(\\sigma^2\\), but when you take the square root, it turns out that \\(\\hat\\sigma\\) is a biased estimator of the population standard deviation \\(\\sigma\\). Weird, weird, weird, right? So, why is \\(\\hat\\sigma\\) biased? The technical answer is “because non-linear transformations (e.g., the square root) don’t commute with expectation,” but that just sounds like gibberish to everyone who hasn’t taken a course in mathematical statistics. Fortunately, it doesn’t matter for practical purposes. The bias is small, and in real life everyone uses \\(\\hat\\sigma\\) and it works just fine. Sometimes mathematics is just annoying.↩︎ "],["week-6-hypothesis-testingweek6-hypothesistesting-1.html", " 6 Week 6: Hypothesis Testing23 6.1 A menagerie of hypotheses 6.2 Two types of errors 6.3 Test statistics and sampling distributions 6.4 Making decisions 6.5 The \\(p\\) value of a test 6.6 Running the hypothesis test in practice 6.7 Using hypothesis tests to compare means 6.8 The one-sample \\(z\\)-test 6.9 The one-sample \\(t\\)-test 6.10 The independent samples \\(t\\)-test 6.11 The paired-samples \\(t\\)-test 6.12 That’s it for this week…", " 6 Week 6: Hypothesis Testing23 The process of induction is the process of assuming the simplest law that can be made to harmonize with our experience. This process, however, has no logical foundation but only a psychological one. It is clear that there are no grounds for believing that the simplest course of events will really happen. It is an hypothesis that the sun will rise tomorrow: and this means that we do not know whether it will rise. – Ludwig Wittgenstein24 In the last chapter, we discussed estimation and sampling theory: “big ideas” in inferential statistics. It’s now time to put these ideas to practical use with hypothesis testing. In its most abstract form, hypothesis testing is really very simple: the researcher has some theory about the world and wants to determine whether or not the data actually support that theory. However, the details are messy, and most people find the theory of hypothesis testing to be a very frustrating part of statistics. The structure of this chapter is as follows. Firstly, I’ll describe how hypothesis testing works, in a fair amount of detail, using a simple running example to show you how a hypothesis test is “built.” I’ll try to avoid being too dogmatic while doing so, and focus instead on the underlying logic of the testing procedure. Then, we will apply this logic to something which is done very often in research: comparing means. 6.1 A menagerie of hypotheses Eventually we all succumb to madness. For me, that day will arrive once I’m finally promoted to full professor. Safely ensconced in my ivory tower, happily protected by tenure, I will finally be able to take leave of my senses (so to speak), and indulge in that most thoroughly unproductive line of psychological research: the search for extrasensory perception (ESP).25 Let’s suppose that this glorious day has come. My first study is a simple one, in which I seek to test whether clairvoyance (the claimed ability to gain information about an object, person, location, or physical event through extrasensory perception) exists. The participants in my study sit down at a table and are shown a card by an experimenter. The card is black on one side and white on the other. The experimenter takes the card away, and places it on a table in an adjacent room. The card is placed black side up or white side up completely at random, with the randomization occurring after the experimenter has left the room with the participant. A second experimenter comes in and asks the participant which side of the card is now facing upwards. The card is in the adjacent room, so the participant should have no way of knowing which side is facing upwards! Or do they…? This is purely a one-shot experiment. Each person sees only one card, and gives only one answer; and at no stage is the participant actually in contact with someone who knows the right answer. My data set, therefore, is very simple. I have asked the question of \\(n\\) people, and some number \\(X\\) of these people have given the correct response. To make things concrete, let’s suppose that I have tested \\(n = 100\\) people, and \\(X = 62\\) of these got the answer right… a surprisingly large number, we’d expect approximately 50 correct answers, but is it large enough for me to feel safe in claiming I’ve found evidence for extrasensory perception? This is the situation where hypothesis testing comes in useful. However, before we talk about how to test hypotheses, we need to be clear about what we mean by hypotheses. 6.1.1 Research hypotheses versus statistical hypotheses The first distinction that you need to keep clear in your mind is between research hypotheses and statistical hypotheses. In my ESP study, my overall scientific goal is to demonstrate that clairvoyance exists. In this situation, I have a clear research goal: I am hoping to discover evidence for ESP. In other situations I might actually be a lot more neutral than that, so I might say that my research goal is to determine whether or not clairvoyance exists. Regardless of how I want to portray myself, the basic point that I’m trying to convey here is that a research hypothesis involves making a substantive, testable scientific claim… if you are a psychologist, then your research hypotheses are fundamentally about psychological constructs. Any of the following would count as research hypotheses: Listening to music reduces your ability to pay attention to other things. This is a claim about the causal relationship between two psychologically meaningful concepts (listening to music and paying attention to things), so it’s a perfectly reasonable research hypothesis. Intelligence is related to personality. Like the last one, this is a relational claim about two psychological constructs (intelligence and personality), but the claim is weaker: correlation is not causation. Intelligence is speed of information processing. This hypothesis has a quite different character: it’s not actually a relational claim at all. It’s an ontological claim about the fundamental character of intelligence (and I’m pretty sure it’s wrong). It’s worth expanding on the last research hypothesis actually. It’s usually easier to think about how to construct experiments to test research hypotheses of the form “does X affect Y?” than it is to address claims like “what is X?” And in practice, what usually happens is that you find ways of testing relational claims that follow from your ontological ones. For instance, if I believe that intelligence is speed of information processing in the brain, my experiments will often involve looking for relationships between measures of intelligence and measures of speed. As a consequence, most everyday research questions do tend to be relational in nature, but they’re almost always motivated by deeper ontological questions about the state of nature. Notice that in practice, my research hypotheses could overlap a lot. My ultimate goal in the ESP experiment might be to test an ontological claim like “ESP exists,” but I might operationally restrict myself to a narrower hypothesis like “Some people can ‘see’ objects in a clairvoyant fashion.” As you can see, research hypotheses can be somewhat messy at times; and ultimately they are scientific claims. Statistical hypotheses are neither of these two things. Statistical hypotheses must be mathematically precise, and they must correspond to specific claims about the characteristics of the data generating mechanism (i.e., the “population”). Even so, the intent is that statistical hypotheses bear a clear relationship to the substantive research hypotheses that you care about! For instance, in my ESP study my research hypothesis is that some people are able to see through walls or whatever. What I want to do is to “map” this onto a statement about how the data were generated. So let’s think about what that statement would be. The quantity that I’m interested in within the experiment is \\(P(\\mbox{correct})\\), the true-but-unknown probability with which the participants in my experiment answer the question correctly. Let’s use the Greek letter \\(\\theta\\) (theta) to refer to this probability. Here are four different statistical hypotheses: If ESP doesn’t exist and if my experiment is well designed, then my participants are just guessing. So I should expect them to get it right half of the time and so my statistical hypothesis is that the true probability of choosing correctly is \\(\\theta = 0.5\\). Alternatively, suppose ESP does exist and participants can see the card. If that’s true, people will perform better than chance. The statistical hypothesis would be that \\(\\theta &gt; 0.5\\). A third possibility is that ESP does exist, but the colors are all reversed and people don’t realise it (okay, that’s wacky, but you never know…). If that’s how it works then you’d expect people’s performance to be below chance. This would correspond to a statistical hypothesis that \\(\\theta &lt; 0.5\\). Finally, suppose ESP exists, but I have no idea whether people are seeing the right color or the wrong one. In that case, the only claim I could make about the data would be that the probability of making the correct answer is not equal to 50. This corresponds to the statistical hypothesis that \\(\\theta \\neq 0.5\\). All of these are legitimate examples of a statistical hypothesis because they are statements about a population parameter and are meaningfully related to my experiment. What this discussion makes clear, I hope, is that when attempting to construct a statistical hypothesis test the researcher actually has two quite distinct hypotheses to consider. First, he or she has a research hypothesis (a claim about something), and this corresponds to a statistical hypothesis (a claim about the data generating population). In my ESP example, these might be: My research hypothesis My statistical hypothesis ESP exists \\(\\theta \\neq 0.5\\) The key thing to recognise is this: a statistical hypothesis test is a test of the statistical hypothesis, not the research hypothesis. If your study is badly designed, then the link between your research hypothesis and your statistical hypothesis is broken. To give a silly example, suppose that my ESP study was conducted in a situation where the participant can actually see the card reflected in a window; if that happens, I would be able to find very strong evidence that \\(\\theta \\neq 0.5\\), but this would tell us nothing about whether “ESP exists.” 6.1.2 Null hypotheses and alternative hypotheses So far, so good. I have a research hypothesis that corresponds to what I want to believe about the world, and I can map it onto a statistical hypothesis that corresponds to what I want to believe about how the data were generated. It’s at this point that things get somewhat counterintuitive for a lot of people. Because what I’m about to do is invent a new statistical hypothesis (the “null” hypothesis, \\(H_0\\)) that corresponds to the exact opposite of what I want to believe, and then focus exclusively on that, almost to the neglect of the thing I’m actually interested in (the “alternative” hypothesis: \\(H_1\\)). In our ESP example, the null hypothesis is that \\(\\theta = 0.5\\), since that’s what we’d expect if ESP didn’t exist. My hope, of course, is that ESP is totally real, and so the alternative to this null hypothesis is \\(\\theta \\neq 0.5\\). In essence, what we’re doing here is dividing up the possible values of \\(\\theta\\) into two groups: those values that I really hope aren’t true (the null), and those values that I’d be happy with if they turn out to be right (the alternative). Having done so, the important thing to recognise is that the goal of a hypothesis test is not to show that the alternative hypothesis is true; the goal is to show that the null hypothesis is false. Most people find this pretty weird. The best way to think about it, in my experience, is to imagine that a hypothesis test is a criminal trial: the trial of the null hypothesis. The null hypothesis is the defendant, the researcher is the prosecutor, and the statistical test itself is the judge. Just like a criminal trial, there is a presumption of innocence: the null hypothesis is deemed to be true unless you, the researcher, can prove beyond a reasonable doubt that it is false. You are free to design your experiment however you like (within reason, obviously!), and your goal when doing so is to maximise the chance that the data will yield a conviction… for the crime of being false. The catch is that the statistical test sets the rules of the trial, and those rules are designed to protect the null hypothesis – specifically to ensure that if the null hypothesis is actually true, the chances of a false conviction are guaranteed to be low. This is pretty important: after all, the null hypothesis doesn’t get a lawyer. And given that the researcher is trying desperately to prove it to be false, someone has to protect it. 6.2 Two types of errors Before going into details about how a statistical test is constructed, it’s useful to understand the philosophy behind it. I hinted at it when pointing out the similarity between a null hypothesis test and a criminal trial, but I should now be explicit. Ideally, we would like to construct our test so that we never make any errors. Unfortunately, since the world is messy, this is never possible. Sometimes you’re just really unlucky: for instance, suppose you flip a coin 10 times in a row and it comes up heads all 10 times. That feels like very strong evidence that the coin is biased, but of course there’s a 1 in 1024 chance that this would happen even if the coin was totally fair26. In other words, in real life we always have to accept that there’s a chance that we did the wrong thing. As a consequence, the goal behind statistical hypothesis testing is not to eliminate errors, but to minimise them. At this point, we need to be a bit more precise about what we mean by “errors.” Firstly, let’s state the obvious: it is either the case that the null hypothesis is true, or it is false; and our test will either reject the null hypothesis or retain it.27 So, as the table below illustrates, after we run the test and make our choice, one of four things might have happened: retain \\(H_0\\) reject \\(H_0\\) \\(H_0\\) is true correct decision error (type I) \\(H_0\\) is false error (type II) correct decision As a consequence there are actually two different types of error here. If we reject a null hypothesis that is actually true, then we have made a type I error. On the other hand, if we retain the null hypothesis when it is in fact false, then we have made a type II error. Remember how I said that statistical testing was kind of like a criminal trial? Well, I meant it. A criminal trial requires that you establish “beyond a reasonable doubt” that the defendant did it. All of the evidentiary rules are (in theory, at least) designed to ensure that there’s (almost) no chance of wrongfully convicting an innocent defendant. The trial is designed to protect the rights of a defendant: as the English jurist William Blackstone famously said, it is “better that ten guilty persons escape than that one innocent suffer.” In other words, a criminal trial doesn’t treat the two types of error in the same way… punishing the innocent is deemed to be much worse than letting the guilty go free. A statistical test is pretty much the same: the single most important design principle of the test is to control the probability of a type I error, to keep it below some fixed probability. This probability, which is denoted \\(\\alpha\\), is called the significance level of the test. And I’ll say it again, because it is so central to the whole set-up… a hypothesis test is said to have significance level \\(\\alpha\\) if the type I error rate is no larger than \\(\\alpha\\). So, what about the type II error rate? Well, we’d also like to keep those under control too, and we denote this probability by \\(\\beta\\). However, it’s much more common to refer to the power of the test, which is the probability with which we reject a null hypothesis when it really is false, which is \\(1-\\beta\\). To help keep this straight, here’s the same table again, but with the relevant numbers added: retain \\(H_0\\) reject \\(H_0\\) \\(H_0\\) is true \\(1-\\alpha\\) (probability of correct retention) \\(\\alpha\\) (type I error rate) \\(H_0\\) is false \\(\\beta\\) (type II error rate) \\(1-\\beta\\) (power of the test) A “powerful” hypothesis test is one that has a small value of \\(\\beta\\), while still keeping \\(\\alpha\\) fixed at some (small) desired level. By convention, scientists mostly make use of three different \\(\\alpha\\) levels: \\(.05\\), \\(.01\\) and \\(.001\\). Notice the asymmetry here… the tests are designed to ensure that the \\(\\alpha\\) level is kept small, but there’s no corresponding guarantee regarding \\(\\beta\\). We’d certainly like the type II error rate to be small, and we try to design tests that keep it small, but this is very much secondary to the overwhelming need to control the type I error rate. As Blackstone might have said if he were a statistician, it is “better to retain 10 false null hypotheses than to reject a single true one.” To be honest, I don’t know that I agree with this philosophy – there are situations where I think it makes sense, and situations where I think it doesn’t – but that’s neither here nor there. It’s how the tests are built. 6.3 Test statistics and sampling distributions At this point we need to start talking specifics about how a hypothesis test is constructed. To that end, let’s return to the ESP example. Let’s ignore the actual data that we obtained, for the moment, and think about the structure of the experiment. Regardless of what the actual numbers are, the form of the data is that \\(X\\) out of \\(N\\) people correctly identified the colour of the hidden card. Moreover, let’s suppose for the moment that the null hypothesis really is true: ESP doesn’t exist, and the true probability that anyone picks the correct colour is exactly \\(\\theta = 0.5\\). What would we expect the data to look like? Well, obviously, we’d expect the proportion of people who make the correct response to be pretty close to 50%. Or, to phrase this in more mathematical terms, we’d say that \\(X/N\\) is approximately \\(0.5\\). Of course, we wouldn’t expect this fraction to be exactly 0.5: if, for example we tested \\(N=100\\) people, and \\(X = 53\\) of them got the question right, we’d probably be forced to concede that the data are quite consistent with the null hypothesis. On the other hand, if \\(X = 99\\) of our participants got the question right, then we’d feel pretty confident that the null hypothesis is wrong. Similarly, if only \\(X=3\\) people got the answer right, we’d be similarly confident that the null was wrong. Let’s be a little more technical about this: we have a quantity \\(X\\) that we can calculate by looking at our data; after looking at the value of \\(X\\), we make a decision about whether to believe that the null hypothesis is correct, or to reject the null hypothesis in favour of the alternative. The name for this thing that we calculate to guide our choices is a test statistic. Having chosen a test statistic, the next step is to state precisely which values of the test statistic would cause to reject the null hypothesis, and which values would cause us to keep it. In order to do so, we need to determine what the sampling distribution of the test statistic would be if the null hypothesis were actually true (we talked about sampling distributions earlier in Section 5.3). Why do we need this? Because this distribution tells us exactly what values of \\(X\\) our null hypothesis would lead us to expect. And therefore, we can use this distribution as a tool for assessing how closely the null hypothesis agrees with our data. Figure 6.1: The sampling distribution for our test statistic \\(X\\) when the null hypothesis is true. For our ESP scenario, this is a binomial distribution. Not surprisingly, since the null hypothesis says that the probability of a correct response is \\(\\theta = .5\\), the sampling distribution says that the most likely value is 50 (our of 100) correct responses. Most of the probability mass lies between 40 and 60. How do we actually determine the sampling distribution of the test statistic? For a lot of hypothesis tests this step is actually quite complicated, but fortunately for us, our ESP example provides us with one of the easiest cases. Our population parameter \\(\\theta\\) is just the overall probability that people respond correctly when asked the question, and our test statistic \\(X\\) is the count of the number of people who did so, out of a sample size of \\(N\\). We’ve seen a distribution like this before, in Section 4.5.1: that’s exactly what the binomial distribution describes! So, to use the notation and terminology that I introduced in that section, we would say that the null hypothesis predicts that \\(X\\) is binomially distributed, which is written \\[ X \\sim \\mbox{Binomial}(\\theta,N) \\] Since the null hypothesis states that \\(\\theta = 0.5\\) and our experiment has \\(N=100\\) people, we have the sampling distribution we need. This sampling distribution is plotted in Figure 6.1. No surprises really: the null hypothesis says that \\(X=50\\) is the most likely outcome, and it says that we’re almost certain to see somewhere between 40 and 60 correct responses. 6.4 Making decisions Okay, we’re very close to being finished. We’ve constructed a test statistic (\\(X\\)), and we chose this test statistic in such a way that we’re pretty confident that if \\(X\\) is close to \\(N/2\\) then we should retain the null, and if not we should reject it. The question that remains is this: exactly which values of the test statistic should we associate with the null hypothesis, and which exactly values go with the alternative hypothesis? In my ESP study, for example, I’ve observed a value of \\(X=62\\). What decision should I make? Should I choose to believe the null hypothesis, or the alternative hypothesis? 6.4.1 Critical regions and critical values To answer this question, we need to introduce the concept of a critical region for the test statistic \\(X\\). The critical region of the test corresponds to those values of \\(X\\) that would lead us to reject null hypothesis (which is why the critical region is also sometimes called the rejection region). How do we find this critical region? Well, let’s consider what we know: \\(X\\) should be very big or very small in order to reject the null hypothesis. If the null hypothesis is true, the sampling distribution of \\(X\\) is Binomial\\((0.5, N)\\). If \\(\\alpha =.05\\), the critical region must cover 5% of this sampling distribution. It’s important to make sure you understand this last point: the critical region corresponds to those values of \\(X\\) for which we would reject the null hypothesis, and the sampling distribution in question describes the probability that we would obtain a particular value of \\(X\\) if the null hypothesis were actually true. Now, let’s suppose that we chose a critical region that covers 20% of the sampling distribution, and suppose that the null hypothesis is actually true. What would be the probability of incorrectly rejecting the null? The answer is of course 20%. And therefore, we would have built a test that had an \\(\\alpha\\) level of \\(0.2\\). If we want \\(\\alpha = .05\\), the critical region is only allowed to cover 5% of the sampling distribution of our test statistic. Figure 6.2: The critical region associated with the hypothesis test for the ESP study, for a hypothesis test with a significance level of \\(\\alpha = .05\\). The plot itself shows the sampling distribution of \\(X\\) under the null hypothesis: the grey bars correspond to those values of \\(X\\) for which we would retain the null hypothesis. The blue bars show the critical region: those values of \\(X\\) for which we would reject the null. Because the alternative hypothesis is two sided (i.e., allows both \\(\\theta &lt;.5\\) and \\(\\theta &gt;.5\\)), the critical region covers both tails of the distribution. To ensure an \\(\\alpha\\) level of \\(.05\\), we need to ensure that each of the two regions encompasses 2.5% of the sampling distribution. As it turns out, those three things uniquely solve the problem: our critical region consists of the most extreme values, known as the tails of the distribution. This is illustrated in Figure 6.2. As it turns out, if we want \\(\\alpha = .05\\), then our critical regions correspond to \\(X \\leq 40\\) and \\(X \\geq 60\\).28 That is, if the number of people saying “true” is between 41 and 59, then we should retain the null hypothesis. If the number is between 0 to 40 or between 60 to 100, then we should reject the null hypothesis. The numbers 40 and 60 are often referred to as the critical values, since they define the edges of the critical region. At this point, our hypothesis test is essentially complete: (1) we choose an \\(\\alpha\\) level (e.g., \\(\\alpha = .05\\), (2) come up with some test statistic (e.g., \\(X\\)) that does a good job (in some meaningful sense) of comparing \\(H_0\\) to \\(H_1\\), (3) figure out the sampling distribution of the test statistic on the assumption that the null hypothesis is true (in this case, binomial) and then (4) calculate the critical region that produces an appropriate \\(\\alpha\\) level (0-40 and 60-100). All that we have to do now is calculate the value of the test statistic for the real data (e.g., \\(X = 62\\)) and then compare it to the critical values to make our decision. Since 62 is greater than the critical value of 60, we would reject the null hypothesis. Or, to phrase it slightly differently, we say that the test has produced a significant result. 6.4.2 A note on statistical “significance” Like other occult techniques of divination, the statistical method has a private jargon deliberately contrived to obscure its methods from non-practitioners. – Attributed to G. O. Ashley29 A very brief digression is in order at this point, regarding the word “significant.” The concept of statistical significance is actually a very simple one, but has a very unfortunate name. If the data allow us to reject the null hypothesis, we say that “the result is statistically significant,” which is often shortened to “the result is significant.” This terminology is rather old, and dates back to a time when “significant” just meant something like “indicated,” rather than its modern meaning, which is much closer to “important.” As a result, a lot of modern readers get very confused when they start learning statistics, because they think that a “significant result” must be an important one. It doesn’t mean that at all. All that “statistically significant” means is that the data allowed us to reject a null hypothesis. Whether or not the result is actually important in the real world is a very different question, and depends on all sorts of other things. 6.4.3 The difference between one sided and two sided tests There’s one more thing I want to point out about the hypothesis test that I’ve just constructed. If we take a moment to think about the statistical hypotheses I’ve been using, \\[ \\begin{array}{cc} H_0 : &amp; \\theta = .5 \\\\ H_1 : &amp; \\theta \\neq .5 \\end{array} \\] we notice that the alternative hypothesis covers both the possibility that \\(\\theta &lt; .5\\) and the possibility that \\(\\theta &gt; .5\\). This makes sense if I really think that ESP could produce better-than-chance performance or worse-than-chance performance (and there are some people who think that). In statistical language, this is an example of a two-sided test. It’s called this because the alternative hypothesis covers the area on both “sides” of the null hypothesis, and as a consequence the critical region of the test covers both tails of the sampling distribution (2.5% on either side if \\(\\alpha =.05\\)), as illustrated earlier in Figure 6.2. However, that’s not the only possibility. It might be the case, for example, that I’m only willing to believe in ESP if it produces better than chance performance. If so, then my alternative hypothesis would only covers the possibility that \\(\\theta &gt; .5\\), and as a consequence the null hypothesis now becomes \\(\\theta \\leq .5\\): \\[ \\begin{array}{cc} H_0 : &amp; \\theta \\leq .5 \\\\ H_1 : &amp; \\theta &gt; .5 \\end{array} \\] When this happens, we have what’s called a one-sided test, and when this happens the critical region only covers one tail of the sampling distribution. This is illustrated in Figure 6.3. Figure 6.3: The critical region for a one sided test. In this case, the alternative hypothesis is that \\(\\theta &gt; .05\\), so we would only reject the null hypothesis for large values of \\(X\\). As a consequence, the critical region only covers the upper tail of the sampling distribution; specifically the upper 5% of the distribution. Contrast this to the two-sided version earlier) 6.5 The \\(p\\) value of a test In one sense, our hypothesis test is complete; we’ve constructed a test statistic, figured out its sampling distribution if the null hypothesis is true, and then constructed the critical region for the test. Nevertheless, I’ve actually omitted the most important number of all: the \\(p\\) value. It is to this topic that we now turn. There are actually different ways of interpreting a \\(p\\) value, that reflect very different ways of thinking about hypothesis tests. We will stick to interpreting a \\(p\\) value as is done in most introductory textbooks, but please be aware this is not the only way of thinking about \\(p\\) values. In fact, how the \\(p\\) value is used in practice is a mix of several school of thoughts, which makes the whole thing kind of a mess, but it’s a mess we have to deal with. 6.5.1 The probability of extreme data This definition of the \\(p\\)-value comes from Sir Ronald Fisher (yes, him again) and is the one that you tend to see in most introductory statistics textbooks. Notice how, when I constructed the critical region, it corresponded to the tails (i.e., extreme values) of the sampling distribution? That’s not a coincidence: almost all “good” tests have this characteristic (good in the sense of minimising our type II error rate, \\(\\beta\\)). The reason for that is that a good critical region almost always corresponds to those values of the test statistic that are least likely to be observed if the null hypothesis is true. If this rule is true, then we can define the \\(p\\)-value as the probability that we would have observed a test statistic that is at least as extreme as the one we actually did get. In other words, if the data are extremely implausible according to the null hypothesis, then the null hypothesis is probably wrong. 6.5.2 A common mistake Unfortunately, there is an explanation of \\(p\\)-values that people sometimes give, especially when they’re first learning statistics, and it is absolutely and completely wrong. This mistaken approach is to refer to the \\(p\\) value as “the probability that the null hypothesis is true.” It’s an intuitively appealing way to think, but it’s wrong in two key respects: (1) null hypothesis testing is a frequentist tool, and the frequentist approach to probability does not allow you to assign probabilities to the null hypothesis… according to this view of probability, the null hypothesis is either true or it is not; it cannot have a “5% chance” of being true. (2) even within the Bayesian approach, which does let you assign probabilities to hypotheses, the \\(p\\) value would not correspond to the probability that the null is true; this interpretation is entirely inconsistent with the mathematics of how the \\(p\\) value is calculated. Put bluntly, despite the intuitive appeal of thinking this way, there is no justification for interpreting a \\(p\\) value this way. Never do it. 6.6 Running the hypothesis test in practice At this point some of you might be wondering if the running example we’ve been using is a “real” hypothesis test, or just a toy example that I made up. It’s real. I built the test from first principles, thinking that it was the simplest possible problem that you might ever encounter in real life. The test actually exists and is called the binomial test. It’s implemented by an R function called binom.test(). To test the null hypothesis that the response probability is 0.5 (p = .5),30 using data in which x = 62 of n = 100 people made the correct response, here’s how to do it in R: binom.test( x=62, n=100, p=.5 ) ## ## Exact binomial test ## ## data: 62 and 100 ## number of successes = 62, number of trials = 100, p-value = 0.02098 ## alternative hypothesis: true probability of success is not equal to 0.5 ## 95 percent confidence interval: ## 0.5174607 0.7152325 ## sample estimates: ## probability of success ## 0.62 Right now, this output looks pretty unfamiliar to you, but you can see that it’s telling you more or less the right things. Specifically, the \\(p\\)-value of 0.02 is less than the usual choice of \\(\\alpha = .05\\), so you can reject the null. 6.7 Using hypothesis tests to compare means The running example we’ve used until now was exactly that: an example to explain the foundations of hypothesis testing, but limited in scope. The outcome variable was binomial: we counted the number of times participants successfully “sensed” the color of the card. However, when conducting research, you’re more likely to find yourself in a situation where your outcome variable is continuous, and what you’re interested in is whether the average value of the outcome variable is higher in one group or another. For instance, a psychologist might want to know if anxiety levels are higher among parents than non-parents, or if working memory capacity is reduced by listening to music (relative to not listening to music). In a medical context, we might want to know if a new drug increases or decreases blood pressure. An agricultural scientist might want to know whether adding phosphorus to Australian native plants will kill them. In all these situations, our outcome variable is a fairly continuous, interval or ratio scale variable; and our predictor is a binary “grouping” variable. In other words, we want to compare the means of the two groups. The standard answer to the problem of comparing means is to use something called a \\(t\\)-test, of which there are several varieties depending on exactly what question you want to solve. As a consequence, the majority of the rest of this chapter focuses on different types of the \\(t\\)-test: one sample \\(t\\)-tests are discussed in Section 6.9, independent samples \\(t\\)-tests are discussed in Section 6.10.2, and paired samples \\(t\\)-tests are discussed in Section 6.11. The later sections of the chapter focus on the assumptions of the \\(t\\)-tests, and possible remedies if they are violated. However, before discussing any of these useful things, we’ll start with a discussion of the \\(z\\)-test. 6.8 The one-sample \\(z\\)-test In this section I’ll describe one of the most useless tests in all of statistics: the \\(z\\)-test. Seriously – this test is almost never used in real life. Its only real purpose is that, when teaching statistics, it’s a very convenient stepping stone along the way towards the \\(t\\)-test, which is probably the most (over)used tool in all statistics. 6.8.1 The inference problem that the test addresses To introduce the idea behind the \\(z\\)-test, let’s use a simple example. A friend of mine, Dr Zeppo, grades his introductory statistics class on a curve. Let’s suppose that the average grade in his class is 67.5, and the standard deviation is 9.5. Of his many hundreds of students, it turns out that 20 of them also take psychology classes. Out of curiosity, I find myself wondering: do the psychology students tend to get the same grades as everyone else (i.e., mean 67.5) or do they tend to score higher or lower? He emails me their grades and I load them into R: grades &lt;- c(50, 60, 60, 64, 66, 66, 67, 69, 70, 74, 76, 76, 77, 79, 79, 79, 81, 82, 82, 89) and calculate the mean: mean(grades) ## [1] 72.3 Hm. It might be that the psychology students are scoring a bit higher than normal: that sample mean of \\(\\bar{x} = 72.3\\) is a fair bit higher than the hypothesised population mean of \\(\\mu = 67.5\\), but on the other hand, a sample size of \\(N = 20\\) isn’t all that big. Maybe it’s pure chance. To answer the question, it helps to be able to write down what it is that I think I know. Firstly, I know that the sample mean is \\(\\bar{X} = 72.3\\). If I’m willing to assume that the psychology students have the same standard deviation as the rest of the class then I can say that the population standard deviation is \\(\\sigma = 9.5\\). I’ll also assume that the psychology student grades are normally distributed. Next, it helps to be clear about what I want to learn from the data. In this case, my research hypothesis relates to the population mean \\(\\mu\\) for the psychology student grades, which is unknown. Specifically, I want to know if \\(\\mu = 67.5\\) or not. Given that this is what I know, can we devise a hypothesis test to solve our problem? The data, along with the hypothesised distribution from which they are thought to arise, are shown in Figure 6.4. Not entirely obvious what the right answer is, is it? For this, we are going to need some statistics. Figure 6.4: The theoretical distribution (solid line) from which the psychology student grades (blue bars) are supposed to have been generated. 6.8.2 Constructing the hypothesis test The first step in constructing a hypothesis test is to be clear about what the null and alternative hypotheses are. This isn’t too hard to do. Our null hypothesis, \\(H_0\\), is that the true population mean \\(\\mu\\) for psychology student grades is 67.5; and our alternative hypothesis is that the population mean isn’t 67.5. If we write this in mathematical notation, these hypotheses become: \\[ \\begin{array}{ll} H_0: &amp; \\mu = 67.5 \\\\ H_1: &amp; \\mu \\neq 67.5 \\end{array} \\] though to be honest this notation doesn’t add much to our understanding of the problem, it’s just a compact way of writing down what we’re trying to learn from the data. The null hypotheses \\(H_0\\) and the alternative hypothesis \\(H_1\\) for our test are both illustrated in Figure 6.5. In addition to providing us with these hypotheses, the scenario outlined above provides us with a fair amount of background knowledge that might be useful. Specifically, there are two special pieces of information that we can add: The psychology grades are normally distributed. The true standard deviation of these scores \\(\\sigma\\) is known to be 9.5. For the moment, we’ll act as if these are absolutely trustworthy facts. In real life, this kind of absolutely trustworthy background knowledge doesn’t exist, and so if we want to rely on these facts we’ll just have make the assumption that these things are true. Figure 6.5: Graphical illustration of the null and alternative hypotheses assumed by the one sample \\(z\\)-test (the two sided version, that is). The null and alternative hypotheses both assume that the population distribution is normal, and additionally assumes that the population standard deviation is known (fixed at some value \\(\\sigma_0\\)). The null hypothesis (left) is that the population mean \\(\\mu\\) is equal to some specified value \\(\\mu_0\\). The alternative hypothesis is that the population mean differs from this value, \\(\\mu \\neq \\mu_0\\). The next step is to figure out what we would be a good choice for a diagnostic test statistic; something that would help us discriminate between \\(H_0\\) and \\(H_1\\). Given that the hypotheses all refer to the population mean \\(\\mu\\), you’d feel pretty confident that the sample mean \\(\\bar{X}\\) would be a pretty useful place to start. What we could do, is look at the difference between the sample mean \\(\\bar{X}\\) and the value that the null hypothesis predicts for the population mean. In our example, that would mean we calculate \\(\\bar{X} - 67.5\\). More generally, if we let \\(\\mu_0\\) refer to the value that the null hypothesis claims is our population mean, then we’d want to calculate: \\[ \\bar{X} - \\mu_0 \\] If this quantity equals or is very close to 0, things are looking good for the null hypothesis. If this quantity is a long way away from 0, then it’s looking less likely that the null hypothesis is worth retaining. But how far away from zero should it be for us to reject \\(H_0\\)? To figure that out, we need to be a bit more sneaky, and we’ll need to rely on those two pieces of background knowledge that I wrote down previously, namely that the raw data are normally distributed, and we know the value of the population standard deviation \\(\\sigma\\). If the null hypothesis is actually true, and the true mean is \\(\\mu_0\\), then these facts together mean that we know the complete population distribution of the data: a normal distribution with mean \\(\\mu_0\\) and standard deviation \\(\\sigma\\). Adopting the notation from Section 4.5.3, a statistician might write this as: \\[ X \\sim \\mbox{Normal}(\\mu_0,\\sigma) \\] Okay, if that’s true, then what can we say about the distribution of \\(\\bar{X}\\)? Well, as we discussed earlier (see Section 5.4), the sampling distribution of the mean \\(\\bar{X}\\) is also normal, and has mean \\(\\mu\\). But the standard deviation of this sampling distribution \\(\\mbox{SE}({\\bar{X}})\\), which is called the standard error of the mean, is: \\[ \\mbox{SE}({\\bar{X}}) = \\frac{\\sigma}{\\sqrt{N}} \\] In other words, if the null hypothesis is true then the sampling distribution of the mean can be written as follows: \\[ \\bar{X} \\sim \\mbox{Normal}(\\mu_0,\\mbox{SE}({\\bar{X}})) \\] Now comes the trick. What we can do is convert the sample mean \\(\\bar{X}\\) into a standard score (Section 4.6). This is conventionally written as \\(z\\), but for now I’m going to refer to it as \\(z_{\\bar{X}}\\). (The reason for using this expanded notation is to help you remember that we’re calculating standardised version of a sample mean, not a standardised version of a single observation, which is what a \\(z\\)-score usually refers to). When we do so, the \\(z\\)-score for our sample mean is: \\[ z_{\\bar{X}} = \\frac{\\bar{X} - \\mu_0}{\\mbox{SE}({\\bar{X}})} \\] or, equivalently: \\[ z_{\\bar{X}} = \\frac{\\bar{X} - \\mu_0}{\\sigma / \\sqrt{N}} \\] This \\(z\\)-score is our test statistic. The nice thing about using this as our test statistic is that like all \\(z\\)-scores, it has a standard normal distribution: \\[ z_{\\bar{X}} \\sim \\mbox{Normal}(0,1) \\] In other words, regardless of what scale the original data are on, the \\(z\\)-statistic itself always has the same interpretation: it’s equal to the number of standard errors that separate the observed sample mean \\(\\bar{X}\\) from the population mean \\(\\mu_0\\) predicted by the null hypothesis. Better yet, regardless of what the population parameters for the raw scores actually are, the 5% critical regions for \\(z\\)-test are always the same, as illustrated in Figures 6.6 and 6.7. And what this meant, way back in the days where people did all their statistics by hand, is that someone could publish a table like this: desired \\(\\alpha\\) level two-sided test one-sided test .1 1.644854 1.281552 .05 1.959964 1.644854 .01 2.575829 2.326348 .001 3.290527 3.090232 which in turn meant that researchers could calculate their \\(z\\)-statistic by hand, and then look up the critical value in a text book. That was an incredibly handy thing to be able to do back then, but it’s kind of unnecessary these days, since it’s trivially easy to do it with software like R. Figure 6.6: Rejection regions for the two-sided \\(z\\)-test Figure 6.7: Rejection regions for the one-sided \\(z\\)-test 6.8.3 A worked example using R Now, as I mentioned earlier, the \\(z\\)-test is almost never used in practice. It’s so rarely used in real life that the basic installation of R doesn’t have a built in function for it. However, the test is so incredibly simple that it’s really easy to do one manually. Let’s go back to the data from Dr Zeppo’s class. Having loaded the grades data, the first thing I need to do is calculate the sample mean: sample.mean &lt;- mean( grades ) print(sample.mean) ## [1] 72.3 Then, I create variables corresponding to known population standard deviation (\\(\\sigma = 9.5\\)), and the value of the population mean that the null hypothesis specifies (\\(\\mu_0 = 67.5\\)): mu.null &lt;- 67.5 sd &lt;- 9.5 Let’s also create a variable for the sample size. We could count up the number of observations ourselves, and type N &lt;- 20 at the command prompt, but counting is tedious and repetitive. Let’s get R to do the tedious repetitive bit by using the length() function, which tells us how many elements there are in a vector: N &lt;- length(grades) print(N) ## [1] 20 Next, let’s calculate the standard error of the mean: sem &lt;- sd / sqrt(N) print(sem) ## [1] 2.124265 And finally, we calculate our \\(z\\)-score: z.score &lt;- (sample.mean - mu.null) / sem print(z.score) ## [1] 2.259606 At this point, we would traditionally look up the value 2.26 in our table of critical values. Our original hypothesis was two-sided (we didn’t really have any theory about whether psych students would be better or worse at statistics than other students) so our hypothesis test is two-sided (or two-tailed) also. Looking at the little table that I showed earlier, we can see that 2.26 is bigger than the critical value of 1.96 that would be required to be significant at \\(\\alpha = .05\\), but smaller than the value of 2.58 that would be required to be significant at a level of \\(\\alpha = .01\\). Therefore, we can conclude that we have a significant effect, which we might write up by saying something like this: With a mean grade of 73.2 in the sample of psychology students, and assuming a true population standard deviation of 9.5, we can conclude that the psychology students have significantly different statistics scores to the class average (\\(z = 2.26\\), \\(N=20\\), \\(p&lt;.05\\)). However, what if want an exact \\(p\\)-value? Well, back in the day, the tables of critical values were huge, and so you could look up your actual \\(z\\)-value, and find the smallest value of \\(\\alpha\\) for which your data would be significant. However, looking things up in books is tedious, and typing things into computers is awesome. So let’s do it using R instead. Now, notice that the \\(\\alpha\\) level of a \\(z\\)-test (or any other test, for that matter) defines the total area “under the curve” for the critical region, right? That is, if we set \\(\\alpha = .05\\) for a two-sided test, then the critical region is set up such that the area under the curve for the critical region is \\(.05\\). And, for the \\(z\\)-test, the critical value of 1.96 is chosen that way because the area in the lower tail (i.e., below \\(-1.96\\)) is exactly \\(.025\\) and the area under the upper tail (i.e., above \\(1.96\\)) is exactly \\(.025\\). So, since our observed \\(z\\)-statistic is \\(2.26\\), why not calculate the area under the curve below \\(-2.26\\) or above \\(2.26\\)? In R we can calculate this using the pnorm() function. For the upper tail: upper.area &lt;- pnorm(q = z.score, lower.tail = FALSE) print(upper.area) ## [1] 0.01192287 The lower.tail = FALSE is me telling R to calculate the area under the curve from 2.26 and upwards. If I’d told it that lower.tail = TRUE, then R would calculate the area from 2.26 and below, and it would give me an answer 0.9880771. Alternatively, to calculate the area from \\(-2.26\\) and below, we get lower.area &lt;- pnorm(q = -z.score, lower.tail = TRUE) print(lower.area) ## [1] 0.01192287 Thus we get our \\(p\\)-value: p.value &lt;- lower.area + upper.area print(p.value) ## [1] 0.02384574 6.8.4 Assumptions of the \\(z\\)-test All statistical tests make assumptions. Some tests make reasonable assumptions, while other tests do not. The test I’ve just described – the one sample \\(z\\)-test – makes three basic assumptions. These are: Normality. As usually described, the \\(z\\)-test assumes that the true population distribution is normal.31 is often pretty reasonable, and not only that, it’s an assumption that we can check if we feel worried about it (but not during this course). Independence. The second assumption of the test is that the observations in your data set are not correlated with each other, or related to each other in some funny way. This isn’t as easy to check statistically: it relies a bit on good experimental design. An obvious (and stupid) example of something that violates this assumption is a data set where you “copy” the same observation over and over again in your data file: so you end up with a massive “sample size,” consisting of only one genuine observation. More realistically, you have to ask yourself if it’s really plausible to imagine that each observation is a completely random sample from the population that you’re interested in. In practice, this assumption is never met; but we try our best to design studies that minimise the problems of correlated data. Known standard deviation. The third assumption of the \\(z\\)-test is that the true standard deviation of the population is known to the researcher. This is just stupid. In no real world data analysis problem do you know the standard deviation \\(\\sigma\\) of some population, but are completely ignorant about the mean \\(\\mu\\). In other words, this assumption is always wrong. In view of the stupidity of assuming that \\(\\sigma\\) is known, let’s see if we can live without it. This takes us out of the dreary domain of the \\(z\\)-test, and into the magical kingdom of the \\(t\\)-test, with unicorns and fairies and leprechauns, and um… 6.9 The one-sample \\(t\\)-test After some thought, I decided that it might not be safe to assume that the psychology student grades necessarily have the same standard deviation as the other students in Dr Zeppo’s class. After all, if I’m entertaining the hypothesis that they don’t have the same mean, then why should I believe that they absolutely have the same standard deviation? In view of this, I should really stop assuming that I know the true value of \\(\\sigma\\). This violates the assumptions of my \\(z\\)-test, so in one sense I’m back to square one. However, it’s not like I’m completely bereft of options. After all, I’ve still got my raw data, and those raw data give me an estimate of the population standard deviation: ## [1] 9.520615 In other words, while I can’t say that I know that \\(\\sigma = 9.5\\), I can say that \\(\\hat\\sigma = 9.52\\). Okay, cool. The obvious thing that you might think to do is run a \\(z\\)-test, but using the estimated standard deviation of 9.52 instead of relying on my assumption that the true standard deviation is 9.5. So, we could just type this new number into R and out would come the answer. And you probably wouldn’t be surprised to hear that this would still give us a significant result. This approach is close, but it’s not quite correct. Because we are now relying on an estimate of the population standard deviation, we need to make some adjustment for the fact that we have some uncertainty about what the true population standard deviation actually is. Maybe our data are just a fluke … maybe the true population standard deviation is 11, for instance. But if that were actually true, and we ran the \\(z\\)-test assuming \\(\\sigma=11\\), then the result would end up being non-significant. That’s a problem, and it’s one we’re going to have to address. 6.9.1 Introducing the \\(t\\)-test This ambiguity is annoying, and it was resolved in 1908 by a guy called William Sealy Gosset (Student 1908), who was working as a chemist for the Guinness brewery at the time (see Box 1987). Because Guinness took a dim view of its employees publishing statistical analysis (apparently they felt it was a trade secret), he published the work under the pseudonym “A Student,” and to this day, the full name of the \\(t\\)-test is actually Student’s \\(t\\)-test. The key thing that Gosset figured out is how we should accommodate the fact that we aren’t completely sure what the true standard deviation is.32 The answer is that it subtly changes the sampling distribution. In the \\(t\\)-test, our test statistic (now called a \\(t\\)-statistic) is calculated in exactly the same way I mentioned above. If our null hypothesis is that the true mean is \\(\\mu\\), but our sample has mean \\(\\bar{X}\\) and our estimate of the population standard deviation is \\(\\hat{\\sigma}\\), then our \\(t\\) statistic is: \\[ t = \\frac{\\bar{X} - \\mu}{\\hat{\\sigma}/\\sqrt{N} } \\] The only thing that has changed in the equation is that instead of using the known true value \\(\\sigma\\), we use the estimate \\(\\hat{\\sigma}\\). And if this estimate has been constructed from \\(N\\) observations, then the sampling distribution turns into a \\(t\\)-distribution with \\(N-1\\) degrees of freedom (df). The \\(t\\) distribution is very similar to the normal distribution, but has “heavier” tails, as discussed earlier in Section 4.5.5 and illustrated in Figure 6.8. Notice, though, that as df gets larger, the \\(t\\)-distribution starts to look identical to the standard normal distribution. This is as it should be: if you have a sample size of \\(N = 70,000,000\\) then your “estimate” of the standard deviation would be pretty much perfect, right? So, you should expect that for large \\(N\\), the \\(t\\)-test would behave exactly the same way as a \\(z\\)-test. And that’s exactly what happens! Figure 6.8: The \\(t\\) distribution with 2 degrees of freedom (left) and 10 degrees of freedom (right), with a standard normal distribution (i.e., mean 0 and std dev 1) plotted as dotted lines for comparison purposes. Notice that the \\(t\\) distribution has heavier tails (higher kurtosis) than the normal distribution; this effect is quite exaggerated when the degrees of freedom are very small, but negligible for larger values. In other words, for large \\(df\\) the \\(t\\) distribution is essentially identical to a normal distribution. 6.9.2 Doing the test in R As you might expect, the mechanics of the \\(t\\)-test are almost identical to the mechanics of the \\(z\\)-test. So there’s not much point in going through the tedious exercise of showing you how to do the calculations using low level commands: it’s pretty much identical to the calculations that we did earlier, except that we use the estimated standard deviation (i.e., something like se.est &lt;- sd(grades)), and then we test our hypothesis using the \\(t\\) distribution rather than the normal distribution (i.e. we use pt() rather than pnorm(). During the labs, instead of going through the calculations in tedious detail, for now we’ll jump straight to showing you how \\(t\\)-tests are done in practice using the t.test() command: t.test(grades, mu = 67.5) ## ## One Sample t-test ## ## data: grades ## t = 2.2547, df = 19, p-value = 0.03615 ## alternative hypothesis: true mean is not equal to 67.5 ## 95 percent confidence interval: ## 67.84422 76.75578 ## sample estimates: ## mean of x ## 72.3 So that seems straightforward enough. Now what do we do with this output? Well, since we’re pretending that we actually care about my toy example, we’re overjoyed to discover that the result is statistically significant (i.e. \\(p\\) value below .05). We could report the result by saying something like this: With a mean grade of 72.3, the psychology students scored slightly higher than the average grade of 67.5 (\\(t(19) = 2.25\\), \\(p&lt;.05\\)). 6.9.3 Assumptions of the one sample \\(t\\)-test Okay, so what assumptions does the one-sample \\(t\\)-test make? Well, since the \\(t\\)-test is basically a \\(z\\)-test with the assumption of known standard deviation removed, you shouldn’t be surprised to see that it makes the same assumptions as the \\(z\\)-test, minus the one about the known standard deviation. That is Normality. We’re still assuming that the population distribution (or sampling distribution of the mean) is normal. Independence. Once again, we have to assume that the observations in our sample are generated independently of one another. See the earlier discussion about the \\(z\\)-test for specifics (Section 6.8.4). Overall, these two assumptions aren’t terribly unreasonable, and as a consequence the one-sample \\(t\\)-test is pretty widely used in practice as a way of comparing a sample mean against a hypothesized population mean. 6.10 The independent samples \\(t\\)-test Although the one sample \\(t\\)-test has its uses, it’s not the most typical example of a \\(t\\)-test. A much more common situation arises when you’ve got two different groups of observations. In psychology, this tends to correspond to two different groups of participants, where each group corresponds to a different condition in your study. For each person in the study, you measure some outcome variable of interest, and the research question that you’re asking is whether or not the two groups have the same population mean. This is the situation that the independent samples \\(t\\)-test is designed for. 6.10.1 The data Suppose we have 33 students taking Dr Harpo’s statistics lectures, and Dr Harpo doesn’t grade to a curve. Actually, Dr Harpo’s grading is a bit of a mystery, so we don’t really know anything about what the average grade is for the class as a whole. There are two tutors for the class, Anastasia and Bernadette. There are \\(N_1 = 15\\) students in Anastasia’s tutorials, and \\(N_2 = 18\\) in Bernadette’s tutorials. The research question I’m interested in is whether Anastasia or Bernadette is a better tutor, or if it doesn’t make much of a difference. Dr Harpo emails me the course grades as a data.frame: ## Rows: 33 ## Columns: 2 ## $ grade &lt;dbl&gt; 65, 72, 66, 74, 73, 71, 66, 76, 69, 79, 73, 62, 83, 76, 69, 68,… ## $ tutor &lt;fct&gt; Anastasia, Bernadette, Bernadette, Anastasia, Anastasia, Bernad… As we can see, there’s a single data frame with two variables, grade and tutor. The grade variable is a numeric vector, containing the grades for all \\(N = 33\\) students taking Dr Harpo’s class; the tutor variable is a factor that indicates who each student’s tutor was. The first six observations in this data set are shown below: head(harpo) ## grade tutor ## 1 65 Anastasia ## 2 72 Bernadette ## 3 66 Bernadette ## 4 74 Anastasia ## 5 73 Anastasia ## 6 71 Bernadette We can calculate means and standard deviations, using the mean() and sd() functions. Rather than show the R output, here’s a nice little summary table: mean std dev N Anastasia’s students 74.53 9.00 15 Bernadette’s students 69.06 5.77 18 Since it’s always a good idea to look at your data, I’ve plotted histograms showing the distribution of grades for both tutors (Figure 6.9 and 6.10). Inspection of these histograms suggests that the students in Anastasia’s class may be getting slightly better grades on average, though they also seem a little more variable. Figure 6.9: Histogram showing the overall distribution of grades for students in Anastasia’s class Figure 6.10: Histogram showing the overall distribution of grades for students in Bernadette’s class 6.10.2 Introducing the test The independent samples \\(t\\)-test comes in two different forms: Student’s and Welch’s. The original Student \\(t\\)-test is the simpler of the two, but relies on more restrictive assumptions than the Welch \\(t\\)-test. As such, it is generally advised to use the Welch \\(t\\)-test, which we’ll explain in more detail below. The biggest problem with using the Student test is that it assumes that both groups have the same standard deviation. This is rarely true in real life: if two samples don’t have the same means, why should we expect them to have the same standard deviation? There’s really no reason to expect this assumption to be true. A graphical illustration of what the Welch \\(t\\) test assumes about the data is shown in Figure 6.11. Assuming for the moment that you want to run a two-sided test, the goal is to determine whether two “independent samples” of data are drawn from populations with the same mean (the null hypothesis) or different means (the alternative hypothesis). When we say “independent” samples, what we really mean here is that there’s no special relationship between observations in the two samples. This probably doesn’t make a lot of sense right now, but it will be clearer when we come to talk about the paired samples \\(t\\)-test later on. For now, let’s just point out that if we have an experimental design where participants are randomly allocated to one of two groups, and we want to compare the two groups’ mean performance on some outcome measure, then an independent samples \\(t\\)-test (rather than a paired samples \\(t\\)-test) is what we’re after. Figure 6.11: Graphical illustration of the null and alternative hypotheses assumed by the Welch \\(t\\)-test. Like the Student test we assume that both samples are drawn from a normal population; but the alternative hypothesis no longer requires the two populations to have equal variance. Okay, so let’s let \\(\\mu_1\\) denote the true population mean for group 1 (e.g., Anastasia’s students), and \\(\\mu_2\\) will be the true population mean for group 2 (e.g., Bernadette’s students),33 and as usual we’ll let \\(\\bar{X}_1\\) and \\(\\bar{X}_2\\) denote the observed sample means for both of these groups. Our null hypothesis states that the two population means are identical (\\(\\mu_1 = \\mu_2\\)) and the alternative to this is that they are not (\\(\\mu_1 \\neq \\mu_2\\)). Written in mathematical-ese, this is… \\[ \\begin{array}{ll} H_0: &amp; \\mu_1 = \\mu_2 \\\\ H_1: &amp; \\mu_1 \\neq \\mu_2 \\end{array} \\] To construct a hypothesis test that handles this scenario, we start by noting that if the null hypothesis is true, then the difference between the population means is exactly zero: \\(\\mu_1 - \\mu_2 = 0\\) As a consequence, a diagnostic test statistic will be based on the difference between the two sample means. Because if the null hypothesis is true, then we’d expect \\[\\bar{X}_1 - \\bar{X}_2\\] to be pretty close to zero. However, just like we saw with our one-sample tests (i.e., the one-sample \\(z\\)-test and the one-sample \\(t\\)-test) we have to be precise about exactly how close to zero this difference should be. And the solution to the problem is more or less the same one: we calculate a standard error estimate (SE), just like last time, and then divide the difference between means by this estimate. So our \\(t\\)-statistic will be of the form: \\[t = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\mbox{SE}({\\bar{X}_1 - \\bar{X}_2})}\\] We just need to figure out what the standard error estimate of the difference between sample means actually is. This is a bit trickier than was the case for what we’ve looked at so far, but it works out to this: \\[ \\mbox{SE}({\\bar{X}_1 - \\bar{X}_2}) = \\sqrt{ \\frac{{\\hat{\\sigma}_1}^2}{N_1} + \\frac{{\\hat{\\sigma}_2}^2}{N_2} } \\] Why it’s calculated this way is beyond the scope of this book. In the Welch test, the “degrees of freedom” doesn’t have to be a whole number any more, and it doesn’t correspond all that closely to the “number of data points minus the number of constraints” anymore. The degrees of freedom are, in fact… \\[ \\mbox{df} = \\frac{ ({\\hat{\\sigma}_1}^2 / N_1 + {\\hat{\\sigma}_2}^2 / N_2)^2 }{ ({\\hat{\\sigma}_1}^2 / N_1)^2 / (N_1 -1 ) + ({\\hat{\\sigma}_2}^2 / N_2)^2 / (N_2 -1 ) } \\] … which is all pretty straightforward and obvious, right? Well, perhaps not. It doesn’t really matter for our purposes. Just as we saw with our one-sample test, the sampling distribution of this \\(t\\)-statistic is a \\(t\\)-distribution with the degrees of freedom above as long as the null hypothesis is true, and all of the assumptions of the test are met. 6.10.3 Doing the test in R Not surprisingly, you can run an independent samples \\(t\\)-test using the t.test() function. The exact usage of t.test() for independent samples will be explained during the lab, but it looks as follows: t.test( formula = grade ~ tutor, data = harpo ) ## ## Welch Two Sample t-test ## ## data: grade by tutor ## t = 2.0342, df = 23.025, p-value = 0.05361 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.09249349 11.04804904 ## sample estimates: ## mean in group Anastasia mean in group Bernadette ## 74.53333 69.05556 The output has a very familiar form. First, it tells you what test was run, and it tells you the names of the variables that you used. The second part of the output reports the sample means and standard deviations for both groups (i.e., both tutorial groups). The third section of the output states the null hypothesis and the alternative hypothesis in a fairly explicit form. It then reports the test results: just like last time, the test results consist of a \\(t\\)-statistic, the degrees of freedom, the \\(p\\)-value and a confidence interval. It’s pretty important to be clear on what this confidence interval actually refers to: it is a confidence interval for the difference between the group means. In our example, Anastasia’s students had an average grade of 74.5, and Bernadette’s students had an average grade of 69.1, so the difference between the two sample means is 5.4. But of course the difference between population means might be bigger or smaller than this. The confidence interval tells you that there’s a 95% chance that the true difference between means lies between -0.1 and 11.0. In any case, the difference between the two groups is not significant (just barely), so we might write up the result using text like this: The mean grade in Anastasia’s class was 74.5%, whereas the mean in Bernadette’s class was 69.1%. A Welch’s independent samples \\(t\\)-test showed that this difference was not significant (\\(t(23.03) = 2.03\\), \\(p&lt;.05\\), \\(CI_{95} = [-0.1, 11.0]\\)). 6.10.4 Positive and negative \\(t\\) values Before moving on to talk about the assumptions of the \\(t\\)-test, there’s one additional point I want to make about the use of \\(t\\)-tests in practice. The first one relates to the sign of the \\(t\\)-statistic (that is, whether it is a positive number or a negative one). One very common worry that students have when they start running their first \\(t\\)-test is that they often end up with negative values for the \\(t\\)-statistic, and don’t know how to interpret it. In fact, it’s not at all uncommon for two people working independently to end up with R outputs that are almost identical, except that one person has a negative \\(t\\) values and the other one has a positive \\(t\\) value. Assuming that you’re running a two-sided test, then the \\(p\\)-values will be identical. On closer inspection, the students will notice that the confidence intervals also have the opposite signs. This is perfectly okay: whenever this happens, what you’ll find is that the two versions of the R output arise from slightly different ways of running the \\(t\\)-test. What’s happening here is very simple. The \\(t\\)-statistic that R is calculating here is always of the form \\[ t = \\frac{\\mbox{(mean 1)} -\\mbox{(mean 2)}}{ \\mbox{(SE)}} \\] If “mean 1” is larger than “mean 2” the \\(t\\) statistic will be positive, whereas if “mean 2” is larger then the \\(t\\) statistic will be negative. Similarly, the confidence interval that R reports is the confidence interval for the difference “(mean 1) minus (mean 2),” which will be the reverse of what you’d get if you were calculating the confidence interval for the difference “(mean 2) minus (mean 1).” Okay, that’s pretty straightforward when you think about it, but now consider our \\(t\\)-test comparing Anastasia’s class to Bernadette’s class. Which one should we call “mean 1” and which one should we call “mean 2.” It’s arbitrary. However, you really do need to designate one of them as “mean 1” and the other one as “mean 2.” Not surprisingly, the way that R handles this is also pretty arbitrary. In earlier versions of the book I used to try to explain it, but after a while I gave up, because it’s not really all that important, and to be honest I can never remember myself. Whenever I get a significant \\(t\\)-test result, and I want to figure out which mean is the larger one, I don’t try to figure it out by looking at the \\(t\\)-statistic. Why would I bother doing that? It’s foolish. It’s easier just look at the actual group means, since the R output actually shows them! 6.10.5 Assumptions of the test As always, our hypothesis test relies on some assumptions. So what are they? For the Welch t-test there are two assumptions, the first one we saw previously in the context of the one sample \\(t\\)-test (see Section 6.9.3): Normality. Like the one-sample \\(t\\)-test, it is assumed that the data are normally distributed. Specifically, we assume that both groups are normally distributed. Independence. Once again, it is assumed that the observations are independently sampled. In the context of the Welch test this has two aspects to it. Firstly, we assume that the observations within each sample are independent of one another (exactly the same as for the one-sample test). However, we also assume that there are no cross-sample dependencies. If, for instance, it turns out that you included some participants in both experimental conditions of your study (e.g., by accidentally allowing the same person to sign up to different conditions), then there are some cross sample dependencies that you’d need to take into account. 6.11 The paired-samples \\(t\\)-test An independent samples \\(t\\)-test is intended to be used in a situation where you have two samples that are, well, independent of one another. This situation arises naturally when participants are assigned randomly to one of two experimental conditions, but it provides a very poor approximation to other sorts of research designs. In particular, a repeated measures design – in which each participant is measured (with respect to the same outcome variable) in both experimental conditions – is not suited for analysis using independent samples \\(t\\)-tests. For example, we might be interested in whether listening to music reduces people’s working memory capacity. To that end, we could measure each person’s working memory capacity in two conditions: with music, and without music. In an experimental design such as this one each participant appears in both groups. This requires us to approach the problem in a different way; by using the paired samples \\(t\\)-test. 6.11.1 The data The data set that we’ll use this time comes from Dr Chico’s class.34 In her class, students take two major tests, one early in the semester and one later in the semester. To hear her tell it, she runs a very hard class, one that most students find very challenging; but she argues that by setting hard assessments, students are encouraged to work harder. Her theory is that the first test is a bit of a “wake up call” for students: when they realise how hard her class really is, they’ll work harder for the second test and get a better mark. Is she right? To test this, let’s have a look at the data.frame she sent me: glimpse(chico) ## Rows: 20 ## Columns: 3 ## $ id &lt;fct&gt; student1, student2, student3, student4, student5, student… ## $ grade_test1 &lt;dbl&gt; 42.9, 51.8, 71.7, 51.6, 63.5, 58.0, 59.8, 50.8, 62.5, 61.… ## $ grade_test2 &lt;dbl&gt; 44.6, 54.0, 72.3, 53.4, 63.8, 59.3, 60.8, 51.6, 64.3, 63.… The data frame chico contains three variables: an id variable that identifies each student in the class, the grade_test1 variable that records the student grade for the first test, and the grade_test2 variable that has the grades for the second test. Here’s the first six students: head(chico) ## id grade_test1 grade_test2 ## 1 student1 42.9 44.6 ## 2 student2 51.8 54.0 ## 3 student3 71.7 72.3 ## 4 student4 51.6 53.4 ## 5 student5 63.5 63.8 ## 6 student6 58.0 59.3 At a glance, it does seem like the class is a hard one (most grades are between 50% and 60%), but it does look like there’s an improvement from the first test to the second one. If we take a quick look at the descriptive statistics: chico %&gt;% summarise(n = length(grade_test1), mean_grade_test1 = mean(grade_test1), sd_grade_test1 = sd(grade_test1), mean_grade_test2 = mean(grade_test2), sd_grade_test2 = sd(grade_test2),) %&gt;% knitr::kable() n mean_grade_test1 sd_grade_test1 mean_grade_test2 sd_grade_test2 20 56.98 6.616137 58.385 6.405612 we see that this impression seems to be supported. Across all 20 students the mean grade for the first test is 57%, but this rises to 58% for the second test. Although, given that the standard deviations are 6.6% and 6.4% respectively, it’s starting to feel like maybe the improvement is just illusory; maybe just random variation. This impression is reinforced when you see the means and confidence intervals plotted in Figure 6.12. If we were to rely on this plot alone, we’d come to the same conclusion that we got from looking at the descriptive statistics. Looking at how wide those confidence intervals are, we’d be tempted to think that the apparent improvement in student performance is pure chance. Figure 6.12: Mean grade for test 1 and test 2, with associated 95% confidence intervals Nevertheless, this impression is wrong. To see why, take a look at the scatterplot of the grades for test 1 against the grades for test 2. shown in Figure 6.13. Figure 6.13: Scatterplot showing the individual grades for test 1 and test 2 In this plot, each dot corresponds to the two grades for a given student: if their grade for test 1 (\\(x\\) co-ordinate) equals their grade for test 2 (\\(y\\) co-ordinate), then the dot falls on the line. Points falling above the line are the students that performed better on the second test. Critically, almost all of the data points fall above the diagonal line: almost all of the students do seem to have improved their grade, if only by a small amount. This suggests that we should be looking at the improvement made by each student from one test to the next, and treating that as our raw data. To do this, we’ll need to create a new variable for the improvement that each student makes, and add it to the chico data frame. The easiest way to do this is as follows: chico$improvement &lt;- chico$grade_test2 - chico$grade_test1 Notice that I assigned the output to a variable called chico$improvement. That has the effect of creating a new variable called improvement inside the chico data frame. So now when I look at the chico data frame, I get an output that looks like this: head(chico) ## id grade_test1 grade_test2 improvement ## 1 student1 42.9 44.6 1.7 ## 2 student2 51.8 54.0 2.2 ## 3 student3 71.7 72.3 0.6 ## 4 student4 51.6 53.4 1.8 ## 5 student5 63.5 63.8 0.3 ## 6 student6 58.0 59.3 1.3 Now that we’ve created and stored this improvement variable, we can draw a histogram showing the distribution of these improvement scores, shown in Figure 6.14. Figure 6.14: Histogram showing the improvement made by each student in Dr Chico’s class. Notice that almost the entire distribution is above zero: the vast majority of students did improve their performance from the first test to the second one When we look at histogram, it’s very clear that there is a real improvement here. The vast majority of the students scored higher on test 2 than on test 1, reflected in the fact that almost the entire histogram is above zero. So you can see, qualitatively, what’s going on: there is a real “within student” improvement (everyone improves by about 1%), but it is very small when set against the quite large “between student” differences (student grades vary by about 20% or so). 6.11.2 What is the paired samples \\(t\\)-test? In light of the previous exploration, let’s think about how to construct an appropriate \\(t\\) test. One possibility would be to try to run an independent samples \\(t\\)-test using grade_test1 and grade_test2 as the variables of interest. However, this is clearly the wrong thing to do: the independent samples \\(t\\)-test assumes that there is no particular relationship between the two samples. Yet clearly that’s not true in this case, because of the repeated measures structure to the data. To use the language that I introduced in the last section, if we were to try to do an independent samples \\(t\\)-test, we would be conflating the within subject differences (which is what we’re interested in testing) with the between subject variability (which we are not). The solution to the problem is obvious, I hope, since we already did all the hard work in the previous section. Instead of running an independent samples \\(t\\)-test on grade_test1 and grade_test2, we run a one-sample \\(t\\)-test on the within-subject difference variable, improvement. To formalise this slightly, if \\(X_{i1}\\) is the score that the \\(i\\)-th participant obtained on the first variable, and \\(X_{i2}\\) is the score that the same person obtained on the second one, then the difference score is: \\[ D_{i} = X_{i1} - X_{i2} \\] Notice that the difference scores is variable 1 minus variable 2 and not the other way around, so if we want improvement to correspond to a positive valued difference, we actually want “test 2” to be our “variable 1.” Equally, we would say that \\(\\mu_D = \\mu_1 - \\mu_2\\) is the population mean for this difference variable. So, to convert this to a hypothesis test, our null hypothesis is that this mean difference is zero; the alternative hypothesis is that it is not: \\[ \\begin{array}{ll} H_0: &amp; \\mu_D = 0 \\\\ H_1: &amp; \\mu_D \\neq 0 \\end{array} \\] (this is assuming we’re talking about a two-sided test here). This is more or less identical to the way we described the hypotheses for the one-sample \\(t\\)-test: the only difference is that the specific value that the null hypothesis predicts is 0. And so our \\(t\\)-statistic is defined in more or less the same way too. If we let \\(\\bar{D}\\) denote the mean of the difference scores, then \\[ t = \\frac{\\bar{D}}{\\mbox{SE}({\\bar{D}})} \\] which is \\[ t = \\frac{\\bar{D}}{\\hat\\sigma_D / \\sqrt{N}} \\] where \\(\\hat\\sigma_D\\) is the standard deviation of the difference scores. Since this is just an ordinary, one-sample \\(t\\)-test, with nothing special about it, the degrees of freedom are still \\(N-1\\). And that’s it: the paired samples \\(t\\)-test really isn’t a new test at all: it’s a one-sample \\(t\\)-test, but applied to the difference between two variables. It’s actually very simple; the only reason it merits a discussion as long as the one we’ve just gone through is that you need to be able to recognise when a paired samples test is appropriate, and to understand why it’s better than an independent samples \\(t\\) test. 6.11.3 Doing the test in R How do you do a paired samples \\(t\\)-test in R. One possibility is to follow the process I outlined above: create a “difference” variable and then run a one sample \\(t\\)-test on that. Since we’ve already created a variable called chico$improvement, let’s do that: t.test(chico$improvement, mu=0) ## ## One Sample t-test ## ## data: chico$improvement ## t = 6.4754, df = 19, p-value = 3.321e-06 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## 0.9508686 1.8591314 ## sample estimates: ## mean of x ## 1.405 Alternatively you could do the following, giving you the exact same output: t.test( x = chico$grade_test2, # variable 1 is the &quot;test2&quot; scores y = chico$grade_test1, # variable 2 is the &quot;test1&quot; scores paired = TRUE # paired test ) ## ## Paired t-test ## ## data: chico$grade_test2 and chico$grade_test1 ## t = 6.4754, df = 19, p-value = 3.321e-06 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 0.9508686 1.8591314 ## sample estimates: ## mean of the differences ## 1.405 6.12 That’s it for this week… … and for new materials during this course. Null hypothesis significance testing (NHST) is one of the most ubiquitous elements to statistical theory. The vast majority of scientific papers report the results of some hypothesis test or another. As a consequence it is almost impossible to get by in science without having at least a cursory understanding of NHST and what a \\(p\\)-value means. During the labs we will walk through the formal steps of conducting NHSTs (\\(t\\)-tests in particular), use R to run tests on our own data and discuss some of things to be mindful of when conducting statistical tests. As a reminder, there are additional practice materials for this week on SOWISO. The materials on SOWISO have a slightly different take on NHST and show you how to do many of the calculations we do in R by hand. Adapted nearly verbatim from Chapter 11 and 13 in Navarro, D. “Learning Statistics with R.” R code from Emily Kothe’s Bookdown adaptation of Learning statistics with R↩︎ The quote comes from Wittgenstein’s (1922) text, Tractatus Logico-Philosphicus.↩︎ My apologies to anyone who actually believes in this stuff, but on my reading of the literature on ESP, it’s just not reasonable to think this is real. To be fair, though, some of the studies are rigorously designed; so it’s actually an interesting area for thinking about psychological research design. And of course it’s a free country, so you can spend your own time and effort proving me wrong if you like, but I wouldn’t think that’s a terribly practical use of your intellect.↩︎ \\(\\frac{1}{0.5^{10}}\\) or try it in R: dbinom(10,10,0.5)↩︎ An aside regarding the language you use to talk about hypothesis testing. Firstly, one thing you really want to avoid is the word “prove”: a statistical test really doesn’t prove that a hypothesis is true or false. Proof implies certainty, and as the saying goes, statistics means never having to say you’re certain. On that point almost everyone would agree. However, beyond that there’s a fair amount of confusion. Some people argue that you’re only allowed to make statements like “rejected the null,” “failed to reject the null,” or possibly “retained the null.” According to this line of thinking, you can’t say things like “accept the alternative” or “accept the null.” Personally I think this is too strong: in my opinion, this conflates null hypothesis testing with Karl Popper’s falsificationist view of the scientific process. While there are similarities between falsificationism and null hypothesis testing, they aren’t equivalent. However, while I personally think it’s fine to talk about accepting a hypothesis (on the proviso that “acceptance” doesn’t actually mean that it’s necessarily true, especially in the case of the null hypothesis), many people will disagree. And more to the point, you should be aware that this particular weirdness exists, so that you’re not caught unaware by it when writing up your own results.↩︎ Strictly speaking, the test I just constructed has \\(\\alpha = .057\\), which is a bit too generous. However, if I’d chosen 39 and 61 to be the boundaries for the critical region, then the critical region only covers 3.5% of the distribution. I figured that it makes more sense to use 40 and 60 as my critical values, and be willing to tolerate a 5.7% type I error rate, since that’s as close as I can get to a value of \\(\\alpha = .05\\).↩︎ The internet seems fairly convinced that Ashley said this, though I can’t for the life of me find anyone willing to give a source for the claim.↩︎ Note that the p here has nothing to do with a \\(p\\) value. The p argument in the binom.test() function corresponds to the probability of making a correct response, according to the null hypothesis. In other words, it’s the \\(\\theta\\) value.↩︎ Actually this is too strong. Strictly speaking the \\(z\\) test only requires that the sampling distribution of the mean be normally distributed; if the population is normal then it necessarily follows that the sampling distribution of the mean is also normal. However, as we saw when talking about the central limit theorem, it’s quite possible (even commonplace) for the sampling distribution to be normal even if the population distribution itself is non-normal. However, in light of the sheer ridiculousness of the assumption that the true standard deviation is known, there really isn’t much point in going into details on this front!↩︎ Well, sort of. As I understand the history, Gosset only provided a partial solution: the general solution to the problem was provided by… Sir Ronald Fisher.↩︎ A funny question almost always pops up at this point: what the heck is the population being referred to in this case? Is it the set of students actually taking Dr Harpo’s class (all 33 of them)? The set of people who might take the class (an unknown number) of them? Or something else? Does it matter which of these we pick? It’s traditional in an introductory behavioural stats class to mumble a lot at this point, but since I get asked this question every year by my students, I’ll give a brief answer. Technically yes, it does matter: if you change your definition of what the “real world” population actually is, then the sampling distribution of your observed mean \\(\\bar{X}\\) changes too. The \\(t\\)-test relies on an assumption that the observations are sampled at random from an infinitely large population; and to the extent that real life isn’t like that, then the \\(t\\)-test can be wrong. In practice, however, this isn’t usually a big deal: even though the assumption is almost always wrong, it doesn’t lead to a lot of pathological behaviour from the test, so we tend to just ignore it.↩︎ At this point we have Drs Harpo, Chico and Zeppo. No prizes for guessing who Dr Groucho is.↩︎ "],["references.html", " 7 References", " 7 References Adair, G. 1984. “The Hawthorne Effect: A Reconsideration of the Methodological Artifact.” Journal of Applied Psychology 69: 334–45. Anscombe, F. J. 1973. “Graphs in Statistical Analysis.” American Statistician 27: 17–21. Becker, Gary S. 2009. Human Capital: A Theoretical and Empirical Analysis, with Special Reference to Education. University of Chicago press. Bickel, P. J., E. A. Hammel, and J. W. O’Connell. 1975. “Sex Bias in Graduate Admissions: Data from Berkeley.” Science 187: 398–404. Box, Joan Fisher. 1987. “Guinness, Gosset, Fisher, and Small Samples.” Statistical Science, 45–52. Campbell, D. T., and J. C. Stanley. 1963. Experimental and Quasi-Experimental Designs for Research. Boston, MA: Houghton Mifflin. Evans, J. St. B. T., J. L. Barston, and P. Pollard. 1983. “On the Conflict Between Logic and Belief in Syllogistic Reasoning.” Memory and Cognition 11: 295–306. Fisher, R. A. 1922. “On the Interpretation of Chi-Squared from Contingency Tables, and the Calculation of p.” Journal of the Royal Statistical Society 84: 87–94. Fuente, Angel de la. 2011. “Human Capital and Productivity.” Hothersall, D. 2004. History of Psychology. McGraw-Hill. Kahneman, D., and A. Tversky. 1973. “On the Psychology of Prediction.” Psychological Review 80: 237–51. Kampelmann, Stephan, François Rycx, Yves Saks, and Ilan Tojerow. 2018. “Does Education Raise Productivity and Wages Equally? The Moderating Role of Age and Gender.” IZA Journal of Labor Economics 7 (1): 1. Keynes, John Maynard. 1923. A Tract on Monetary Reform. London: Macmillan; Company. Matejka, Justin, and George Fitzmaurice. 2017. “Same Stats, Different Graphs: Generating Datasets with Varied Appearance and Identical Statistics Through Simulated Annealing.” In Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems, 1290–94. ACM. Meehl, P. H. 1967. “Theory Testing in Psychology and Physics: A Methodological Paradox.” Philosophy of Science 34: 103–15. Pfungst, O. 1911. Clever Hans (The Horse of Mr. Von Osten): A Contribution to Experimental Animal and Human Psychology. Translated by C. L. Rahn. New York: Henry Holt. Rosenthal, R. 1966. Experimenter Effects in Behavioral Research. New York: Appleton. Rowland, Michael L. 1990. “Self-Reported Weight and Height.” The American Journal of Clinical Nutrition 52 (6): 1125–33. Salsburg, David. 2001. The Lady Tasting Tea: How Statistics Revolutionized Science in the Twentieth Century. Macmillan. Student. 1908. “The Probable Error of a Mean.” Biometrika, 1–25. Vaus, D. de. 2001. Research Design in Social Research. Research Methods Series. SAGE Publications. "]]
